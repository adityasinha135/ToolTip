{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { debug } from './Debug.js';\nimport { TargetCloseError, ProtocolError } from './Errors.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { debugError } from './util.js';\nconst debugProtocolSend = debug('puppeteer:protocol:SEND ►');\nconst debugProtocolReceive = debug('puppeteer:protocol:RECV ◀');\n/**\n * Internal events that the Connection class emits.\n *\n * @internal\n */\nexport const ConnectionEmittedEvents = {\n  Disconnected: Symbol('Connection.Disconnected')\n};\n/**\n * @internal\n */\nfunction createIncrementalIdGenerator() {\n  let id = 0;\n  return () => {\n    return ++id;\n  };\n}\n/**\n * @internal\n */\nexport class Callback {\n  #id;\n  #error = new ProtocolError();\n  #deferred = Deferred.create();\n  #timer;\n  #label;\n  constructor(id, label, timeout) {\n    this.#id = id;\n    this.#label = label;\n    if (timeout) {\n      this.#timer = setTimeout(() => {\n        this.#deferred.reject(rewriteError(this.#error, `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));\n      }, timeout);\n    }\n  }\n  resolve(value) {\n    clearTimeout(this.#timer);\n    this.#deferred.resolve(value);\n  }\n  reject(error) {\n    clearTimeout(this.#timer);\n    this.#deferred.reject(error);\n  }\n  get id() {\n    return this.#id;\n  }\n  get promise() {\n    return this.#deferred;\n  }\n  get error() {\n    return this.#error;\n  }\n  get label() {\n    return this.#label;\n  }\n}\n/**\n * Manages callbacks and their IDs for the protocol request/response communication.\n *\n * @internal\n */\nexport class CallbackRegistry {\n  #callbacks = new Map();\n  #idGenerator = createIncrementalIdGenerator();\n  create(label, timeout, request) {\n    const callback = new Callback(this.#idGenerator(), label, timeout);\n    this.#callbacks.set(callback.id, callback);\n    try {\n      request(callback.id);\n    } catch (error) {\n      // We still throw sync errors synchronously and clean up the scheduled\n      // callback.\n      callback.promise.valueOrThrow().catch(debugError).finally(() => {\n        this.#callbacks.delete(callback.id);\n      });\n      callback.reject(error);\n      throw error;\n    }\n    // Must only have sync code up until here.\n    return callback.promise.valueOrThrow().finally(() => {\n      this.#callbacks.delete(callback.id);\n    });\n  }\n  reject(id, message, originalMessage) {\n    const callback = this.#callbacks.get(id);\n    if (!callback) {\n      return;\n    }\n    this._reject(callback, message, originalMessage);\n  }\n  _reject(callback, errorMessage, originalMessage) {\n    const isError = errorMessage instanceof ProtocolError;\n    const message = isError ? errorMessage.message : errorMessage;\n    const error = isError ? errorMessage : callback.error;\n    callback.reject(rewriteError(error, `Protocol error (${callback.label}): ${message}`, originalMessage));\n  }\n  resolve(id, value) {\n    const callback = this.#callbacks.get(id);\n    if (!callback) {\n      return;\n    }\n    callback.resolve(value);\n  }\n  clear() {\n    for (const callback of this.#callbacks.values()) {\n      // TODO: probably we can accept error messages as params.\n      this._reject(callback, new TargetCloseError('Target closed'));\n    }\n    this.#callbacks.clear();\n  }\n}\n/**\n * @public\n */\nexport class Connection extends EventEmitter {\n  #url;\n  #transport;\n  #delay;\n  #timeout;\n  #sessions = new Map();\n  #closed = false;\n  #manuallyAttached = new Set();\n  #callbacks = new CallbackRegistry();\n  constructor(url, transport, delay = 0, timeout) {\n    super();\n    this.#url = url;\n    this.#delay = delay;\n    this.#timeout = timeout ?? 180000;\n    this.#transport = transport;\n    this.#transport.onmessage = this.onMessage.bind(this);\n    this.#transport.onclose = this.#onClose.bind(this);\n  }\n  static fromSession(session) {\n    return session.connection();\n  }\n  get timeout() {\n    return this.#timeout;\n  }\n  /**\n   * @internal\n   */\n  get _closed() {\n    return this.#closed;\n  }\n  /**\n   * @internal\n   */\n  get _sessions() {\n    return this.#sessions;\n  }\n  /**\n   * @param sessionId - The session id\n   * @returns The current CDP session if it exists\n   */\n  session(sessionId) {\n    return this.#sessions.get(sessionId) || null;\n  }\n  url() {\n    return this.#url;\n  }\n  send(method, ...paramArgs) {\n    // There is only ever 1 param arg passed, but the Protocol defines it as an\n    // array of 0 or 1 items See this comment:\n    // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285\n    // which explains why the protocol defines the params this way for better\n    // type-inference.\n    // So now we check if there are any params or not and deal with them accordingly.\n    const params = paramArgs.length ? paramArgs[0] : undefined;\n    return this._rawSend(this.#callbacks, method, params);\n  }\n  /**\n   * @internal\n   */\n  _rawSend(callbacks, method, params, sessionId) {\n    return callbacks.create(method, this.#timeout, id => {\n      const stringifiedMessage = JSON.stringify({\n        method,\n        params,\n        id,\n        sessionId\n      });\n      debugProtocolSend(stringifiedMessage);\n      this.#transport.send(stringifiedMessage);\n    });\n  }\n  /**\n   * @internal\n   */\n  async closeBrowser() {\n    await this.send('Browser.close');\n  }\n  /**\n   * @internal\n   */\n  async onMessage(message) {\n    if (this.#delay) {\n      await new Promise(f => {\n        return setTimeout(f, this.#delay);\n      });\n    }\n    debugProtocolReceive(message);\n    const object = JSON.parse(message);\n    if (object.method === 'Target.attachedToTarget') {\n      const sessionId = object.params.sessionId;\n      const session = new CDPSessionImpl(this, object.params.targetInfo.type, sessionId);\n      this.#sessions.set(sessionId, session);\n      this.emit('sessionattached', session);\n      const parentSession = this.#sessions.get(object.sessionId);\n      if (parentSession) {\n        parentSession.emit('sessionattached', session);\n      }\n    } else if (object.method === 'Target.detachedFromTarget') {\n      const session = this.#sessions.get(object.params.sessionId);\n      if (session) {\n        session._onClosed();\n        this.#sessions.delete(object.params.sessionId);\n        this.emit('sessiondetached', session);\n        const parentSession = this.#sessions.get(object.sessionId);\n        if (parentSession) {\n          parentSession.emit('sessiondetached', session);\n        }\n      }\n    }\n    if (object.sessionId) {\n      const session = this.#sessions.get(object.sessionId);\n      if (session) {\n        session._onMessage(object);\n      }\n    } else if (object.id) {\n      if (object.error) {\n        this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);\n      } else {\n        this.#callbacks.resolve(object.id, object.result);\n      }\n    } else {\n      this.emit(object.method, object.params);\n    }\n  }\n  #onClose() {\n    if (this.#closed) {\n      return;\n    }\n    this.#closed = true;\n    this.#transport.onmessage = undefined;\n    this.#transport.onclose = undefined;\n    this.#callbacks.clear();\n    for (const session of this.#sessions.values()) {\n      session._onClosed();\n    }\n    this.#sessions.clear();\n    this.emit(ConnectionEmittedEvents.Disconnected);\n  }\n  dispose() {\n    this.#onClose();\n    this.#transport.close();\n  }\n  /**\n   * @internal\n   */\n  isAutoAttached(targetId) {\n    return !this.#manuallyAttached.has(targetId);\n  }\n  /**\n   * @internal\n   */\n  async _createSession(targetInfo, isAutoAttachEmulated = true) {\n    if (!isAutoAttachEmulated) {\n      this.#manuallyAttached.add(targetInfo.targetId);\n    }\n    const {\n      sessionId\n    } = await this.send('Target.attachToTarget', {\n      targetId: targetInfo.targetId,\n      flatten: true\n    });\n    this.#manuallyAttached.delete(targetInfo.targetId);\n    const session = this.#sessions.get(sessionId);\n    if (!session) {\n      throw new Error('CDPSession creation failed.');\n    }\n    return session;\n  }\n  /**\n   * @param targetInfo - The target info\n   * @returns The CDP session that is created\n   */\n  async createSession(targetInfo) {\n    return await this._createSession(targetInfo, false);\n  }\n}\n/**\n * Internal events that the CDPSession class emits.\n *\n * @internal\n */\nexport const CDPSessionEmittedEvents = {\n  Disconnected: Symbol('CDPSession.Disconnected')\n};\n/**\n * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.\n *\n * @remarks\n *\n * Protocol methods can be called with {@link CDPSession.send} method and protocol\n * events can be subscribed to with `CDPSession.on` method.\n *\n * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}\n * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/HEAD/README.md | Getting Started with DevTools Protocol}.\n *\n * @example\n *\n * ```ts\n * const client = await page.target().createCDPSession();\n * await client.send('Animation.enable');\n * client.on('Animation.animationCreated', () =>\n *   console.log('Animation created!')\n * );\n * const response = await client.send('Animation.getPlaybackRate');\n * console.log('playback rate is ' + response.playbackRate);\n * await client.send('Animation.setPlaybackRate', {\n *   playbackRate: response.playbackRate / 2,\n * });\n * ```\n *\n * @public\n */\nexport class CDPSession extends EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n  connection() {\n    throw new Error('Not implemented');\n  }\n  send() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  async detach() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Returns the session's id.\n   */\n  id() {\n    throw new Error('Not implemented');\n  }\n}\n/**\n * @internal\n */\nexport class CDPSessionImpl extends CDPSession {\n  #sessionId;\n  #targetType;\n  #callbacks = new CallbackRegistry();\n  #connection;\n  /**\n   * @internal\n   */\n  constructor(connection, targetType, sessionId) {\n    super();\n    this.#connection = connection;\n    this.#targetType = targetType;\n    this.#sessionId = sessionId;\n  }\n  connection() {\n    return this.#connection;\n  }\n  send(method, ...paramArgs) {\n    if (!this.#connection) {\n      return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${this.#targetType} has been closed.`));\n    }\n    // See the comment in Connection#send explaining why we do this.\n    const params = paramArgs.length ? paramArgs[0] : undefined;\n    return this.#connection._rawSend(this.#callbacks, method, params, this.#sessionId);\n  }\n  /**\n   * @internal\n   */\n  _onMessage(object) {\n    if (object.id) {\n      if (object.error) {\n        this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);\n      } else {\n        this.#callbacks.resolve(object.id, object.result);\n      }\n    } else {\n      assert(!object.id);\n      this.emit(object.method, object.params);\n    }\n  }\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  async detach() {\n    if (!this.#connection) {\n      throw new Error(`Session already detached. Most likely the ${this.#targetType} has been closed.`);\n    }\n    await this.#connection.send('Target.detachFromTarget', {\n      sessionId: this.#sessionId\n    });\n  }\n  /**\n   * @internal\n   */\n  _onClosed() {\n    this.#callbacks.clear();\n    this.#connection = undefined;\n    this.emit(CDPSessionEmittedEvents.Disconnected);\n  }\n  /**\n   * Returns the session's id.\n   */\n  id() {\n    return this.#sessionId;\n  }\n}\nfunction createProtocolErrorMessage(object) {\n  let message = `${object.error.message}`;\n  // TODO: remove the type checks when we stop connecting to BiDi with a CDP\n  // client.\n  if (object.error && typeof object.error === 'object' && 'data' in object.error) {\n    message += ` ${object.error.data}`;\n  }\n  return message;\n}\nfunction rewriteError(error, message, originalMessage) {\n  error.message = message;\n  error.originalMessage = originalMessage ?? error.originalMessage;\n  return error;\n}\n/**\n * @internal\n */\nexport function isTargetClosedError(error) {\n  return error instanceof TargetCloseError;\n}","map":{"version":3,"names":["assert","Deferred","debug","TargetCloseError","ProtocolError","EventEmitter","debugError","debugProtocolSend","debugProtocolReceive","ConnectionEmittedEvents","Disconnected","Symbol","createIncrementalIdGenerator","id","Callback","error","deferred","create","timer","label","constructor","timeout","setTimeout","reject","rewriteError","resolve","value","clearTimeout","promise","CallbackRegistry","callbacks","Map","idGenerator","request","callback","set","valueOrThrow","catch","finally","delete","message","originalMessage","get","_reject","errorMessage","isError","clear","values","Connection","url","transport","delay","sessions","closed","manuallyAttached","Set","onmessage","onMessage","bind","onclose","onClose","fromSession","session","connection","_closed","_sessions","sessionId","send","method","paramArgs","params","length","undefined","_rawSend","stringifiedMessage","JSON","stringify","closeBrowser","Promise","f","object","parse","CDPSessionImpl","targetInfo","type","emit","parentSession","_onClosed","_onMessage","createProtocolErrorMessage","result","#onClose","dispose","close","isAutoAttached","targetId","has","_createSession","isAutoAttachEmulated","add","flatten","Error","createSession","CDPSessionEmittedEvents","CDPSession","detach","targetType","data","isTargetClosedError"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/Connection.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Protocol} from 'devtools-protocol';\nimport {ProtocolMapping} from 'devtools-protocol/types/protocol-mapping.js';\n\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\n\nimport {ConnectionTransport} from './ConnectionTransport.js';\nimport {debug} from './Debug.js';\nimport {TargetCloseError, ProtocolError} from './Errors.js';\nimport {EventEmitter} from './EventEmitter.js';\nimport {debugError} from './util.js';\n\nconst debugProtocolSend = debug('puppeteer:protocol:SEND ►');\nconst debugProtocolReceive = debug('puppeteer:protocol:RECV ◀');\n\n/**\n * @public\n */\nexport {ConnectionTransport, ProtocolMapping};\n\n/**\n * Internal events that the Connection class emits.\n *\n * @internal\n */\nexport const ConnectionEmittedEvents = {\n  Disconnected: Symbol('Connection.Disconnected'),\n} as const;\n\n/**\n * @internal\n */\ntype GetIdFn = () => number;\n\n/**\n * @internal\n */\nfunction createIncrementalIdGenerator(): GetIdFn {\n  let id = 0;\n  return (): number => {\n    return ++id;\n  };\n}\n\n/**\n * @internal\n */\nexport class Callback {\n  #id: number;\n  #error = new ProtocolError();\n  #deferred = Deferred.create<unknown>();\n  #timer?: ReturnType<typeof setTimeout>;\n  #label: string;\n\n  constructor(id: number, label: string, timeout?: number) {\n    this.#id = id;\n    this.#label = label;\n    if (timeout) {\n      this.#timer = setTimeout(() => {\n        this.#deferred.reject(\n          rewriteError(\n            this.#error,\n            `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`\n          )\n        );\n      }, timeout);\n    }\n  }\n\n  resolve(value: unknown): void {\n    clearTimeout(this.#timer);\n    this.#deferred.resolve(value);\n  }\n\n  reject(error: Error): void {\n    clearTimeout(this.#timer);\n    this.#deferred.reject(error);\n  }\n\n  get id(): number {\n    return this.#id;\n  }\n\n  get promise(): Deferred<unknown> {\n    return this.#deferred;\n  }\n\n  get error(): ProtocolError {\n    return this.#error;\n  }\n\n  get label(): string {\n    return this.#label;\n  }\n}\n\n/**\n * Manages callbacks and their IDs for the protocol request/response communication.\n *\n * @internal\n */\nexport class CallbackRegistry {\n  #callbacks = new Map<number, Callback>();\n  #idGenerator = createIncrementalIdGenerator();\n\n  create(\n    label: string,\n    timeout: number | undefined,\n    request: (id: number) => void\n  ): Promise<unknown> {\n    const callback = new Callback(this.#idGenerator(), label, timeout);\n    this.#callbacks.set(callback.id, callback);\n    try {\n      request(callback.id);\n    } catch (error) {\n      // We still throw sync errors synchronously and clean up the scheduled\n      // callback.\n      callback.promise\n        .valueOrThrow()\n        .catch(debugError)\n        .finally(() => {\n          this.#callbacks.delete(callback.id);\n        });\n      callback.reject(error as Error);\n      throw error;\n    }\n    // Must only have sync code up until here.\n    return callback.promise.valueOrThrow().finally(() => {\n      this.#callbacks.delete(callback.id);\n    });\n  }\n\n  reject(id: number, message: string, originalMessage?: string): void {\n    const callback = this.#callbacks.get(id);\n    if (!callback) {\n      return;\n    }\n    this._reject(callback, message, originalMessage);\n  }\n\n  _reject(\n    callback: Callback,\n    errorMessage: string | ProtocolError,\n    originalMessage?: string\n  ): void {\n    const isError = errorMessage instanceof ProtocolError;\n    const message = isError ? errorMessage.message : errorMessage;\n    const error = isError ? errorMessage : callback.error;\n\n    callback.reject(\n      rewriteError(\n        error,\n        `Protocol error (${callback.label}): ${message}`,\n        originalMessage\n      )\n    );\n  }\n\n  resolve(id: number, value: unknown): void {\n    const callback = this.#callbacks.get(id);\n    if (!callback) {\n      return;\n    }\n    callback.resolve(value);\n  }\n\n  clear(): void {\n    for (const callback of this.#callbacks.values()) {\n      // TODO: probably we can accept error messages as params.\n      this._reject(callback, new TargetCloseError('Target closed'));\n    }\n    this.#callbacks.clear();\n  }\n}\n\n/**\n * @public\n */\nexport class Connection extends EventEmitter {\n  #url: string;\n  #transport: ConnectionTransport;\n  #delay: number;\n  #timeout: number;\n  #sessions = new Map<string, CDPSessionImpl>();\n  #closed = false;\n  #manuallyAttached = new Set<string>();\n  #callbacks = new CallbackRegistry();\n\n  constructor(\n    url: string,\n    transport: ConnectionTransport,\n    delay = 0,\n    timeout?: number\n  ) {\n    super();\n    this.#url = url;\n    this.#delay = delay;\n    this.#timeout = timeout ?? 180_000;\n\n    this.#transport = transport;\n    this.#transport.onmessage = this.onMessage.bind(this);\n    this.#transport.onclose = this.#onClose.bind(this);\n  }\n\n  static fromSession(session: CDPSession): Connection | undefined {\n    return session.connection();\n  }\n\n  get timeout(): number {\n    return this.#timeout;\n  }\n\n  /**\n   * @internal\n   */\n  get _closed(): boolean {\n    return this.#closed;\n  }\n\n  /**\n   * @internal\n   */\n  get _sessions(): Map<string, CDPSession> {\n    return this.#sessions;\n  }\n\n  /**\n   * @param sessionId - The session id\n   * @returns The current CDP session if it exists\n   */\n  session(sessionId: string): CDPSession | null {\n    return this.#sessions.get(sessionId) || null;\n  }\n\n  url(): string {\n    return this.#url;\n  }\n\n  send<T extends keyof ProtocolMapping.Commands>(\n    method: T,\n    ...paramArgs: ProtocolMapping.Commands[T]['paramsType']\n  ): Promise<ProtocolMapping.Commands[T]['returnType']> {\n    // There is only ever 1 param arg passed, but the Protocol defines it as an\n    // array of 0 or 1 items See this comment:\n    // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285\n    // which explains why the protocol defines the params this way for better\n    // type-inference.\n    // So now we check if there are any params or not and deal with them accordingly.\n    const params = paramArgs.length ? paramArgs[0] : undefined;\n    return this._rawSend(this.#callbacks, method, params);\n  }\n\n  /**\n   * @internal\n   */\n  _rawSend<T extends keyof ProtocolMapping.Commands>(\n    callbacks: CallbackRegistry,\n    method: T,\n    params: ProtocolMapping.Commands[T]['paramsType'][0],\n    sessionId?: string\n  ): Promise<ProtocolMapping.Commands[T]['returnType']> {\n    return callbacks.create(method, this.#timeout, id => {\n      const stringifiedMessage = JSON.stringify({\n        method,\n        params,\n        id,\n        sessionId,\n      });\n      debugProtocolSend(stringifiedMessage);\n      this.#transport.send(stringifiedMessage);\n    }) as Promise<ProtocolMapping.Commands[T]['returnType']>;\n  }\n\n  /**\n   * @internal\n   */\n  async closeBrowser(): Promise<void> {\n    await this.send('Browser.close');\n  }\n\n  /**\n   * @internal\n   */\n  protected async onMessage(message: string): Promise<void> {\n    if (this.#delay) {\n      await new Promise(f => {\n        return setTimeout(f, this.#delay);\n      });\n    }\n    debugProtocolReceive(message);\n    const object = JSON.parse(message);\n    if (object.method === 'Target.attachedToTarget') {\n      const sessionId = object.params.sessionId;\n      const session = new CDPSessionImpl(\n        this,\n        object.params.targetInfo.type,\n        sessionId\n      );\n      this.#sessions.set(sessionId, session);\n      this.emit('sessionattached', session);\n      const parentSession = this.#sessions.get(object.sessionId);\n      if (parentSession) {\n        parentSession.emit('sessionattached', session);\n      }\n    } else if (object.method === 'Target.detachedFromTarget') {\n      const session = this.#sessions.get(object.params.sessionId);\n      if (session) {\n        session._onClosed();\n        this.#sessions.delete(object.params.sessionId);\n        this.emit('sessiondetached', session);\n        const parentSession = this.#sessions.get(object.sessionId);\n        if (parentSession) {\n          parentSession.emit('sessiondetached', session);\n        }\n      }\n    }\n    if (object.sessionId) {\n      const session = this.#sessions.get(object.sessionId);\n      if (session) {\n        session._onMessage(object);\n      }\n    } else if (object.id) {\n      if (object.error) {\n        this.#callbacks.reject(\n          object.id,\n          createProtocolErrorMessage(object),\n          object.error.message\n        );\n      } else {\n        this.#callbacks.resolve(object.id, object.result);\n      }\n    } else {\n      this.emit(object.method, object.params);\n    }\n  }\n\n  #onClose(): void {\n    if (this.#closed) {\n      return;\n    }\n    this.#closed = true;\n    this.#transport.onmessage = undefined;\n    this.#transport.onclose = undefined;\n    this.#callbacks.clear();\n    for (const session of this.#sessions.values()) {\n      session._onClosed();\n    }\n    this.#sessions.clear();\n    this.emit(ConnectionEmittedEvents.Disconnected);\n  }\n\n  dispose(): void {\n    this.#onClose();\n    this.#transport.close();\n  }\n\n  /**\n   * @internal\n   */\n  isAutoAttached(targetId: string): boolean {\n    return !this.#manuallyAttached.has(targetId);\n  }\n\n  /**\n   * @internal\n   */\n  async _createSession(\n    targetInfo: Protocol.Target.TargetInfo,\n    isAutoAttachEmulated = true\n  ): Promise<CDPSession> {\n    if (!isAutoAttachEmulated) {\n      this.#manuallyAttached.add(targetInfo.targetId);\n    }\n    const {sessionId} = await this.send('Target.attachToTarget', {\n      targetId: targetInfo.targetId,\n      flatten: true,\n    });\n    this.#manuallyAttached.delete(targetInfo.targetId);\n    const session = this.#sessions.get(sessionId);\n    if (!session) {\n      throw new Error('CDPSession creation failed.');\n    }\n    return session;\n  }\n\n  /**\n   * @param targetInfo - The target info\n   * @returns The CDP session that is created\n   */\n  async createSession(\n    targetInfo: Protocol.Target.TargetInfo\n  ): Promise<CDPSession> {\n    return await this._createSession(targetInfo, false);\n  }\n}\n\n/**\n * @internal\n */\nexport interface CDPSessionOnMessageObject {\n  id?: number;\n  method: string;\n  params: Record<string, unknown>;\n  error: {message: string; data: any; code: number};\n  result?: any;\n}\n\n/**\n * Internal events that the CDPSession class emits.\n *\n * @internal\n */\nexport const CDPSessionEmittedEvents = {\n  Disconnected: Symbol('CDPSession.Disconnected'),\n} as const;\n\n/**\n * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.\n *\n * @remarks\n *\n * Protocol methods can be called with {@link CDPSession.send} method and protocol\n * events can be subscribed to with `CDPSession.on` method.\n *\n * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}\n * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/HEAD/README.md | Getting Started with DevTools Protocol}.\n *\n * @example\n *\n * ```ts\n * const client = await page.target().createCDPSession();\n * await client.send('Animation.enable');\n * client.on('Animation.animationCreated', () =>\n *   console.log('Animation created!')\n * );\n * const response = await client.send('Animation.getPlaybackRate');\n * console.log('playback rate is ' + response.playbackRate);\n * await client.send('Animation.setPlaybackRate', {\n *   playbackRate: response.playbackRate / 2,\n * });\n * ```\n *\n * @public\n */\nexport class CDPSession extends EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n\n  connection(): Connection | undefined {\n    throw new Error('Not implemented');\n  }\n\n  send<T extends keyof ProtocolMapping.Commands>(\n    method: T,\n    ...paramArgs: ProtocolMapping.Commands[T]['paramsType']\n  ): Promise<ProtocolMapping.Commands[T]['returnType']>;\n  send<T extends keyof ProtocolMapping.Commands>(): Promise<\n    ProtocolMapping.Commands[T]['returnType']\n  > {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  async detach(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Returns the session's id.\n   */\n  id(): string {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * @internal\n */\nexport class CDPSessionImpl extends CDPSession {\n  #sessionId: string;\n  #targetType: string;\n  #callbacks = new CallbackRegistry();\n  #connection?: Connection;\n\n  /**\n   * @internal\n   */\n  constructor(connection: Connection, targetType: string, sessionId: string) {\n    super();\n    this.#connection = connection;\n    this.#targetType = targetType;\n    this.#sessionId = sessionId;\n  }\n\n  override connection(): Connection | undefined {\n    return this.#connection;\n  }\n\n  override send<T extends keyof ProtocolMapping.Commands>(\n    method: T,\n    ...paramArgs: ProtocolMapping.Commands[T]['paramsType']\n  ): Promise<ProtocolMapping.Commands[T]['returnType']> {\n    if (!this.#connection) {\n      return Promise.reject(\n        new TargetCloseError(\n          `Protocol error (${method}): Session closed. Most likely the ${\n            this.#targetType\n          } has been closed.`\n        )\n      );\n    }\n    // See the comment in Connection#send explaining why we do this.\n    const params = paramArgs.length ? paramArgs[0] : undefined;\n    return this.#connection._rawSend(\n      this.#callbacks,\n      method,\n      params,\n      this.#sessionId\n    );\n  }\n\n  /**\n   * @internal\n   */\n  _onMessage(object: CDPSessionOnMessageObject): void {\n    if (object.id) {\n      if (object.error) {\n        this.#callbacks.reject(\n          object.id,\n          createProtocolErrorMessage(object),\n          object.error.message\n        );\n      } else {\n        this.#callbacks.resolve(object.id, object.result);\n      }\n    } else {\n      assert(!object.id);\n      this.emit(object.method, object.params);\n    }\n  }\n\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  override async detach(): Promise<void> {\n    if (!this.#connection) {\n      throw new Error(\n        `Session already detached. Most likely the ${\n          this.#targetType\n        } has been closed.`\n      );\n    }\n    await this.#connection.send('Target.detachFromTarget', {\n      sessionId: this.#sessionId,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _onClosed(): void {\n    this.#callbacks.clear();\n    this.#connection = undefined;\n    this.emit(CDPSessionEmittedEvents.Disconnected);\n  }\n\n  /**\n   * Returns the session's id.\n   */\n  override id(): string {\n    return this.#sessionId;\n  }\n}\n\nfunction createProtocolErrorMessage(object: {\n  error: {message: string; data: any; code: number};\n}): string {\n  let message = `${object.error.message}`;\n  // TODO: remove the type checks when we stop connecting to BiDi with a CDP\n  // client.\n  if (\n    object.error &&\n    typeof object.error === 'object' &&\n    'data' in object.error\n  ) {\n    message += ` ${object.error.data}`;\n  }\n  return message;\n}\n\nfunction rewriteError(\n  error: ProtocolError,\n  message: string,\n  originalMessage?: string\n): Error {\n  error.message = message;\n  error.originalMessage = originalMessage ?? error.originalMessage;\n  return error;\n}\n\n/**\n * @internal\n */\nexport function isTargetClosedError(error: Error): boolean {\n  return error instanceof TargetCloseError;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}