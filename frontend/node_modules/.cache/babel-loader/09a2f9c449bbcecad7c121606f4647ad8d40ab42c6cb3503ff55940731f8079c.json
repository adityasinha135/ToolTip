{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { isTargetClosedError } from './Connection.js';\nimport { DeviceRequestPromptManager } from './DeviceRequestPrompt.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { ExecutionContext } from './ExecutionContext.js';\nimport { Frame as CDPFrame } from './Frame.js';\nimport { FrameTree } from './FrameTree.js';\nimport { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';\nimport { NetworkManager } from './NetworkManager.js';\nimport { debugError, PuppeteerURL } from './util.js';\n/**\n * @internal\n */\nexport const UTILITY_WORLD_NAME = '__puppeteer_utility_world__';\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const FrameManagerEmittedEvents = {\n  FrameAttached: Symbol('FrameManager.FrameAttached'),\n  FrameNavigated: Symbol('FrameManager.FrameNavigated'),\n  FrameDetached: Symbol('FrameManager.FrameDetached'),\n  FrameSwapped: Symbol('FrameManager.FrameSwapped'),\n  LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),\n  FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),\n  ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),\n  ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed')\n};\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter {\n  #page;\n  #networkManager;\n  #timeoutSettings;\n  #contextIdToContext = new Map();\n  #isolatedWorlds = new Set();\n  #client;\n  /**\n   * @internal\n   */\n  _frameTree = new FrameTree();\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set();\n  #deviceRequestPromptManagerMap = new WeakMap();\n  get timeoutSettings() {\n    return this.#timeoutSettings;\n  }\n  get networkManager() {\n    return this.#networkManager;\n  }\n  get client() {\n    return this.#client;\n  }\n  constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(client, ignoreHTTPSErrors, this);\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n  }\n  setupEventListeners(session) {\n    session.on('Page.frameAttached', event => {\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      void this.#onFrameNavigated(event.frame);\n    });\n    session.on('Page.navigatedWithinDocument', event => {\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on('Page.frameDetached', event => {\n      this.#onFrameDetached(event.frameId, event.reason);\n    });\n    session.on('Page.frameStartedLoading', event => {\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', event => {\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', event => {\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', event => {\n      this.#onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', () => {\n      this.#onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', event => {\n      this.#onLifecycleEvent(event);\n    });\n  }\n  async initialize(client = this.#client) {\n    try {\n      const result = await Promise.all([client.send('Page.enable'), client.send('Page.getFrameTree')]);\n      const {\n        frameTree\n      } = result[1];\n      this.#handleFrameTree(client, frameTree);\n      await Promise.all([client.send('Page.setLifecycleEventsEnabled', {\n        enabled: true\n      }), client.send('Runtime.enable').then(() => {\n        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n      }),\n      // TODO: Network manager is not aware of OOP iframes yet.\n      client === this.#client ? this.#networkManager.initialize() : Promise.resolve()]);\n    } catch (error) {\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  executionContextById(contextId, session = this.#client) {\n    const context = this.getExecutionContextById(contextId, session);\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n  getExecutionContextById(contextId, session = this.#client) {\n    return this.#contextIdToContext.get(`${session.id()}:${contextId}`);\n  }\n  page() {\n    return this.#page;\n  }\n  mainFrame() {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n  frames() {\n    return Array.from(this._frameTree.frames());\n  }\n  frame(frameId) {\n    return this._frameTree.getById(frameId) || null;\n  }\n  onAttachedToTarget(target) {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session());\n    }\n    this.setupEventListeners(target._session());\n    void this.initialize(target._session());\n  }\n  /**\n   * @internal\n   */\n  _deviceRequestPromptManager(client) {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n  #onLifecycleEvent(event) {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n  #onFrameStartedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n  #onFrameStoppedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n  #handleFrameTree(session, frameTree) {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame);\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n    if (!frameTree.childFrames) {\n      return;\n    }\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n  #onFrameAttached(session, frameId, parentFrameId) {\n    let frame = this.frame(frameId);\n    if (frame) {\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n    frame = new CDPFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEmittedEvents.FrameAttached, frame);\n  }\n  async #onFrameNavigated(framePayload) {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n    let frame = this._frameTree.getById(frameId);\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CDPFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n  async #createIsolatedWorld(session, name) {\n    const key = `${session.id()}:${name}`;\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name\n    });\n    await Promise.all(this.frames().filter(frame => {\n      return frame._client() === session;\n    }).map(frame => {\n      // Frames might be removed before we send this, so we don't want to\n      // throw an error.\n      return session.send('Page.createIsolatedWorld', {\n        frameId: frame._id,\n        worldName: name,\n        grantUniveralAccess: true\n      }).catch(debugError);\n    }));\n    this.#isolatedWorlds.add(key);\n  }\n  #onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);\n    this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n  #onFrameDetached(frameId, reason) {\n    const frame = this.frame(frameId);\n    if (reason === 'remove') {\n      // Only remove the frame if the reason for the detached event is\n      // an actual removement of the frame.\n      // For frames that become OOP iframes, the reason would be 'swap'.\n      if (frame) {\n        this.#removeFramesRecursively(frame);\n      }\n    } else if (reason === 'swap') {\n      this.emit(FrameManagerEmittedEvents.FrameSwapped, frame);\n    }\n  }\n  #onExecutionContextCreated(contextPayload, session) {\n    const auxData = contextPayload.auxData;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame._client() !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[PUPPETEER_WORLD].hasContext()) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    const context = new ExecutionContext(frame?._client() || this.#client, contextPayload, world);\n    if (world) {\n      world.setContext(context);\n    }\n    const key = `${session.id()}:${contextPayload.id}`;\n    this.#contextIdToContext.set(key, context);\n  }\n  #onExecutionContextDestroyed(executionContextId, session) {\n    const key = `${session.id()}:${executionContextId}`;\n    const context = this.#contextIdToContext.get(key);\n    if (!context) {\n      return;\n    }\n    this.#contextIdToContext.delete(key);\n    if (context._world) {\n      context._world.clearContext();\n    }\n  }\n  #onExecutionContextsCleared(session) {\n    for (const [key, context] of this.#contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) {\n        continue;\n      }\n      if (context._world) {\n        context._world.clearContext();\n      }\n      this.#contextIdToContext.delete(key);\n    }\n  }\n  #removeFramesRecursively(frame) {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame._detach();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEmittedEvents.FrameDetached, frame);\n  }\n}","map":{"version":3,"names":["assert","isErrorLike","isTargetClosedError","DeviceRequestPromptManager","EventEmitter","ExecutionContext","Frame","CDPFrame","FrameTree","MAIN_WORLD","PUPPETEER_WORLD","NetworkManager","debugError","PuppeteerURL","UTILITY_WORLD_NAME","FrameManagerEmittedEvents","FrameAttached","Symbol","FrameNavigated","FrameDetached","FrameSwapped","LifecycleEvent","FrameNavigatedWithinDocument","ExecutionContextCreated","ExecutionContextDestroyed","FrameManager","page","networkManager","timeoutSettings","contextIdToContext","Map","isolatedWorlds","Set","client","_frameTree","frameNavigatedReceived","deviceRequestPromptManagerMap","WeakMap","constructor","ignoreHTTPSErrors","setupEventListeners","session","on","event","onFrameAttached","frameId","parentFrameId","add","frame","id","onFrameNavigated","onFrameNavigatedWithinDocument","url","onFrameDetached","reason","onFrameStartedLoading","onFrameStoppedLoading","onExecutionContextCreated","context","onExecutionContextDestroyed","executionContextId","onExecutionContextsCleared","onLifecycleEvent","initialize","result","Promise","all","send","frameTree","handleFrameTree","enabled","then","createIsolatedWorld","resolve","error","executionContextById","contextId","getExecutionContextById","get","mainFrame","getMainFrame","frames","Array","from","getById","onAttachedToTarget","target","_getTargetInfo","type","targetId","updateClient","_session","_deviceRequestPromptManager","manager","undefined","set","#onLifecycleEvent","_onLifecycleEvent","loaderId","name","emit","#onFrameStartedLoading","_onLoadingStarted","#onFrameStoppedLoading","_onLoadingStopped","#handleFrameTree","parentId","has","delete","childFrames","child","#onFrameAttached","isOOPFrame","addFrame","#onFrameNavigated","framePayload","isMainFrame","removeFramesRecursively","removeFrame","_id","waitForFrame","_navigated","#createIsolatedWorld","key","source","INTERNAL_URL","worldName","filter","_client","map","grantUniveralAccess","catch","#onFrameNavigatedWithinDocument","_navigatedWithinDocument","#onFrameDetached","#onExecutionContextCreated","contextPayload","auxData","world","worlds","hasContext","setContext","#onExecutionContextDestroyed","_world","clearContext","#onExecutionContextsCleared","entries","#removeFramesRecursively","_detach"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/FrameManager.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Protocol} from 'devtools-protocol';\n\nimport {Page} from '../api/Page.js';\nimport {assert} from '../util/assert.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\n\nimport {CDPSession, isTargetClosedError} from './Connection.js';\nimport {DeviceRequestPromptManager} from './DeviceRequestPrompt.js';\nimport {EventEmitter} from './EventEmitter.js';\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {Frame} from './Frame.js';\nimport {Frame as CDPFrame} from './Frame.js';\nimport {FrameTree} from './FrameTree.js';\nimport {IsolatedWorld} from './IsolatedWorld.js';\nimport {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {NetworkManager} from './NetworkManager.js';\nimport {CDPTarget} from './Target.js';\nimport {TimeoutSettings} from './TimeoutSettings.js';\nimport {debugError, PuppeteerURL} from './util.js';\n\n/**\n * @internal\n */\nexport const UTILITY_WORLD_NAME = '__puppeteer_utility_world__';\n\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const FrameManagerEmittedEvents = {\n  FrameAttached: Symbol('FrameManager.FrameAttached'),\n  FrameNavigated: Symbol('FrameManager.FrameNavigated'),\n  FrameDetached: Symbol('FrameManager.FrameDetached'),\n  FrameSwapped: Symbol('FrameManager.FrameSwapped'),\n  LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),\n  FrameNavigatedWithinDocument: Symbol(\n    'FrameManager.FrameNavigatedWithinDocument'\n  ),\n  ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),\n  ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed'),\n};\n\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter {\n  #page: Page;\n  #networkManager: NetworkManager;\n  #timeoutSettings: TimeoutSettings;\n  #contextIdToContext = new Map<string, ExecutionContext>();\n  #isolatedWorlds = new Set<string>();\n  #client: CDPSession;\n  /**\n   * @internal\n   */\n  _frameTree = new FrameTree<Frame>();\n\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set<string>();\n\n  #deviceRequestPromptManagerMap = new WeakMap<\n    CDPSession,\n    DeviceRequestPromptManager\n  >();\n\n  get timeoutSettings(): TimeoutSettings {\n    return this.#timeoutSettings;\n  }\n\n  get networkManager(): NetworkManager {\n    return this.#networkManager;\n  }\n\n  get client(): CDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CDPSession,\n    page: Page,\n    ignoreHTTPSErrors: boolean,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(client, ignoreHTTPSErrors, this);\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n  }\n\n  private setupEventListeners(session: CDPSession) {\n    session.on('Page.frameAttached', event => {\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      void this.#onFrameNavigated(event.frame);\n    });\n    session.on('Page.navigatedWithinDocument', event => {\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on(\n      'Page.frameDetached',\n      (event: Protocol.Page.FrameDetachedEvent) => {\n        this.#onFrameDetached(\n          event.frameId,\n          event.reason as Protocol.Page.FrameDetachedEventReason\n        );\n      }\n    );\n    session.on('Page.frameStartedLoading', event => {\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', event => {\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', event => {\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', event => {\n      this.#onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', () => {\n      this.#onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', event => {\n      this.#onLifecycleEvent(event);\n    });\n  }\n\n  async initialize(client: CDPSession = this.#client): Promise<void> {\n    try {\n      const result = await Promise.all([\n        client.send('Page.enable'),\n        client.send('Page.getFrameTree'),\n      ]);\n\n      const {frameTree} = result[1];\n      this.#handleFrameTree(client, frameTree);\n      await Promise.all([\n        client.send('Page.setLifecycleEventsEnabled', {enabled: true}),\n        client.send('Runtime.enable').then(() => {\n          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n        }),\n        // TODO: Network manager is not aware of OOP iframes yet.\n        client === this.#client\n          ? this.#networkManager.initialize()\n          : Promise.resolve(),\n      ]);\n    } catch (error) {\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  executionContextById(\n    contextId: number,\n    session: CDPSession = this.#client\n  ): ExecutionContext {\n    const context = this.getExecutionContextById(contextId, session);\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n\n  getExecutionContextById(\n    contextId: number,\n    session: CDPSession = this.#client\n  ): ExecutionContext | undefined {\n    return this.#contextIdToContext.get(`${session.id()}:${contextId}`);\n  }\n\n  page(): Page {\n    return this.#page;\n  }\n\n  mainFrame(): Frame {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n\n  frames(): Frame[] {\n    return Array.from(this._frameTree.frames());\n  }\n\n  frame(frameId: string): Frame | null {\n    return this._frameTree.getById(frameId) || null;\n  }\n\n  onAttachedToTarget(target: CDPTarget): void {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session()!);\n    }\n    this.setupEventListeners(target._session()!);\n    void this.initialize(target._session());\n  }\n\n  /**\n   * @internal\n   */\n  _deviceRequestPromptManager(client: CDPSession): DeviceRequestPromptManager {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n\n  #onLifecycleEvent(event: Protocol.Page.LifecycleEventEvent): void {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n\n  #onFrameStartedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n\n  #onFrameStoppedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n\n  #handleFrameTree(\n    session: CDPSession,\n    frameTree: Protocol.Page.FrameTree\n  ): void {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(\n        session,\n        frameTree.frame.id,\n        frameTree.frame.parentId\n      );\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame);\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n\n    if (!frameTree.childFrames) {\n      return;\n    }\n\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n\n  #onFrameAttached(\n    session: CDPSession,\n    frameId: string,\n    parentFrameId: string\n  ): void {\n    let frame = this.frame(frameId);\n    if (frame) {\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n\n    frame = new CDPFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEmittedEvents.FrameAttached, frame);\n  }\n\n  async #onFrameNavigated(framePayload: Protocol.Page.Frame): Promise<void> {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n\n    let frame = this._frameTree.getById(frameId);\n\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CDPFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n\n  async #createIsolatedWorld(session: CDPSession, name: string): Promise<void> {\n    const key = `${session.id()}:${name}`;\n\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name,\n    });\n\n    await Promise.all(\n      this.frames()\n        .filter(frame => {\n          return frame._client() === session;\n        })\n        .map(frame => {\n          // Frames might be removed before we send this, so we don't want to\n          // throw an error.\n          return session\n            .send('Page.createIsolatedWorld', {\n              frameId: frame._id,\n              worldName: name,\n              grantUniveralAccess: true,\n            })\n            .catch(debugError);\n        })\n    );\n\n    this.#isolatedWorlds.add(key);\n  }\n\n  #onFrameNavigatedWithinDocument(frameId: string, url: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);\n    this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n\n  #onFrameDetached(\n    frameId: string,\n    reason: Protocol.Page.FrameDetachedEventReason\n  ): void {\n    const frame = this.frame(frameId);\n    if (reason === 'remove') {\n      // Only remove the frame if the reason for the detached event is\n      // an actual removement of the frame.\n      // For frames that become OOP iframes, the reason would be 'swap'.\n      if (frame) {\n        this.#removeFramesRecursively(frame);\n      }\n    } else if (reason === 'swap') {\n      this.emit(FrameManagerEmittedEvents.FrameSwapped, frame);\n    }\n  }\n\n  #onExecutionContextCreated(\n    contextPayload: Protocol.Runtime.ExecutionContextDescription,\n    session: CDPSession\n  ): void {\n    const auxData = contextPayload.auxData as {frameId?: string} | undefined;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world: IsolatedWorld | undefined;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame._client() !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (\n        contextPayload.name === UTILITY_WORLD_NAME &&\n        !frame.worlds[PUPPETEER_WORLD].hasContext()\n      ) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    const context = new ExecutionContext(\n      frame?._client() || this.#client,\n      contextPayload,\n      world\n    );\n    if (world) {\n      world.setContext(context);\n    }\n    const key = `${session.id()}:${contextPayload.id}`;\n    this.#contextIdToContext.set(key, context);\n  }\n\n  #onExecutionContextDestroyed(\n    executionContextId: number,\n    session: CDPSession\n  ): void {\n    const key = `${session.id()}:${executionContextId}`;\n    const context = this.#contextIdToContext.get(key);\n    if (!context) {\n      return;\n    }\n    this.#contextIdToContext.delete(key);\n    if (context._world) {\n      context._world.clearContext();\n    }\n  }\n\n  #onExecutionContextsCleared(session: CDPSession): void {\n    for (const [key, context] of this.#contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) {\n        continue;\n      }\n      if (context._world) {\n        context._world.clearContext();\n      }\n      this.#contextIdToContext.delete(key);\n    }\n  }\n\n  #removeFramesRecursively(frame: Frame): void {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame._detach();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEmittedEvents.FrameDetached, frame);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}