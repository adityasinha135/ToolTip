{"ast":null,"code":"/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ElementHandle } from '../api/ElementHandle.js';\nimport { assert } from '../util/assert.js';\nimport { CDPJSHandle } from './JSHandle.js';\nimport { debugError } from './util.js';\nconst applyOffsetsToQuad = (quad, offsetX, offsetY) => {\n  return quad.map(part => {\n    return {\n      x: part.x + offsetX,\n      y: part.y + offsetY\n    };\n  });\n};\n/**\n * The CDPElementHandle extends ElementHandle now to keep compatibility\n * with `instanceof` because of that we need to have methods for\n * CDPJSHandle to in this implementation as well.\n *\n * @internal\n */\nexport class CDPElementHandle extends ElementHandle {\n  #frame;\n  constructor(context, remoteObject, frame) {\n    super(new CDPJSHandle(context, remoteObject));\n    this.#frame = frame;\n  }\n  /**\n   * @internal\n   */\n  executionContext() {\n    return this.handle.executionContext();\n  }\n  /**\n   * @internal\n   */\n  get client() {\n    return this.handle.client;\n  }\n  remoteObject() {\n    return this.handle.remoteObject();\n  }\n  get #frameManager() {\n    return this.#frame._frameManager;\n  }\n  get #page() {\n    return this.#frame.page();\n  }\n  get frame() {\n    return this.#frame;\n  }\n  async $(selector) {\n    return super.$(selector);\n  }\n  async $$(selector) {\n    return super.$$(selector);\n  }\n  async waitForSelector(selector, options) {\n    return await super.waitForSelector(selector, options);\n  }\n  async contentFrame() {\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: this.id\n    });\n    if (typeof nodeInfo.node.frameId !== 'string') {\n      return null;\n    }\n    return this.#frameManager.frame(nodeInfo.node.frameId);\n  }\n  async scrollIntoView() {\n    await this.assertConnectedElement();\n    try {\n      await this.client.send('DOM.scrollIntoViewIfNeeded', {\n        objectId: this.id\n      });\n    } catch (error) {\n      debugError(error);\n      // Fallback to Element.scrollIntoView if DOM.scrollIntoViewIfNeeded is not supported\n      await super.scrollIntoView();\n    }\n  }\n  async #getOOPIFOffsets(frame) {\n    let offsetX = 0;\n    let offsetY = 0;\n    let currentFrame = frame;\n    while (currentFrame && currentFrame.parentFrame()) {\n      const parent = currentFrame.parentFrame();\n      if (!currentFrame.isOOPFrame() || !parent) {\n        currentFrame = parent;\n        continue;\n      }\n      const {\n        backendNodeId\n      } = await parent._client().send('DOM.getFrameOwner', {\n        frameId: currentFrame._id\n      });\n      const result = await parent._client().send('DOM.getBoxModel', {\n        backendNodeId: backendNodeId\n      });\n      if (!result) {\n        break;\n      }\n      const contentBoxQuad = result.model.content;\n      const topLeftCorner = this.#fromProtocolQuad(contentBoxQuad)[0];\n      offsetX += topLeftCorner.x;\n      offsetY += topLeftCorner.y;\n      currentFrame = parent;\n    }\n    return {\n      offsetX,\n      offsetY\n    };\n  }\n  async clickablePoint(offset) {\n    const [result, layoutMetrics] = await Promise.all([this.client.send('DOM.getContentQuads', {\n      objectId: this.id\n    }).catch(debugError), this.#page._client().send('Page.getLayoutMetrics')]);\n    if (!result || !result.quads.length) {\n      throw new Error('Node is either not clickable or not an HTMLElement');\n    }\n    // Filter out quads that have too small area to click into.\n    // Fallback to `layoutViewport` in case of using Firefox.\n    const {\n      clientWidth,\n      clientHeight\n    } = layoutMetrics.cssLayoutViewport || layoutMetrics.layoutViewport;\n    const {\n      offsetX,\n      offsetY\n    } = await this.#getOOPIFOffsets(this.#frame);\n    const quads = result.quads.map(quad => {\n      return this.#fromProtocolQuad(quad);\n    }).map(quad => {\n      return applyOffsetsToQuad(quad, offsetX, offsetY);\n    }).map(quad => {\n      return this.#intersectQuadWithViewport(quad, clientWidth, clientHeight);\n    }).filter(quad => {\n      return computeQuadArea(quad) > 1;\n    });\n    if (!quads.length) {\n      throw new Error('Node is either not clickable or not an HTMLElement');\n    }\n    const quad = quads[0];\n    if (offset) {\n      // Return the point of the first quad identified by offset.\n      let minX = Number.MAX_SAFE_INTEGER;\n      let minY = Number.MAX_SAFE_INTEGER;\n      for (const point of quad) {\n        if (point.x < minX) {\n          minX = point.x;\n        }\n        if (point.y < minY) {\n          minY = point.y;\n        }\n      }\n      if (minX !== Number.MAX_SAFE_INTEGER && minY !== Number.MAX_SAFE_INTEGER) {\n        return {\n          x: minX + offset.x,\n          y: minY + offset.y\n        };\n      }\n    }\n    // Return the middle point of the first quad.\n    let x = 0;\n    let y = 0;\n    for (const point of quad) {\n      x += point.x;\n      y += point.y;\n    }\n    return {\n      x: x / 4,\n      y: y / 4\n    };\n  }\n  #getBoxModel() {\n    const params = {\n      objectId: this.id\n    };\n    return this.client.send('DOM.getBoxModel', params).catch(error => {\n      return debugError(error);\n    });\n  }\n  #fromProtocolQuad(quad) {\n    return [{\n      x: quad[0],\n      y: quad[1]\n    }, {\n      x: quad[2],\n      y: quad[3]\n    }, {\n      x: quad[4],\n      y: quad[5]\n    }, {\n      x: quad[6],\n      y: quad[7]\n    }];\n  }\n  #intersectQuadWithViewport(quad, width, height) {\n    return quad.map(point => {\n      return {\n        x: Math.min(Math.max(point.x, 0), width),\n        y: Math.min(Math.max(point.y, 0), height)\n      };\n    });\n  }\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async hover() {\n    await this.scrollIntoViewIfNeeded();\n    const {\n      x,\n      y\n    } = await this.clickablePoint();\n    await this.#page.mouse.move(x, y);\n  }\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to click in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async click(options = {}) {\n    await this.scrollIntoViewIfNeeded();\n    const {\n      x,\n      y\n    } = await this.clickablePoint(options.offset);\n    await this.#page.mouse.click(x, y, options);\n  }\n  /**\n   * This method creates and captures a dragevent from the element.\n   */\n  async drag(target) {\n    assert(this.#page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');\n    await this.scrollIntoViewIfNeeded();\n    const start = await this.clickablePoint();\n    return await this.#page.mouse.drag(start, target);\n  }\n  async dragEnter(data = {\n    items: [],\n    dragOperationsMask: 1\n  }) {\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await this.#page.mouse.dragEnter(target, data);\n  }\n  async dragOver(data = {\n    items: [],\n    dragOperationsMask: 1\n  }) {\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await this.#page.mouse.dragOver(target, data);\n  }\n  async drop(data = {\n    items: [],\n    dragOperationsMask: 1\n  }) {\n    await this.scrollIntoViewIfNeeded();\n    const destination = await this.clickablePoint();\n    await this.#page.mouse.drop(destination, data);\n  }\n  async dragAndDrop(target, options) {\n    assert(this.#page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');\n    await this.scrollIntoViewIfNeeded();\n    const startPoint = await this.clickablePoint();\n    const targetPoint = await target.clickablePoint();\n    await this.#page.mouse.dragAndDrop(startPoint, targetPoint, options);\n  }\n  async uploadFile(...filePaths) {\n    const isMultiple = await this.evaluate(element => {\n      return element.multiple;\n    });\n    assert(filePaths.length <= 1 || isMultiple, 'Multiple file uploads only work with <input type=file multiple>');\n    // Locate all files and confirm that they exist.\n    let path;\n    try {\n      path = await import('path');\n    } catch (error) {\n      if (error instanceof TypeError) {\n        throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);\n      }\n      throw error;\n    }\n    const files = filePaths.map(filePath => {\n      if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {\n        return filePath;\n      } else {\n        return path.resolve(filePath);\n      }\n    });\n    const {\n      node\n    } = await this.client.send('DOM.describeNode', {\n      objectId: this.id\n    });\n    const {\n      backendNodeId\n    } = node;\n    /*  The zero-length array is a special case, it seems that\n         DOM.setFileInputFiles does not actually update the files in that case,\n         so the solution is to eval the element value to a new FileList directly.\n     */\n    if (files.length === 0) {\n      await this.evaluate(element => {\n        element.files = new DataTransfer().files;\n        // Dispatch events for this case because it should behave akin to a user action.\n        element.dispatchEvent(new Event('input', {\n          bubbles: true\n        }));\n        element.dispatchEvent(new Event('change', {\n          bubbles: true\n        }));\n      });\n    } else {\n      await this.client.send('DOM.setFileInputFiles', {\n        objectId: this.id,\n        files,\n        backendNodeId\n      });\n    }\n  }\n  async tap() {\n    await this.scrollIntoViewIfNeeded();\n    const {\n      x,\n      y\n    } = await this.clickablePoint();\n    await this.#page.touchscreen.touchStart(x, y);\n    await this.#page.touchscreen.touchEnd();\n  }\n  async touchStart() {\n    await this.scrollIntoViewIfNeeded();\n    const {\n      x,\n      y\n    } = await this.clickablePoint();\n    await this.#page.touchscreen.touchStart(x, y);\n  }\n  async touchMove() {\n    await this.scrollIntoViewIfNeeded();\n    const {\n      x,\n      y\n    } = await this.clickablePoint();\n    await this.#page.touchscreen.touchMove(x, y);\n  }\n  async touchEnd() {\n    await this.scrollIntoViewIfNeeded();\n    await this.#page.touchscreen.touchEnd();\n  }\n  async type(text, options) {\n    await this.focus();\n    await this.#page.keyboard.type(text, options);\n  }\n  async press(key, options) {\n    await this.focus();\n    await this.#page.keyboard.press(key, options);\n  }\n  async boundingBox() {\n    const result = await this.#getBoxModel();\n    if (!result) {\n      return null;\n    }\n    const {\n      offsetX,\n      offsetY\n    } = await this.#getOOPIFOffsets(this.#frame);\n    const quad = result.model.border;\n    const x = Math.min(quad[0], quad[2], quad[4], quad[6]);\n    const y = Math.min(quad[1], quad[3], quad[5], quad[7]);\n    const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;\n    const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;\n    return {\n      x: x + offsetX,\n      y: y + offsetY,\n      width,\n      height\n    };\n  }\n  async boxModel() {\n    const result = await this.#getBoxModel();\n    if (!result) {\n      return null;\n    }\n    const {\n      offsetX,\n      offsetY\n    } = await this.#getOOPIFOffsets(this.#frame);\n    const {\n      content,\n      padding,\n      border,\n      margin,\n      width,\n      height\n    } = result.model;\n    return {\n      content: applyOffsetsToQuad(this.#fromProtocolQuad(content), offsetX, offsetY),\n      padding: applyOffsetsToQuad(this.#fromProtocolQuad(padding), offsetX, offsetY),\n      border: applyOffsetsToQuad(this.#fromProtocolQuad(border), offsetX, offsetY),\n      margin: applyOffsetsToQuad(this.#fromProtocolQuad(margin), offsetX, offsetY),\n      width,\n      height\n    };\n  }\n  async screenshot(options = {}) {\n    let needsViewportReset = false;\n    let boundingBox = await this.boundingBox();\n    assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n    const viewport = this.#page.viewport();\n    if (viewport && (boundingBox.width > viewport.width || boundingBox.height > viewport.height)) {\n      const newViewport = {\n        width: Math.max(viewport.width, Math.ceil(boundingBox.width)),\n        height: Math.max(viewport.height, Math.ceil(boundingBox.height))\n      };\n      await this.#page.setViewport(Object.assign({}, viewport, newViewport));\n      needsViewportReset = true;\n    }\n    await this.scrollIntoViewIfNeeded();\n    boundingBox = await this.boundingBox();\n    assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n    assert(boundingBox.width !== 0, 'Node has 0 width.');\n    assert(boundingBox.height !== 0, 'Node has 0 height.');\n    const layoutMetrics = await this.client.send('Page.getLayoutMetrics');\n    // Fallback to `layoutViewport` in case of using Firefox.\n    const {\n      pageX,\n      pageY\n    } = layoutMetrics.cssVisualViewport || layoutMetrics.layoutViewport;\n    const clip = Object.assign({}, boundingBox);\n    clip.x += pageX;\n    clip.y += pageY;\n    const imageData = await this.#page.screenshot(Object.assign({}, {\n      clip\n    }, options));\n    if (needsViewportReset && viewport) {\n      await this.#page.setViewport(viewport);\n    }\n    return imageData;\n  }\n  async autofill(data) {\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: this.handle.id\n    });\n    const fieldId = nodeInfo.node.backendNodeId;\n    const frameId = this.#frame._id;\n    await this.client.send('Autofill.trigger', {\n      fieldId,\n      frameId,\n      card: data.creditCard\n    });\n  }\n}\nfunction computeQuadArea(quad) {\n  /* Compute sum of all directed areas of adjacent triangles\n     https://en.wikipedia.org/wiki/Polygon#Simple_polygons\n   */\n  let area = 0;\n  for (let i = 0; i < quad.length; ++i) {\n    const p1 = quad[i];\n    const p2 = quad[(i + 1) % quad.length];\n    area += (p1.x * p2.y - p2.x * p1.y) / 2;\n  }\n  return Math.abs(area);\n}","map":{"version":3,"names":["ElementHandle","assert","CDPJSHandle","debugError","applyOffsetsToQuad","quad","offsetX","offsetY","map","part","x","y","CDPElementHandle","frame","constructor","context","remoteObject","executionContext","handle","client","frameManager","#frameManager","_frameManager","page","#page","$","selector","$$","waitForSelector","options","contentFrame","nodeInfo","send","objectId","id","node","frameId","scrollIntoView","assertConnectedElement","error","getOOPIFOffsets","#getOOPIFOffsets","currentFrame","parentFrame","parent","isOOPFrame","backendNodeId","_client","_id","result","contentBoxQuad","model","content","topLeftCorner","fromProtocolQuad","clickablePoint","offset","layoutMetrics","Promise","all","catch","quads","length","Error","clientWidth","clientHeight","cssLayoutViewport","layoutViewport","intersectQuadWithViewport","filter","computeQuadArea","minX","Number","MAX_SAFE_INTEGER","minY","point","getBoxModel","#getBoxModel","params","#fromProtocolQuad","#intersectQuadWithViewport","width","height","Math","min","max","hover","scrollIntoViewIfNeeded","mouse","move","click","drag","target","isDragInterceptionEnabled","start","dragEnter","data","items","dragOperationsMask","dragOver","drop","destination","dragAndDrop","startPoint","targetPoint","uploadFile","filePaths","isMultiple","evaluate","element","multiple","path","TypeError","files","filePath","win32","isAbsolute","posix","resolve","DataTransfer","dispatchEvent","Event","bubbles","tap","touchscreen","touchStart","touchEnd","touchMove","type","text","focus","keyboard","press","key","boundingBox","border","boxModel","padding","margin","screenshot","needsViewportReset","viewport","newViewport","ceil","setViewport","Object","assign","pageX","pageY","cssVisualViewport","clip","imageData","autofill","fieldId","card","creditCard","area","i","p1","p2","abs"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/ElementHandle.ts"],"sourcesContent":["/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Protocol} from 'devtools-protocol';\n\nimport {\n  AutofillData,\n  BoundingBox,\n  BoxModel,\n  ClickOptions,\n  ElementHandle,\n  Offset,\n  Point,\n} from '../api/ElementHandle.js';\nimport {KeyPressOptions, KeyboardTypeOptions} from '../api/Input.js';\nimport {Page, ScreenshotOptions} from '../api/Page.js';\nimport {assert} from '../util/assert.js';\n\nimport {CDPSession} from './Connection.js';\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {Frame} from './Frame.js';\nimport {FrameManager} from './FrameManager.js';\nimport {WaitForSelectorOptions} from './IsolatedWorld.js';\nimport {CDPJSHandle} from './JSHandle.js';\nimport {CDPPage} from './Page.js';\nimport {NodeFor} from './types.js';\nimport {KeyInput} from './USKeyboardLayout.js';\nimport {debugError} from './util.js';\n\nconst applyOffsetsToQuad = (\n  quad: Point[],\n  offsetX: number,\n  offsetY: number\n) => {\n  return quad.map(part => {\n    return {x: part.x + offsetX, y: part.y + offsetY};\n  });\n};\n\n/**\n * The CDPElementHandle extends ElementHandle now to keep compatibility\n * with `instanceof` because of that we need to have methods for\n * CDPJSHandle to in this implementation as well.\n *\n * @internal\n */\nexport class CDPElementHandle<\n  ElementType extends Node = Element,\n> extends ElementHandle<ElementType> {\n  #frame: Frame;\n  declare handle: CDPJSHandle<ElementType>;\n\n  constructor(\n    context: ExecutionContext,\n    remoteObject: Protocol.Runtime.RemoteObject,\n    frame: Frame\n  ) {\n    super(new CDPJSHandle(context, remoteObject));\n    this.#frame = frame;\n  }\n\n  /**\n   * @internal\n   */\n  override executionContext(): ExecutionContext {\n    return this.handle.executionContext();\n  }\n\n  /**\n   * @internal\n   */\n  override get client(): CDPSession {\n    return this.handle.client;\n  }\n\n  override remoteObject(): Protocol.Runtime.RemoteObject {\n    return this.handle.remoteObject();\n  }\n\n  get #frameManager(): FrameManager {\n    return this.#frame._frameManager;\n  }\n\n  get #page(): Page {\n    return this.#frame.page();\n  }\n\n  override get frame(): Frame {\n    return this.#frame;\n  }\n\n  override async $<Selector extends string>(\n    selector: Selector\n  ): Promise<CDPElementHandle<NodeFor<Selector>> | null> {\n    return super.$(selector) as Promise<CDPElementHandle<\n      NodeFor<Selector>\n    > | null>;\n  }\n\n  override async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<CDPElementHandle<NodeFor<Selector>>>> {\n    return super.$$(selector) as Promise<\n      Array<CDPElementHandle<NodeFor<Selector>>>\n    >;\n  }\n\n  override async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options?: WaitForSelectorOptions\n  ): Promise<CDPElementHandle<NodeFor<Selector>> | null> {\n    return (await super.waitForSelector(selector, options)) as CDPElementHandle<\n      NodeFor<Selector>\n    > | null;\n  }\n\n  override async contentFrame(): Promise<Frame | null> {\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: this.id,\n    });\n    if (typeof nodeInfo.node.frameId !== 'string') {\n      return null;\n    }\n    return this.#frameManager.frame(nodeInfo.node.frameId);\n  }\n\n  override async scrollIntoView(\n    this: CDPElementHandle<Element>\n  ): Promise<void> {\n    await this.assertConnectedElement();\n    try {\n      await this.client.send('DOM.scrollIntoViewIfNeeded', {\n        objectId: this.id,\n      });\n    } catch (error) {\n      debugError(error);\n      // Fallback to Element.scrollIntoView if DOM.scrollIntoViewIfNeeded is not supported\n      await super.scrollIntoView();\n    }\n  }\n\n  async #getOOPIFOffsets(\n    frame: Frame\n  ): Promise<{offsetX: number; offsetY: number}> {\n    let offsetX = 0;\n    let offsetY = 0;\n    let currentFrame: Frame | null = frame;\n    while (currentFrame && currentFrame.parentFrame()) {\n      const parent = currentFrame.parentFrame();\n      if (!currentFrame.isOOPFrame() || !parent) {\n        currentFrame = parent;\n        continue;\n      }\n      const {backendNodeId} = await parent._client().send('DOM.getFrameOwner', {\n        frameId: currentFrame._id,\n      });\n      const result = await parent._client().send('DOM.getBoxModel', {\n        backendNodeId: backendNodeId,\n      });\n      if (!result) {\n        break;\n      }\n      const contentBoxQuad = result.model.content;\n      const topLeftCorner = this.#fromProtocolQuad(contentBoxQuad)[0];\n      offsetX += topLeftCorner!.x;\n      offsetY += topLeftCorner!.y;\n      currentFrame = parent;\n    }\n    return {offsetX, offsetY};\n  }\n\n  override async clickablePoint(offset?: Offset): Promise<Point> {\n    const [result, layoutMetrics] = await Promise.all([\n      this.client\n        .send('DOM.getContentQuads', {\n          objectId: this.id,\n        })\n        .catch(debugError),\n      (this.#page as CDPPage)._client().send('Page.getLayoutMetrics'),\n    ]);\n    if (!result || !result.quads.length) {\n      throw new Error('Node is either not clickable or not an HTMLElement');\n    }\n    // Filter out quads that have too small area to click into.\n    // Fallback to `layoutViewport` in case of using Firefox.\n    const {clientWidth, clientHeight} =\n      layoutMetrics.cssLayoutViewport || layoutMetrics.layoutViewport;\n    const {offsetX, offsetY} = await this.#getOOPIFOffsets(this.#frame);\n    const quads = result.quads\n      .map(quad => {\n        return this.#fromProtocolQuad(quad);\n      })\n      .map(quad => {\n        return applyOffsetsToQuad(quad, offsetX, offsetY);\n      })\n      .map(quad => {\n        return this.#intersectQuadWithViewport(quad, clientWidth, clientHeight);\n      })\n      .filter(quad => {\n        return computeQuadArea(quad) > 1;\n      });\n    if (!quads.length) {\n      throw new Error('Node is either not clickable or not an HTMLElement');\n    }\n    const quad = quads[0]!;\n    if (offset) {\n      // Return the point of the first quad identified by offset.\n      let minX = Number.MAX_SAFE_INTEGER;\n      let minY = Number.MAX_SAFE_INTEGER;\n      for (const point of quad) {\n        if (point.x < minX) {\n          minX = point.x;\n        }\n        if (point.y < minY) {\n          minY = point.y;\n        }\n      }\n      if (\n        minX !== Number.MAX_SAFE_INTEGER &&\n        minY !== Number.MAX_SAFE_INTEGER\n      ) {\n        return {\n          x: minX + offset.x,\n          y: minY + offset.y,\n        };\n      }\n    }\n    // Return the middle point of the first quad.\n    let x = 0;\n    let y = 0;\n    for (const point of quad) {\n      x += point.x;\n      y += point.y;\n    }\n    return {\n      x: x / 4,\n      y: y / 4,\n    };\n  }\n\n  #getBoxModel(): Promise<void | Protocol.DOM.GetBoxModelResponse> {\n    const params: Protocol.DOM.GetBoxModelRequest = {\n      objectId: this.id,\n    };\n    return this.client.send('DOM.getBoxModel', params).catch(error => {\n      return debugError(error);\n    });\n  }\n\n  #fromProtocolQuad(quad: number[]): Point[] {\n    return [\n      {x: quad[0]!, y: quad[1]!},\n      {x: quad[2]!, y: quad[3]!},\n      {x: quad[4]!, y: quad[5]!},\n      {x: quad[6]!, y: quad[7]!},\n    ];\n  }\n\n  #intersectQuadWithViewport(\n    quad: Point[],\n    width: number,\n    height: number\n  ): Point[] {\n    return quad.map(point => {\n      return {\n        x: Math.min(Math.max(point.x, 0), width),\n        y: Math.min(Math.max(point.y, 0), height),\n      };\n    });\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  override async hover(this: CDPElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.#page.mouse.move(x, y);\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to click in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  override async click(\n    this: CDPElementHandle<Element>,\n    options: Readonly<ClickOptions> = {}\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint(options.offset);\n    await this.#page.mouse.click(x, y, options);\n  }\n\n  /**\n   * This method creates and captures a dragevent from the element.\n   */\n  override async drag(\n    this: CDPElementHandle<Element>,\n    target: Point\n  ): Promise<Protocol.Input.DragData> {\n    assert(\n      this.#page.isDragInterceptionEnabled(),\n      'Drag Interception is not enabled!'\n    );\n    await this.scrollIntoViewIfNeeded();\n    const start = await this.clickablePoint();\n    return await this.#page.mouse.drag(start, target);\n  }\n\n  override async dragEnter(\n    this: CDPElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await this.#page.mouse.dragEnter(target, data);\n  }\n\n  override async dragOver(\n    this: CDPElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await this.#page.mouse.dragOver(target, data);\n  }\n\n  override async drop(\n    this: CDPElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const destination = await this.clickablePoint();\n    await this.#page.mouse.drop(destination, data);\n  }\n\n  override async dragAndDrop(\n    this: CDPElementHandle<Element>,\n    target: CDPElementHandle<Node>,\n    options?: {delay: number}\n  ): Promise<void> {\n    assert(\n      this.#page.isDragInterceptionEnabled(),\n      'Drag Interception is not enabled!'\n    );\n    await this.scrollIntoViewIfNeeded();\n    const startPoint = await this.clickablePoint();\n    const targetPoint = await target.clickablePoint();\n    await this.#page.mouse.dragAndDrop(startPoint, targetPoint, options);\n  }\n\n  override async uploadFile(\n    this: CDPElementHandle<HTMLInputElement>,\n    ...filePaths: string[]\n  ): Promise<void> {\n    const isMultiple = await this.evaluate(element => {\n      return element.multiple;\n    });\n    assert(\n      filePaths.length <= 1 || isMultiple,\n      'Multiple file uploads only work with <input type=file multiple>'\n    );\n\n    // Locate all files and confirm that they exist.\n    let path: typeof import('path');\n    try {\n      path = await import('path');\n    } catch (error) {\n      if (error instanceof TypeError) {\n        throw new Error(\n          `JSHandle#uploadFile can only be used in Node-like environments.`\n        );\n      }\n      throw error;\n    }\n    const files = filePaths.map(filePath => {\n      if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {\n        return filePath;\n      } else {\n        return path.resolve(filePath);\n      }\n    });\n    const {node} = await this.client.send('DOM.describeNode', {\n      objectId: this.id,\n    });\n    const {backendNodeId} = node;\n\n    /*  The zero-length array is a special case, it seems that\n         DOM.setFileInputFiles does not actually update the files in that case,\n         so the solution is to eval the element value to a new FileList directly.\n     */\n    if (files.length === 0) {\n      await this.evaluate(element => {\n        element.files = new DataTransfer().files;\n\n        // Dispatch events for this case because it should behave akin to a user action.\n        element.dispatchEvent(new Event('input', {bubbles: true}));\n        element.dispatchEvent(new Event('change', {bubbles: true}));\n      });\n    } else {\n      await this.client.send('DOM.setFileInputFiles', {\n        objectId: this.id,\n        files,\n        backendNodeId,\n      });\n    }\n  }\n\n  override async tap(this: CDPElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.#page.touchscreen.touchStart(x, y);\n    await this.#page.touchscreen.touchEnd();\n  }\n\n  override async touchStart(this: CDPElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.#page.touchscreen.touchStart(x, y);\n  }\n\n  override async touchMove(this: CDPElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.#page.touchscreen.touchMove(x, y);\n  }\n\n  override async touchEnd(this: CDPElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    await this.#page.touchscreen.touchEnd();\n  }\n\n  override async type(\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    await this.focus();\n    await this.#page.keyboard.type(text, options);\n  }\n\n  override async press(\n    key: KeyInput,\n    options?: Readonly<KeyPressOptions>\n  ): Promise<void> {\n    await this.focus();\n    await this.#page.keyboard.press(key, options);\n  }\n\n  override async boundingBox(): Promise<BoundingBox | null> {\n    const result = await this.#getBoxModel();\n\n    if (!result) {\n      return null;\n    }\n\n    const {offsetX, offsetY} = await this.#getOOPIFOffsets(this.#frame);\n    const quad = result.model.border;\n    const x = Math.min(quad[0]!, quad[2]!, quad[4]!, quad[6]!);\n    const y = Math.min(quad[1]!, quad[3]!, quad[5]!, quad[7]!);\n    const width = Math.max(quad[0]!, quad[2]!, quad[4]!, quad[6]!) - x;\n    const height = Math.max(quad[1]!, quad[3]!, quad[5]!, quad[7]!) - y;\n\n    return {x: x + offsetX, y: y + offsetY, width, height};\n  }\n\n  override async boxModel(): Promise<BoxModel | null> {\n    const result = await this.#getBoxModel();\n\n    if (!result) {\n      return null;\n    }\n\n    const {offsetX, offsetY} = await this.#getOOPIFOffsets(this.#frame);\n\n    const {content, padding, border, margin, width, height} = result.model;\n    return {\n      content: applyOffsetsToQuad(\n        this.#fromProtocolQuad(content),\n        offsetX,\n        offsetY\n      ),\n      padding: applyOffsetsToQuad(\n        this.#fromProtocolQuad(padding),\n        offsetX,\n        offsetY\n      ),\n      border: applyOffsetsToQuad(\n        this.#fromProtocolQuad(border),\n        offsetX,\n        offsetY\n      ),\n      margin: applyOffsetsToQuad(\n        this.#fromProtocolQuad(margin),\n        offsetX,\n        offsetY\n      ),\n      width,\n      height,\n    };\n  }\n\n  override async screenshot(\n    this: CDPElementHandle<Element>,\n    options: ScreenshotOptions = {}\n  ): Promise<string | Buffer> {\n    let needsViewportReset = false;\n\n    let boundingBox = await this.boundingBox();\n    assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n\n    const viewport = this.#page.viewport();\n\n    if (\n      viewport &&\n      (boundingBox.width > viewport.width ||\n        boundingBox.height > viewport.height)\n    ) {\n      const newViewport = {\n        width: Math.max(viewport.width, Math.ceil(boundingBox.width)),\n        height: Math.max(viewport.height, Math.ceil(boundingBox.height)),\n      };\n      await this.#page.setViewport(Object.assign({}, viewport, newViewport));\n\n      needsViewportReset = true;\n    }\n\n    await this.scrollIntoViewIfNeeded();\n\n    boundingBox = await this.boundingBox();\n    assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n    assert(boundingBox.width !== 0, 'Node has 0 width.');\n    assert(boundingBox.height !== 0, 'Node has 0 height.');\n\n    const layoutMetrics = await this.client.send('Page.getLayoutMetrics');\n    // Fallback to `layoutViewport` in case of using Firefox.\n    const {pageX, pageY} =\n      layoutMetrics.cssVisualViewport || layoutMetrics.layoutViewport;\n\n    const clip = Object.assign({}, boundingBox);\n    clip.x += pageX;\n    clip.y += pageY;\n\n    const imageData = await this.#page.screenshot(\n      Object.assign(\n        {},\n        {\n          clip,\n        },\n        options\n      )\n    );\n\n    if (needsViewportReset && viewport) {\n      await this.#page.setViewport(viewport);\n    }\n\n    return imageData;\n  }\n\n  override async autofill(data: AutofillData): Promise<void> {\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: this.handle.id,\n    });\n    const fieldId = nodeInfo.node.backendNodeId;\n    const frameId = this.#frame._id;\n    await this.client.send('Autofill.trigger', {\n      fieldId,\n      frameId,\n      card: data.creditCard,\n    });\n  }\n}\n\nfunction computeQuadArea(quad: Point[]): number {\n  /* Compute sum of all directed areas of adjacent triangles\n     https://en.wikipedia.org/wiki/Polygon#Simple_polygons\n   */\n  let area = 0;\n  for (let i = 0; i < quad.length; ++i) {\n    const p1 = quad[i]!;\n    const p2 = quad[(i + 1) % quad.length]!;\n    area += (p1.x * p2.y - p2.x * p1.y) / 2;\n  }\n  return Math.abs(area);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}