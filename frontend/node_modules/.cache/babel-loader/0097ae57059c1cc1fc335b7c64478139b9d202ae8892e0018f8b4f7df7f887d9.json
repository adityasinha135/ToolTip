{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Browser as BrowserBase, WEB_PERMISSION_TO_PROTOCOL_PERMISSION } from '../api/Browser.js';\nimport { BrowserContext } from '../api/BrowserContext.js';\nimport { assert } from '../util/assert.js';\nimport { ChromeTargetManager } from './ChromeTargetManager.js';\nimport { ConnectionEmittedEvents } from './Connection.js';\nimport { FirefoxTargetManager } from './FirefoxTargetManager.js';\nimport { InitializationStatus, OtherTarget, PageTarget, WorkerTarget } from './Target.js';\nimport { TaskQueue } from './TaskQueue.js';\n/**\n * @internal\n */\nexport class CDPBrowser extends BrowserBase {\n  /**\n   * @internal\n   */\n  static async _create(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback) {\n    const browser = new CDPBrowser(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback);\n    await browser._attach();\n    return browser;\n  }\n  #ignoreHTTPSErrors;\n  #defaultViewport;\n  #process;\n  #connection;\n  #closeCallback;\n  #targetFilterCallback;\n  #isPageTargetCallback;\n  #defaultContext;\n  #contexts = new Map();\n  #screenshotTaskQueue;\n  #targetManager;\n  /**\n   * @internal\n   */\n  get _targets() {\n    return this.#targetManager.getAvailableTargets();\n  }\n  /**\n   * @internal\n   */\n  constructor(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback) {\n    super();\n    product = product || 'chrome';\n    this.#ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this.#defaultViewport = defaultViewport;\n    this.#process = process;\n    this.#screenshotTaskQueue = new TaskQueue();\n    this.#connection = connection;\n    this.#closeCallback = closeCallback || function () {};\n    this.#targetFilterCallback = targetFilterCallback || (() => {\n      return true;\n    });\n    this.#setIsPageTargetCallback(isPageTargetCallback);\n    if (product === 'firefox') {\n      this.#targetManager = new FirefoxTargetManager(connection, this.#createTarget, this.#targetFilterCallback);\n    } else {\n      this.#targetManager = new ChromeTargetManager(connection, this.#createTarget, this.#targetFilterCallback);\n    }\n    this.#defaultContext = new CDPBrowserContext(this.#connection, this);\n    for (const contextId of contextIds) {\n      this.#contexts.set(contextId, new CDPBrowserContext(this.#connection, this, contextId));\n    }\n  }\n  #emitDisconnected = () => {\n    this.emit(\"disconnected\" /* BrowserEmittedEvents.Disconnected */);\n  };\n  /**\n   * @internal\n   */\n  async _attach() {\n    this.#connection.on(ConnectionEmittedEvents.Disconnected, this.#emitDisconnected);\n    this.#targetManager.on(\"targetAvailable\" /* TargetManagerEmittedEvents.TargetAvailable */, this.#onAttachedToTarget);\n    this.#targetManager.on(\"targetGone\" /* TargetManagerEmittedEvents.TargetGone */, this.#onDetachedFromTarget);\n    this.#targetManager.on(\"targetChanged\" /* TargetManagerEmittedEvents.TargetChanged */, this.#onTargetChanged);\n    this.#targetManager.on(\"targetDiscovered\" /* TargetManagerEmittedEvents.TargetDiscovered */, this.#onTargetDiscovered);\n    await this.#targetManager.initialize();\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    this.#connection.off(ConnectionEmittedEvents.Disconnected, this.#emitDisconnected);\n    this.#targetManager.off(\"targetAvailable\" /* TargetManagerEmittedEvents.TargetAvailable */, this.#onAttachedToTarget);\n    this.#targetManager.off(\"targetGone\" /* TargetManagerEmittedEvents.TargetGone */, this.#onDetachedFromTarget);\n    this.#targetManager.off(\"targetChanged\" /* TargetManagerEmittedEvents.TargetChanged */, this.#onTargetChanged);\n    this.#targetManager.off(\"targetDiscovered\" /* TargetManagerEmittedEvents.TargetDiscovered */, this.#onTargetDiscovered);\n  }\n  /**\n   * The spawned browser process. Returns `null` if the browser instance was created with\n   * {@link Puppeteer.connect}.\n   */\n  process() {\n    return this.#process ?? null;\n  }\n  /**\n   * @internal\n   */\n  _targetManager() {\n    return this.#targetManager;\n  }\n  #setIsPageTargetCallback(isPageTargetCallback) {\n    this.#isPageTargetCallback = isPageTargetCallback || (target => {\n      return target.type() === 'page' || target.type() === 'background_page' || target.type() === 'webview';\n    });\n  }\n  /**\n   * @internal\n   */\n  _getIsPageTargetCallback() {\n    return this.#isPageTargetCallback;\n  }\n  /**\n   * Creates a new incognito browser context. This won't share cookies/cache with other\n   * browser contexts.\n   *\n   * @example\n   *\n   * ```ts\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   // Create a new incognito browser context.\n   *   const context = await browser.createIncognitoBrowserContext();\n   *   // Create a new page in a pristine context.\n   *   const page = await context.newPage();\n   *   // Do stuff\n   *   await page.goto('https://example.com');\n   * })();\n   * ```\n   */\n  async createIncognitoBrowserContext(options = {}) {\n    const {\n      proxyServer,\n      proxyBypassList\n    } = options;\n    const {\n      browserContextId\n    } = await this.#connection.send('Target.createBrowserContext', {\n      proxyServer,\n      proxyBypassList: proxyBypassList && proxyBypassList.join(',')\n    });\n    const context = new CDPBrowserContext(this.#connection, this, browserContextId);\n    this.#contexts.set(browserContextId, context);\n    return context;\n  }\n  /**\n   * Returns an array of all open browser contexts. In a newly created browser, this will\n   * return a single instance of {@link BrowserContext}.\n   */\n  browserContexts() {\n    return [this.#defaultContext, ...Array.from(this.#contexts.values())];\n  }\n  /**\n   * Returns the default browser context. The default browser context cannot be closed.\n   */\n  defaultBrowserContext() {\n    return this.#defaultContext;\n  }\n  /**\n   * @internal\n   */\n  async _disposeContext(contextId) {\n    if (!contextId) {\n      return;\n    }\n    await this.#connection.send('Target.disposeBrowserContext', {\n      browserContextId: contextId\n    });\n    this.#contexts.delete(contextId);\n  }\n  #createTarget = (targetInfo, session) => {\n    const {\n      browserContextId\n    } = targetInfo;\n    const context = browserContextId && this.#contexts.has(browserContextId) ? this.#contexts.get(browserContextId) : this.#defaultContext;\n    if (!context) {\n      throw new Error('Missing browser context');\n    }\n    const createSession = isAutoAttachEmulated => {\n      return this.#connection._createSession(targetInfo, isAutoAttachEmulated);\n    };\n    const targetForFilter = new OtherTarget(targetInfo, session, context, this.#targetManager, createSession);\n    if (this.#isPageTargetCallback(targetForFilter)) {\n      return new PageTarget(targetInfo, session, context, this.#targetManager, createSession, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null, this.#screenshotTaskQueue);\n    }\n    if (targetInfo.type === 'service_worker' || targetInfo.type === 'shared_worker') {\n      return new WorkerTarget(targetInfo, session, context, this.#targetManager, createSession);\n    }\n    return new OtherTarget(targetInfo, session, context, this.#targetManager, createSession);\n  };\n  #onAttachedToTarget = async target => {\n    if ((await target._initializedDeferred.valueOrThrow()) === InitializationStatus.SUCCESS) {\n      this.emit(\"targetcreated\" /* BrowserEmittedEvents.TargetCreated */, target);\n      target.browserContext().emit(\"targetcreated\" /* BrowserContextEmittedEvents.TargetCreated */, target);\n    }\n  };\n  #onDetachedFromTarget = async target => {\n    target._initializedDeferred.resolve(InitializationStatus.ABORTED);\n    target._isClosedDeferred.resolve();\n    if ((await target._initializedDeferred.valueOrThrow()) === InitializationStatus.SUCCESS) {\n      this.emit(\"targetdestroyed\" /* BrowserEmittedEvents.TargetDestroyed */, target);\n      target.browserContext().emit(\"targetdestroyed\" /* BrowserContextEmittedEvents.TargetDestroyed */, target);\n    }\n  };\n  #onTargetChanged = ({\n    target\n  }) => {\n    this.emit(\"targetchanged\" /* BrowserEmittedEvents.TargetChanged */, target);\n    target.browserContext().emit(\"targetchanged\" /* BrowserContextEmittedEvents.TargetChanged */, target);\n  };\n  #onTargetDiscovered = targetInfo => {\n    this.emit('targetdiscovered', targetInfo);\n  };\n  /**\n   * The browser websocket endpoint which can be used as an argument to\n   * {@link Puppeteer.connect}.\n   *\n   * @returns The Browser websocket url.\n   *\n   * @remarks\n   *\n   * The format is `ws://${host}:${port}/devtools/browser/<id>`.\n   *\n   * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.\n   * Learn more about the\n   * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and\n   * the {@link\n   * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target\n   * | browser endpoint}.\n   */\n  wsEndpoint() {\n    return this.#connection.url();\n  }\n  /**\n   * Promise which resolves to a new {@link Page} object. The Page is created in\n   * a default browser context.\n   */\n  async newPage() {\n    return this.#defaultContext.newPage();\n  }\n  /**\n   * @internal\n   */\n  async _createPageInContext(contextId) {\n    const {\n      targetId\n    } = await this.#connection.send('Target.createTarget', {\n      url: 'about:blank',\n      browserContextId: contextId || undefined\n    });\n    const target = this.#targetManager.getAvailableTargets().get(targetId);\n    if (!target) {\n      throw new Error(`Missing target for page (id = ${targetId})`);\n    }\n    const initialized = (await target._initializedDeferred.valueOrThrow()) === InitializationStatus.SUCCESS;\n    if (!initialized) {\n      throw new Error(`Failed to create target for page (id = ${targetId})`);\n    }\n    const page = await target.page();\n    if (!page) {\n      throw new Error(`Failed to create a page for context (id = ${contextId})`);\n    }\n    return page;\n  }\n  /**\n   * All active targets inside the Browser. In case of multiple browser contexts, returns\n   * an array with all the targets in all browser contexts.\n   */\n  targets() {\n    return Array.from(this.#targetManager.getAvailableTargets().values()).filter(target => {\n      return target._initializedDeferred.value() === InitializationStatus.SUCCESS;\n    });\n  }\n  /**\n   * The target associated with the browser.\n   */\n  target() {\n    const browserTarget = this.targets().find(target => {\n      return target.type() === 'browser';\n    });\n    if (!browserTarget) {\n      throw new Error('Browser target is not found');\n    }\n    return browserTarget;\n  }\n  async version() {\n    const version = await this.#getVersion();\n    return version.product;\n  }\n  /**\n   * The browser's original user agent. Pages can override the browser user agent with\n   * {@link Page.setUserAgent}.\n   */\n  async userAgent() {\n    const version = await this.#getVersion();\n    return version.userAgent;\n  }\n  async close() {\n    await this.#closeCallback.call(null);\n    this.disconnect();\n  }\n  disconnect() {\n    this.#targetManager.dispose();\n    this.#connection.dispose();\n    this._detach();\n  }\n  /**\n   * Indicates that the browser is connected.\n   */\n  isConnected() {\n    return !this.#connection._closed;\n  }\n  #getVersion() {\n    return this.#connection.send('Browser.getVersion');\n  }\n}\n/**\n * @internal\n */\nexport class CDPBrowserContext extends BrowserContext {\n  #connection;\n  #browser;\n  #id;\n  /**\n   * @internal\n   */\n  constructor(connection, browser, contextId) {\n    super();\n    this.#connection = connection;\n    this.#browser = browser;\n    this.#id = contextId;\n  }\n  get id() {\n    return this.#id;\n  }\n  /**\n   * An array of all active targets inside the browser context.\n   */\n  targets() {\n    return this.#browser.targets().filter(target => {\n      return target.browserContext() === this;\n    });\n  }\n  /**\n   * This searches for a target in this specific browser context.\n   *\n   * @example\n   * An example of finding a target for a page opened via `window.open`:\n   *\n   * ```ts\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browserContext.waitForTarget(\n   *   target => target.url() === 'https://www.example.com/'\n   * );\n   * ```\n   *\n   * @param predicate - A function to be run for every target\n   * @param options - An object of options. Accepts a timeout,\n   * which is the maximum wait time in milliseconds.\n   * Pass `0` to disable the timeout. Defaults to 30 seconds.\n   * @returns Promise which resolves to the first target found\n   * that matches the `predicate` function.\n   */\n  waitForTarget(predicate, options = {}) {\n    return this.#browser.waitForTarget(target => {\n      return target.browserContext() === this && predicate(target);\n    }, options);\n  }\n  /**\n   * An array of all pages inside the browser context.\n   *\n   * @returns Promise which resolves to an array of all open pages.\n   * Non visible pages, such as `\"background_page\"`, will not be listed here.\n   * You can find them using {@link CDPTarget.page | the target page}.\n   */\n  async pages() {\n    const pages = await Promise.all(this.targets().filter(target => {\n      return target.type() === 'page' || target.type() === 'other' && this.#browser._getIsPageTargetCallback()?.(target);\n    }).map(target => {\n      return target.page();\n    }));\n    return pages.filter(page => {\n      return !!page;\n    });\n  }\n  /**\n   * Returns whether BrowserContext is incognito.\n   * The default browser context is the only non-incognito browser context.\n   *\n   * @remarks\n   * The default browser context cannot be closed.\n   */\n  isIncognito() {\n    return !!this.#id;\n  }\n  /**\n   * @example\n   *\n   * ```ts\n   * const context = browser.defaultBrowserContext();\n   * await context.overridePermissions('https://html5demos.com', [\n   *   'geolocation',\n   * ]);\n   * ```\n   *\n   * @param origin - The origin to grant permissions to, e.g. \"https://example.com\".\n   * @param permissions - An array of permissions to grant.\n   * All permissions that are not listed here will be automatically denied.\n   */\n  async overridePermissions(origin, permissions) {\n    const protocolPermissions = permissions.map(permission => {\n      const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);\n      if (!protocolPermission) {\n        throw new Error('Unknown permission: ' + permission);\n      }\n      return protocolPermission;\n    });\n    await this.#connection.send('Browser.grantPermissions', {\n      origin,\n      browserContextId: this.#id || undefined,\n      permissions: protocolPermissions\n    });\n  }\n  /**\n   * Clears all permission overrides for the browser context.\n   *\n   * @example\n   *\n   * ```ts\n   * const context = browser.defaultBrowserContext();\n   * context.overridePermissions('https://example.com', ['clipboard-read']);\n   * // do stuff ..\n   * context.clearPermissionOverrides();\n   * ```\n   */\n  async clearPermissionOverrides() {\n    await this.#connection.send('Browser.resetPermissions', {\n      browserContextId: this.#id || undefined\n    });\n  }\n  /**\n   * Creates a new page in the browser context.\n   */\n  newPage() {\n    return this.#browser._createPageInContext(this.#id);\n  }\n  /**\n   * The browser this browser context belongs to.\n   */\n  browser() {\n    return this.#browser;\n  }\n  /**\n   * Closes the browser context. All the targets that belong to the browser context\n   * will be closed.\n   *\n   * @remarks\n   * Only incognito browser contexts can be closed.\n   */\n  async close() {\n    assert(this.#id, 'Non-incognito profiles cannot be closed!');\n    await this.#browser._disposeContext(this.#id);\n  }\n}","map":{"version":3,"names":["Browser","BrowserBase","WEB_PERMISSION_TO_PROTOCOL_PERMISSION","BrowserContext","assert","ChromeTargetManager","ConnectionEmittedEvents","FirefoxTargetManager","InitializationStatus","OtherTarget","PageTarget","WorkerTarget","TaskQueue","CDPBrowser","_create","product","connection","contextIds","ignoreHTTPSErrors","defaultViewport","process","closeCallback","targetFilterCallback","isPageTargetCallback","browser","_attach","defaultContext","contexts","Map","screenshotTaskQueue","targetManager","_targets","getAvailableTargets","constructor","setIsPageTargetCallback","createTarget","CDPBrowserContext","contextId","set","emitDisconnected","#emitDisconnected","emit","on","Disconnected","onAttachedToTarget","onDetachedFromTarget","onTargetChanged","onTargetDiscovered","initialize","_detach","off","_targetManager","#setIsPageTargetCallback","target","type","_getIsPageTargetCallback","createIncognitoBrowserContext","options","proxyServer","proxyBypassList","browserContextId","send","join","context","browserContexts","Array","from","values","defaultBrowserContext","_disposeContext","delete","#createTarget","targetInfo","session","has","get","Error","createSession","isAutoAttachEmulated","_createSession","targetForFilter","_initializedDeferred","valueOrThrow","SUCCESS","browserContext","resolve","ABORTED","_isClosedDeferred","#onTargetChanged","wsEndpoint","url","newPage","_createPageInContext","targetId","undefined","initialized","page","targets","filter","value","browserTarget","find","version","getVersion","userAgent","close","call","disconnect","dispose","isConnected","_closed","#getVersion","id","waitForTarget","predicate","pages","Promise","all","map","isIncognito","overridePermissions","origin","permissions","protocolPermissions","permission","protocolPermission","clearPermissionOverrides"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/Browser.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ChildProcess} from 'child_process';\n\nimport {Protocol} from 'devtools-protocol';\n\nimport {\n  Browser as BrowserBase,\n  BrowserCloseCallback,\n  TargetFilterCallback,\n  IsPageTargetCallback,\n  BrowserEmittedEvents,\n  BrowserContextEmittedEvents,\n  BrowserContextOptions,\n  WEB_PERMISSION_TO_PROTOCOL_PERMISSION,\n  Permission,\n} from '../api/Browser.js';\nimport {BrowserContext} from '../api/BrowserContext.js';\nimport {Page} from '../api/Page.js';\nimport {Target} from '../api/Target.js';\nimport {assert} from '../util/assert.js';\n\nimport {ChromeTargetManager} from './ChromeTargetManager.js';\nimport {CDPSession, Connection, ConnectionEmittedEvents} from './Connection.js';\nimport {FirefoxTargetManager} from './FirefoxTargetManager.js';\nimport {Viewport} from './PuppeteerViewport.js';\nimport {\n  InitializationStatus,\n  OtherTarget,\n  PageTarget,\n  CDPTarget,\n  WorkerTarget,\n} from './Target.js';\nimport {TargetManager, TargetManagerEmittedEvents} from './TargetManager.js';\nimport {TaskQueue} from './TaskQueue.js';\n\n/**\n * @internal\n */\nexport class CDPBrowser extends BrowserBase {\n  /**\n   * @internal\n   */\n  static async _create(\n    product: 'firefox' | 'chrome' | undefined,\n    connection: Connection,\n    contextIds: string[],\n    ignoreHTTPSErrors: boolean,\n    defaultViewport?: Viewport | null,\n    process?: ChildProcess,\n    closeCallback?: BrowserCloseCallback,\n    targetFilterCallback?: TargetFilterCallback,\n    isPageTargetCallback?: IsPageTargetCallback\n  ): Promise<CDPBrowser> {\n    const browser = new CDPBrowser(\n      product,\n      connection,\n      contextIds,\n      ignoreHTTPSErrors,\n      defaultViewport,\n      process,\n      closeCallback,\n      targetFilterCallback,\n      isPageTargetCallback\n    );\n    await browser._attach();\n    return browser;\n  }\n  #ignoreHTTPSErrors: boolean;\n  #defaultViewport?: Viewport | null;\n  #process?: ChildProcess;\n  #connection: Connection;\n  #closeCallback: BrowserCloseCallback;\n  #targetFilterCallback: TargetFilterCallback;\n  #isPageTargetCallback!: IsPageTargetCallback;\n  #defaultContext: CDPBrowserContext;\n  #contexts = new Map<string, CDPBrowserContext>();\n  #screenshotTaskQueue: TaskQueue;\n  #targetManager: TargetManager;\n\n  /**\n   * @internal\n   */\n  override get _targets(): Map<string, CDPTarget> {\n    return this.#targetManager.getAvailableTargets();\n  }\n\n  /**\n   * @internal\n   */\n  constructor(\n    product: 'chrome' | 'firefox' | undefined,\n    connection: Connection,\n    contextIds: string[],\n    ignoreHTTPSErrors: boolean,\n    defaultViewport?: Viewport | null,\n    process?: ChildProcess,\n    closeCallback?: BrowserCloseCallback,\n    targetFilterCallback?: TargetFilterCallback,\n    isPageTargetCallback?: IsPageTargetCallback\n  ) {\n    super();\n    product = product || 'chrome';\n    this.#ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this.#defaultViewport = defaultViewport;\n    this.#process = process;\n    this.#screenshotTaskQueue = new TaskQueue();\n    this.#connection = connection;\n    this.#closeCallback = closeCallback || function (): void {};\n    this.#targetFilterCallback =\n      targetFilterCallback ||\n      ((): boolean => {\n        return true;\n      });\n    this.#setIsPageTargetCallback(isPageTargetCallback);\n    if (product === 'firefox') {\n      this.#targetManager = new FirefoxTargetManager(\n        connection,\n        this.#createTarget,\n        this.#targetFilterCallback\n      );\n    } else {\n      this.#targetManager = new ChromeTargetManager(\n        connection,\n        this.#createTarget,\n        this.#targetFilterCallback\n      );\n    }\n    this.#defaultContext = new CDPBrowserContext(this.#connection, this);\n    for (const contextId of contextIds) {\n      this.#contexts.set(\n        contextId,\n        new CDPBrowserContext(this.#connection, this, contextId)\n      );\n    }\n  }\n\n  #emitDisconnected = () => {\n    this.emit(BrowserEmittedEvents.Disconnected);\n  };\n\n  /**\n   * @internal\n   */\n  override async _attach(): Promise<void> {\n    this.#connection.on(\n      ConnectionEmittedEvents.Disconnected,\n      this.#emitDisconnected\n    );\n    this.#targetManager.on(\n      TargetManagerEmittedEvents.TargetAvailable,\n      this.#onAttachedToTarget\n    );\n    this.#targetManager.on(\n      TargetManagerEmittedEvents.TargetGone,\n      this.#onDetachedFromTarget\n    );\n    this.#targetManager.on(\n      TargetManagerEmittedEvents.TargetChanged,\n      this.#onTargetChanged\n    );\n    this.#targetManager.on(\n      TargetManagerEmittedEvents.TargetDiscovered,\n      this.#onTargetDiscovered\n    );\n    await this.#targetManager.initialize();\n  }\n\n  /**\n   * @internal\n   */\n  override _detach(): void {\n    this.#connection.off(\n      ConnectionEmittedEvents.Disconnected,\n      this.#emitDisconnected\n    );\n    this.#targetManager.off(\n      TargetManagerEmittedEvents.TargetAvailable,\n      this.#onAttachedToTarget\n    );\n    this.#targetManager.off(\n      TargetManagerEmittedEvents.TargetGone,\n      this.#onDetachedFromTarget\n    );\n    this.#targetManager.off(\n      TargetManagerEmittedEvents.TargetChanged,\n      this.#onTargetChanged\n    );\n    this.#targetManager.off(\n      TargetManagerEmittedEvents.TargetDiscovered,\n      this.#onTargetDiscovered\n    );\n  }\n\n  /**\n   * The spawned browser process. Returns `null` if the browser instance was created with\n   * {@link Puppeteer.connect}.\n   */\n  override process(): ChildProcess | null {\n    return this.#process ?? null;\n  }\n\n  /**\n   * @internal\n   */\n  _targetManager(): TargetManager {\n    return this.#targetManager;\n  }\n\n  #setIsPageTargetCallback(isPageTargetCallback?: IsPageTargetCallback): void {\n    this.#isPageTargetCallback =\n      isPageTargetCallback ||\n      ((target: Target): boolean => {\n        return (\n          target.type() === 'page' ||\n          target.type() === 'background_page' ||\n          target.type() === 'webview'\n        );\n      });\n  }\n\n  /**\n   * @internal\n   */\n  override _getIsPageTargetCallback(): IsPageTargetCallback | undefined {\n    return this.#isPageTargetCallback;\n  }\n\n  /**\n   * Creates a new incognito browser context. This won't share cookies/cache with other\n   * browser contexts.\n   *\n   * @example\n   *\n   * ```ts\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   // Create a new incognito browser context.\n   *   const context = await browser.createIncognitoBrowserContext();\n   *   // Create a new page in a pristine context.\n   *   const page = await context.newPage();\n   *   // Do stuff\n   *   await page.goto('https://example.com');\n   * })();\n   * ```\n   */\n  override async createIncognitoBrowserContext(\n    options: BrowserContextOptions = {}\n  ): Promise<CDPBrowserContext> {\n    const {proxyServer, proxyBypassList} = options;\n\n    const {browserContextId} = await this.#connection.send(\n      'Target.createBrowserContext',\n      {\n        proxyServer,\n        proxyBypassList: proxyBypassList && proxyBypassList.join(','),\n      }\n    );\n    const context = new CDPBrowserContext(\n      this.#connection,\n      this,\n      browserContextId\n    );\n    this.#contexts.set(browserContextId, context);\n    return context;\n  }\n\n  /**\n   * Returns an array of all open browser contexts. In a newly created browser, this will\n   * return a single instance of {@link BrowserContext}.\n   */\n  override browserContexts(): CDPBrowserContext[] {\n    return [this.#defaultContext, ...Array.from(this.#contexts.values())];\n  }\n\n  /**\n   * Returns the default browser context. The default browser context cannot be closed.\n   */\n  override defaultBrowserContext(): CDPBrowserContext {\n    return this.#defaultContext;\n  }\n\n  /**\n   * @internal\n   */\n  override async _disposeContext(contextId?: string): Promise<void> {\n    if (!contextId) {\n      return;\n    }\n    await this.#connection.send('Target.disposeBrowserContext', {\n      browserContextId: contextId,\n    });\n    this.#contexts.delete(contextId);\n  }\n\n  #createTarget = (\n    targetInfo: Protocol.Target.TargetInfo,\n    session?: CDPSession\n  ) => {\n    const {browserContextId} = targetInfo;\n    const context =\n      browserContextId && this.#contexts.has(browserContextId)\n        ? this.#contexts.get(browserContextId)\n        : this.#defaultContext;\n\n    if (!context) {\n      throw new Error('Missing browser context');\n    }\n\n    const createSession = (isAutoAttachEmulated: boolean) => {\n      return this.#connection._createSession(targetInfo, isAutoAttachEmulated);\n    };\n    const targetForFilter = new OtherTarget(\n      targetInfo,\n      session,\n      context,\n      this.#targetManager,\n      createSession\n    );\n    if (this.#isPageTargetCallback(targetForFilter)) {\n      return new PageTarget(\n        targetInfo,\n        session,\n        context,\n        this.#targetManager,\n        createSession,\n        this.#ignoreHTTPSErrors,\n        this.#defaultViewport ?? null,\n        this.#screenshotTaskQueue\n      );\n    }\n    if (\n      targetInfo.type === 'service_worker' ||\n      targetInfo.type === 'shared_worker'\n    ) {\n      return new WorkerTarget(\n        targetInfo,\n        session,\n        context,\n        this.#targetManager,\n        createSession\n      );\n    }\n    return new OtherTarget(\n      targetInfo,\n      session,\n      context,\n      this.#targetManager,\n      createSession\n    );\n  };\n\n  #onAttachedToTarget = async (target: CDPTarget) => {\n    if (\n      (await target._initializedDeferred.valueOrThrow()) ===\n      InitializationStatus.SUCCESS\n    ) {\n      this.emit(BrowserEmittedEvents.TargetCreated, target);\n      target\n        .browserContext()\n        .emit(BrowserContextEmittedEvents.TargetCreated, target);\n    }\n  };\n\n  #onDetachedFromTarget = async (target: CDPTarget): Promise<void> => {\n    target._initializedDeferred.resolve(InitializationStatus.ABORTED);\n    target._isClosedDeferred.resolve();\n    if (\n      (await target._initializedDeferred.valueOrThrow()) ===\n      InitializationStatus.SUCCESS\n    ) {\n      this.emit(BrowserEmittedEvents.TargetDestroyed, target);\n      target\n        .browserContext()\n        .emit(BrowserContextEmittedEvents.TargetDestroyed, target);\n    }\n  };\n\n  #onTargetChanged = ({target}: {target: CDPTarget}): void => {\n    this.emit(BrowserEmittedEvents.TargetChanged, target);\n    target\n      .browserContext()\n      .emit(BrowserContextEmittedEvents.TargetChanged, target);\n  };\n\n  #onTargetDiscovered = (targetInfo: Protocol.Target.TargetInfo): void => {\n    this.emit('targetdiscovered', targetInfo);\n  };\n\n  /**\n   * The browser websocket endpoint which can be used as an argument to\n   * {@link Puppeteer.connect}.\n   *\n   * @returns The Browser websocket url.\n   *\n   * @remarks\n   *\n   * The format is `ws://${host}:${port}/devtools/browser/<id>`.\n   *\n   * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.\n   * Learn more about the\n   * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and\n   * the {@link\n   * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target\n   * | browser endpoint}.\n   */\n  override wsEndpoint(): string {\n    return this.#connection.url();\n  }\n\n  /**\n   * Promise which resolves to a new {@link Page} object. The Page is created in\n   * a default browser context.\n   */\n  override async newPage(): Promise<Page> {\n    return this.#defaultContext.newPage();\n  }\n\n  /**\n   * @internal\n   */\n  override async _createPageInContext(contextId?: string): Promise<Page> {\n    const {targetId} = await this.#connection.send('Target.createTarget', {\n      url: 'about:blank',\n      browserContextId: contextId || undefined,\n    });\n    const target = this.#targetManager.getAvailableTargets().get(targetId);\n    if (!target) {\n      throw new Error(`Missing target for page (id = ${targetId})`);\n    }\n    const initialized =\n      (await target._initializedDeferred.valueOrThrow()) ===\n      InitializationStatus.SUCCESS;\n    if (!initialized) {\n      throw new Error(`Failed to create target for page (id = ${targetId})`);\n    }\n    const page = await target.page();\n    if (!page) {\n      throw new Error(\n        `Failed to create a page for context (id = ${contextId})`\n      );\n    }\n    return page;\n  }\n\n  /**\n   * All active targets inside the Browser. In case of multiple browser contexts, returns\n   * an array with all the targets in all browser contexts.\n   */\n  override targets(): CDPTarget[] {\n    return Array.from(\n      this.#targetManager.getAvailableTargets().values()\n    ).filter(target => {\n      return (\n        target._initializedDeferred.value() === InitializationStatus.SUCCESS\n      );\n    });\n  }\n\n  /**\n   * The target associated with the browser.\n   */\n  override target(): CDPTarget {\n    const browserTarget = this.targets().find(target => {\n      return target.type() === 'browser';\n    });\n    if (!browserTarget) {\n      throw new Error('Browser target is not found');\n    }\n    return browserTarget;\n  }\n\n  override async version(): Promise<string> {\n    const version = await this.#getVersion();\n    return version.product;\n  }\n\n  /**\n   * The browser's original user agent. Pages can override the browser user agent with\n   * {@link Page.setUserAgent}.\n   */\n  override async userAgent(): Promise<string> {\n    const version = await this.#getVersion();\n    return version.userAgent;\n  }\n\n  override async close(): Promise<void> {\n    await this.#closeCallback.call(null);\n    this.disconnect();\n  }\n\n  override disconnect(): void {\n    this.#targetManager.dispose();\n    this.#connection.dispose();\n    this._detach();\n  }\n\n  /**\n   * Indicates that the browser is connected.\n   */\n  override isConnected(): boolean {\n    return !this.#connection._closed;\n  }\n\n  #getVersion(): Promise<Protocol.Browser.GetVersionResponse> {\n    return this.#connection.send('Browser.getVersion');\n  }\n}\n\n/**\n * @internal\n */\nexport class CDPBrowserContext extends BrowserContext {\n  #connection: Connection;\n  #browser: CDPBrowser;\n  #id?: string;\n\n  /**\n   * @internal\n   */\n  constructor(connection: Connection, browser: CDPBrowser, contextId?: string) {\n    super();\n    this.#connection = connection;\n    this.#browser = browser;\n    this.#id = contextId;\n  }\n\n  override get id(): string | undefined {\n    return this.#id;\n  }\n\n  /**\n   * An array of all active targets inside the browser context.\n   */\n  override targets(): CDPTarget[] {\n    return this.#browser.targets().filter(target => {\n      return target.browserContext() === this;\n    });\n  }\n\n  /**\n   * This searches for a target in this specific browser context.\n   *\n   * @example\n   * An example of finding a target for a page opened via `window.open`:\n   *\n   * ```ts\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browserContext.waitForTarget(\n   *   target => target.url() === 'https://www.example.com/'\n   * );\n   * ```\n   *\n   * @param predicate - A function to be run for every target\n   * @param options - An object of options. Accepts a timeout,\n   * which is the maximum wait time in milliseconds.\n   * Pass `0` to disable the timeout. Defaults to 30 seconds.\n   * @returns Promise which resolves to the first target found\n   * that matches the `predicate` function.\n   */\n  override waitForTarget(\n    predicate: (x: Target) => boolean | Promise<boolean>,\n    options: {timeout?: number} = {}\n  ): Promise<Target> {\n    return this.#browser.waitForTarget(target => {\n      return target.browserContext() === this && predicate(target);\n    }, options);\n  }\n\n  /**\n   * An array of all pages inside the browser context.\n   *\n   * @returns Promise which resolves to an array of all open pages.\n   * Non visible pages, such as `\"background_page\"`, will not be listed here.\n   * You can find them using {@link CDPTarget.page | the target page}.\n   */\n  override async pages(): Promise<Page[]> {\n    const pages = await Promise.all(\n      this.targets()\n        .filter(target => {\n          return (\n            target.type() === 'page' ||\n            (target.type() === 'other' &&\n              this.#browser._getIsPageTargetCallback()?.(target))\n          );\n        })\n        .map(target => {\n          return target.page();\n        })\n    );\n    return pages.filter((page): page is Page => {\n      return !!page;\n    });\n  }\n\n  /**\n   * Returns whether BrowserContext is incognito.\n   * The default browser context is the only non-incognito browser context.\n   *\n   * @remarks\n   * The default browser context cannot be closed.\n   */\n  override isIncognito(): boolean {\n    return !!this.#id;\n  }\n\n  /**\n   * @example\n   *\n   * ```ts\n   * const context = browser.defaultBrowserContext();\n   * await context.overridePermissions('https://html5demos.com', [\n   *   'geolocation',\n   * ]);\n   * ```\n   *\n   * @param origin - The origin to grant permissions to, e.g. \"https://example.com\".\n   * @param permissions - An array of permissions to grant.\n   * All permissions that are not listed here will be automatically denied.\n   */\n  override async overridePermissions(\n    origin: string,\n    permissions: Permission[]\n  ): Promise<void> {\n    const protocolPermissions = permissions.map(permission => {\n      const protocolPermission =\n        WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);\n      if (!protocolPermission) {\n        throw new Error('Unknown permission: ' + permission);\n      }\n      return protocolPermission;\n    });\n    await this.#connection.send('Browser.grantPermissions', {\n      origin,\n      browserContextId: this.#id || undefined,\n      permissions: protocolPermissions,\n    });\n  }\n\n  /**\n   * Clears all permission overrides for the browser context.\n   *\n   * @example\n   *\n   * ```ts\n   * const context = browser.defaultBrowserContext();\n   * context.overridePermissions('https://example.com', ['clipboard-read']);\n   * // do stuff ..\n   * context.clearPermissionOverrides();\n   * ```\n   */\n  override async clearPermissionOverrides(): Promise<void> {\n    await this.#connection.send('Browser.resetPermissions', {\n      browserContextId: this.#id || undefined,\n    });\n  }\n\n  /**\n   * Creates a new page in the browser context.\n   */\n  override newPage(): Promise<Page> {\n    return this.#browser._createPageInContext(this.#id);\n  }\n\n  /**\n   * The browser this browser context belongs to.\n   */\n  override browser(): CDPBrowser {\n    return this.#browser;\n  }\n\n  /**\n   * Closes the browser context. All the targets that belong to the browser context\n   * will be closed.\n   *\n   * @remarks\n   * Only incognito browser contexts can be closed.\n   */\n  override async close(): Promise<void> {\n    assert(this.#id, 'Non-incognito profiles cannot be closed!');\n    await this.#browser._disposeContext(this.#id);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}