{"ast":null,"code":"import { Deferred } from '../util/Deferred.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { ExecutionContext } from './ExecutionContext.js';\nimport { CDPJSHandle } from './JSHandle.js';\nimport { debugError, withSourcePuppeteerURLIfNone } from './util.js';\n/**\n * This class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n *\n * ```ts\n * page.on('workercreated', worker =>\n *   console.log('Worker created: ' + worker.url())\n * );\n * page.on('workerdestroyed', worker =>\n *   console.log('Worker destroyed: ' + worker.url())\n * );\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nexport class WebWorker extends EventEmitter {\n  #executionContext = Deferred.create();\n  #client;\n  #url;\n  /**\n   * @internal\n   */\n  constructor(client, url, consoleAPICalled, exceptionThrown) {\n    super();\n    this.#client = client;\n    this.#url = url;\n    this.#client.once('Runtime.executionContextCreated', async event => {\n      const context = new ExecutionContext(client, event.context);\n      this.#executionContext.resolve(context);\n    });\n    this.#client.on('Runtime.consoleAPICalled', async event => {\n      try {\n        const context = await this.#executionContext.valueOrThrow();\n        return consoleAPICalled(event.type, event.args.map(object => {\n          return new CDPJSHandle(context, object);\n        }), event.stackTrace);\n      } catch (err) {\n        debugError(err);\n      }\n    });\n    this.#client.on('Runtime.exceptionThrown', exception => {\n      return exceptionThrown(exception.exceptionDetails);\n    });\n    // This might fail if the target is closed before we receive all execution contexts.\n    this.#client.send('Runtime.enable').catch(debugError);\n  }\n  /**\n   * @internal\n   */\n  async executionContext() {\n    return this.#executionContext.valueOrThrow();\n  }\n  /**\n   * The URL of this web worker.\n   */\n  url() {\n    return this.#url;\n  }\n  /**\n   * The CDP session client the WebWorker belongs to.\n   */\n  get client() {\n    return this.#client;\n  }\n  /**\n   * If the function passed to the `worker.evaluate` returns a Promise, then\n   * `worker.evaluate` would wait for the promise to resolve and return its\n   * value. If the function passed to the `worker.evaluate` returns a\n   * non-serializable value, then `worker.evaluate` resolves to `undefined`.\n   * DevTools Protocol also supports transferring some additional values that\n   * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and\n   * bigint literals.\n   * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.\n   *\n   * @param pageFunction - Function to be evaluated in the worker context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n  async evaluate(pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n    const context = await this.#executionContext.valueOrThrow();\n    return context.evaluate(pageFunction, ...args);\n  }\n  /**\n   * The only difference between `worker.evaluate` and `worker.evaluateHandle`\n   * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the\n   * function passed to the `worker.evaluateHandle` returns a `Promise`, then\n   * `worker.evaluateHandle` would wait for the promise to resolve and return\n   * its value. Shortcut for\n   * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`\n   *\n   * @param pageFunction - Function to be evaluated in the page context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n    const context = await this.#executionContext.valueOrThrow();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n}","map":{"version":3,"names":["Deferred","EventEmitter","ExecutionContext","CDPJSHandle","debugError","withSourcePuppeteerURLIfNone","WebWorker","executionContext","create","client","url","constructor","consoleAPICalled","exceptionThrown","once","event","context","resolve","on","valueOrThrow","type","args","map","object","stackTrace","err","exception","exceptionDetails","send","catch","evaluate","pageFunction","name","evaluateHandle"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/WebWorker.ts"],"sourcesContent":["/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Protocol} from 'devtools-protocol';\n\nimport {Deferred} from '../util/Deferred.js';\n\nimport {CDPSession} from './Connection.js';\nimport {ConsoleMessageType} from './ConsoleMessage.js';\nimport {EventEmitter} from './EventEmitter.js';\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {CDPJSHandle} from './JSHandle.js';\nimport {EvaluateFunc, HandleFor} from './types.js';\nimport {debugError, withSourcePuppeteerURLIfNone} from './util.js';\n\n/**\n * @internal\n */\nexport type ConsoleAPICalledCallback = (\n  eventType: ConsoleMessageType,\n  handles: CDPJSHandle[],\n  trace: Protocol.Runtime.StackTrace\n) => void;\n\n/**\n * @internal\n */\nexport type ExceptionThrownCallback = (\n  details: Protocol.Runtime.ExceptionDetails\n) => void;\n\n/**\n * This class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n *\n * ```ts\n * page.on('workercreated', worker =>\n *   console.log('Worker created: ' + worker.url())\n * );\n * page.on('workerdestroyed', worker =>\n *   console.log('Worker destroyed: ' + worker.url())\n * );\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nexport class WebWorker extends EventEmitter {\n  #executionContext = Deferred.create<ExecutionContext>();\n\n  #client: CDPSession;\n  #url: string;\n\n  /**\n   * @internal\n   */\n  constructor(\n    client: CDPSession,\n    url: string,\n    consoleAPICalled: ConsoleAPICalledCallback,\n    exceptionThrown: ExceptionThrownCallback\n  ) {\n    super();\n    this.#client = client;\n    this.#url = url;\n\n    this.#client.once('Runtime.executionContextCreated', async event => {\n      const context = new ExecutionContext(client, event.context);\n      this.#executionContext.resolve(context);\n    });\n    this.#client.on('Runtime.consoleAPICalled', async event => {\n      try {\n        const context = await this.#executionContext.valueOrThrow();\n        return consoleAPICalled(\n          event.type,\n          event.args.map((object: Protocol.Runtime.RemoteObject) => {\n            return new CDPJSHandle(context, object);\n          }),\n          event.stackTrace\n        );\n      } catch (err) {\n        debugError(err);\n      }\n    });\n    this.#client.on('Runtime.exceptionThrown', exception => {\n      return exceptionThrown(exception.exceptionDetails);\n    });\n\n    // This might fail if the target is closed before we receive all execution contexts.\n    this.#client.send('Runtime.enable').catch(debugError);\n  }\n\n  /**\n   * @internal\n   */\n  async executionContext(): Promise<ExecutionContext> {\n    return this.#executionContext.valueOrThrow();\n  }\n\n  /**\n   * The URL of this web worker.\n   */\n  url(): string {\n    return this.#url;\n  }\n\n  /**\n   * The CDP session client the WebWorker belongs to.\n   */\n  get client(): CDPSession {\n    return this.#client;\n  }\n\n  /**\n   * If the function passed to the `worker.evaluate` returns a Promise, then\n   * `worker.evaluate` would wait for the promise to resolve and return its\n   * value. If the function passed to the `worker.evaluate` returns a\n   * non-serializable value, then `worker.evaluate` resolves to `undefined`.\n   * DevTools Protocol also supports transferring some additional values that\n   * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and\n   * bigint literals.\n   * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.\n   *\n   * @param pageFunction - Function to be evaluated in the worker context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    const context = await this.#executionContext.valueOrThrow();\n    return context.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * The only difference between `worker.evaluate` and `worker.evaluateHandle`\n   * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the\n   * function passed to the `worker.evaluateHandle` returns a `Promise`, then\n   * `worker.evaluateHandle` would wait for the promise to resolve and return\n   * its value. Shortcut for\n   * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`\n   *\n   * @param pageFunction - Function to be evaluated in the page context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    const context = await this.#executionContext.valueOrThrow();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}