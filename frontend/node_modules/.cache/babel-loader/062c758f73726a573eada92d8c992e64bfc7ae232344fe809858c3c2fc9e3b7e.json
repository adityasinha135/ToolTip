{"ast":null,"code":"import { headersArray, HTTPRequest as BaseHTTPRequest, InterceptResolutionAction, STATUS_TEXTS } from '../api/HTTPRequest.js';\nimport { assert } from '../util/assert.js';\nimport { debugError, isString } from './util.js';\n/**\n * @internal\n */\nexport class HTTPRequest extends BaseHTTPRequest {\n  _requestId;\n  _interceptionId;\n  _failureText = null;\n  _response = null;\n  _fromMemoryCache = false;\n  _redirectChain;\n  #client;\n  #isNavigationRequest;\n  #allowInterception;\n  #interceptionHandled = false;\n  #url;\n  #resourceType;\n  #method;\n  #postData;\n  #headers = {};\n  #frame;\n  #continueRequestOverrides;\n  #responseForRequest = null;\n  #abortErrorReason = null;\n  #interceptResolutionState = {\n    action: InterceptResolutionAction.None\n  };\n  #interceptHandlers;\n  #initiator;\n  get client() {\n    return this.#client;\n  }\n  constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {\n    super();\n    this.#client = client;\n    this._requestId = data.requestId;\n    this.#isNavigationRequest = data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#allowInterception = allowInterception;\n    this.#url = data.request.url;\n    this.#resourceType = (data.type || 'other').toLowerCase();\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#continueRequestOverrides = {};\n    this.#interceptHandlers = [];\n    this.#initiator = data.initiator;\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n  url() {\n    return this.#url;\n  }\n  continueRequestOverrides() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#continueRequestOverrides;\n  }\n  responseForRequest() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#responseForRequest;\n  }\n  abortErrorReason() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#abortErrorReason;\n  }\n  interceptResolutionState() {\n    if (!this.#allowInterception) {\n      return {\n        action: InterceptResolutionAction.Disabled\n      };\n    }\n    if (this.#interceptionHandled) {\n      return {\n        action: InterceptResolutionAction.AlreadyHandled\n      };\n    }\n    return {\n      ...this.#interceptResolutionState\n    };\n  }\n  isInterceptResolutionHandled() {\n    return this.#interceptionHandled;\n  }\n  enqueueInterceptAction(pendingHandler) {\n    this.#interceptHandlers.push(pendingHandler);\n  }\n  async finalizeInterceptions() {\n    await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {\n      action\n    } = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return this.#abort(this.#abortErrorReason);\n      case 'respond':\n        if (this.#responseForRequest === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return this.#respond(this.#responseForRequest);\n      case 'continue':\n        return this.#continue(this.#continueRequestOverrides);\n    }\n  }\n  resourceType() {\n    return this.#resourceType;\n  }\n  method() {\n    return this.#method;\n  }\n  postData() {\n    return this.#postData;\n  }\n  headers() {\n    return this.#headers;\n  }\n  response() {\n    return this._response;\n  }\n  frame() {\n    return this.#frame;\n  }\n  isNavigationRequest() {\n    return this.#isNavigationRequest;\n  }\n  initiator() {\n    return this.#initiator;\n  }\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  failure() {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText\n    };\n  }\n  async continue(overrides = {}, priority) {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return this.#continue(overrides);\n    }\n    this.#continueRequestOverrides = overrides;\n    if (this.#interceptResolutionState.priority === undefined || priority > this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort' || this.#interceptResolutionState.action === 'respond') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n  async #continue(overrides = {}) {\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this.#interceptionHandled = true;\n    const postDataBinaryBase64 = postData ? Buffer.from(postData).toString('base64') : undefined;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');\n    }\n    await this.#client.send('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url,\n      method,\n      postData: postDataBinaryBase64,\n      headers: headers ? headersArray(headers) : undefined\n    }).catch(error => {\n      this.#interceptionHandled = false;\n      return handleError(error);\n    });\n  }\n  async respond(response, priority) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return this.#respond(response);\n    }\n    this.#responseForRequest = response;\n    if (this.#interceptResolutionState.priority === undefined || priority > this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Respond;\n    }\n  }\n  async #respond(response) {\n    this.#interceptionHandled = true;\n    const responseBody = response.body && isString(response.body) ? Buffer.from(response.body) : response.body || null;\n    const responseHeaders = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n        responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map(item => {\n          return String(item);\n        }) : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (responseBody && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n    }\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');\n    }\n    await this.#client.send('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: status,\n      responsePhrase: STATUS_TEXTS[status],\n      responseHeaders: headersArray(responseHeaders),\n      body: responseBody ? responseBody.toString('base64') : undefined\n    }).catch(error => {\n      this.#interceptionHandled = false;\n      return handleError(error);\n    });\n  }\n  async abort(errorCode = 'failed', priority) {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return this.#abort(errorReason);\n    }\n    this.#abortErrorReason = errorReason;\n    if (this.#interceptResolutionState.priority === undefined || priority >= this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority\n      };\n      return;\n    }\n  }\n  async #abort(errorReason) {\n    this.#interceptionHandled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');\n    }\n    await this.#client.send('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason: errorReason || 'Failed'\n    }).catch(handleError);\n  }\n}\nconst errorReasons = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed'\n};\nasync function handleError(error) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}","map":{"version":3,"names":["headersArray","HTTPRequest","BaseHTTPRequest","InterceptResolutionAction","STATUS_TEXTS","assert","debugError","isString","_requestId","_interceptionId","_failureText","_response","_fromMemoryCache","_redirectChain","client","isNavigationRequest","allowInterception","interceptionHandled","url","resourceType","method","postData","headers","frame","continueRequestOverrides","responseForRequest","abortErrorReason","interceptResolutionState","action","None","interceptHandlers","initiator","constructor","interceptionId","data","redirectChain","requestId","loaderId","type","request","toLowerCase","key","value","Object","entries","Disabled","AlreadyHandled","isInterceptResolutionHandled","enqueueInterceptAction","pendingHandler","push","finalizeInterceptions","reduce","promiseChain","interceptAction","then","Promise","resolve","abort","Error","respond","continue","response","slice","failure","errorText","overrides","priority","startsWith","undefined","Continue","#continue","postDataBinaryBase64","Buffer","from","toString","send","catch","error","handleError","Respond","#respond","responseBody","body","responseHeaders","header","keys","Array","isArray","map","item","String","contentType","byteLength","status","responseCode","responsePhrase","errorCode","errorReason","errorReasons","Abort","#abort","aborted","accessdenied","addressunreachable","blockedbyclient","blockedbyresponse","connectionaborted","connectionclosed","connectionfailed","connectionrefused","connectionreset","internetdisconnected","namenotresolved","timedout","failed","includes","originalMessage"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/HTTPRequest.ts"],"sourcesContent":["/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Protocol} from 'devtools-protocol';\n\nimport {Frame} from '../api/Frame.js';\nimport {\n  ContinueRequestOverrides,\n  ErrorCode,\n  headersArray,\n  HTTPRequest as BaseHTTPRequest,\n  InterceptResolutionAction,\n  InterceptResolutionState,\n  ResourceType,\n  ResponseForRequest,\n  STATUS_TEXTS,\n} from '../api/HTTPRequest.js';\nimport {HTTPResponse} from '../api/HTTPResponse.js';\nimport {assert} from '../util/assert.js';\n\nimport {CDPSession} from './Connection.js';\nimport {ProtocolError} from './Errors.js';\nimport {debugError, isString} from './util.js';\n\n/**\n * @internal\n */\nexport class HTTPRequest extends BaseHTTPRequest {\n  override _requestId: string;\n  override _interceptionId: string | undefined;\n  override _failureText: string | null = null;\n  override _response: HTTPResponse | null = null;\n  override _fromMemoryCache = false;\n  override _redirectChain: HTTPRequest[];\n\n  #client: CDPSession;\n  #isNavigationRequest: boolean;\n  #allowInterception: boolean;\n  #interceptionHandled = false;\n  #url: string;\n  #resourceType: ResourceType;\n\n  #method: string;\n  #postData?: string;\n  #headers: Record<string, string> = {};\n  #frame: Frame | null;\n  #continueRequestOverrides: ContinueRequestOverrides;\n  #responseForRequest: Partial<ResponseForRequest> | null = null;\n  #abortErrorReason: Protocol.Network.ErrorReason | null = null;\n  #interceptResolutionState: InterceptResolutionState = {\n    action: InterceptResolutionAction.None,\n  };\n  #interceptHandlers: Array<() => void | PromiseLike<any>>;\n  #initiator?: Protocol.Network.Initiator;\n\n  override get client(): CDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CDPSession,\n    frame: Frame | null,\n    interceptionId: string | undefined,\n    allowInterception: boolean,\n    data: {\n      /**\n       * Request identifier.\n       */\n      requestId: Protocol.Network.RequestId;\n      /**\n       * Loader identifier. Empty string if the request is fetched from worker.\n       */\n      loaderId?: Protocol.Network.LoaderId;\n      /**\n       * URL of the document this request is loaded for.\n       */\n      documentURL?: string;\n      /**\n       * Request data.\n       */\n      request: Protocol.Network.Request;\n      /**\n       * Request initiator.\n       */\n      initiator?: Protocol.Network.Initiator;\n      /**\n       * Type of this resource.\n       */\n      type?: Protocol.Network.ResourceType;\n    },\n    redirectChain: HTTPRequest[]\n  ) {\n    super();\n    this.#client = client;\n    this._requestId = data.requestId;\n    this.#isNavigationRequest =\n      data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#allowInterception = allowInterception;\n    this.#url = data.request.url;\n    this.#resourceType = (data.type || 'other').toLowerCase() as ResourceType;\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#continueRequestOverrides = {};\n    this.#interceptHandlers = [];\n    this.#initiator = data.initiator;\n\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n\n  override url(): string {\n    return this.#url;\n  }\n\n  override continueRequestOverrides(): ContinueRequestOverrides {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#continueRequestOverrides;\n  }\n\n  override responseForRequest(): Partial<ResponseForRequest> | null {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#responseForRequest;\n  }\n\n  override abortErrorReason(): Protocol.Network.ErrorReason | null {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#abortErrorReason;\n  }\n\n  override interceptResolutionState(): InterceptResolutionState {\n    if (!this.#allowInterception) {\n      return {action: InterceptResolutionAction.Disabled};\n    }\n    if (this.#interceptionHandled) {\n      return {action: InterceptResolutionAction.AlreadyHandled};\n    }\n    return {...this.#interceptResolutionState};\n  }\n\n  override isInterceptResolutionHandled(): boolean {\n    return this.#interceptionHandled;\n  }\n\n  override enqueueInterceptAction(\n    pendingHandler: () => void | PromiseLike<unknown>\n  ): void {\n    this.#interceptHandlers.push(pendingHandler);\n  }\n\n  override async finalizeInterceptions(): Promise<void> {\n    await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {action} = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return this.#abort(this.#abortErrorReason);\n      case 'respond':\n        if (this.#responseForRequest === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return this.#respond(this.#responseForRequest);\n      case 'continue':\n        return this.#continue(this.#continueRequestOverrides);\n    }\n  }\n\n  override resourceType(): ResourceType {\n    return this.#resourceType;\n  }\n\n  override method(): string {\n    return this.#method;\n  }\n\n  override postData(): string | undefined {\n    return this.#postData;\n  }\n\n  override headers(): Record<string, string> {\n    return this.#headers;\n  }\n\n  override response(): HTTPResponse | null {\n    return this._response;\n  }\n\n  override frame(): Frame | null {\n    return this.#frame;\n  }\n\n  override isNavigationRequest(): boolean {\n    return this.#isNavigationRequest;\n  }\n\n  override initiator(): Protocol.Network.Initiator | undefined {\n    return this.#initiator;\n  }\n\n  override redirectChain(): HTTPRequest[] {\n    return this._redirectChain.slice();\n  }\n\n  override failure(): {errorText: string} | null {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText,\n    };\n  }\n\n  override async continue(\n    overrides: ContinueRequestOverrides = {},\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return this.#continue(overrides);\n    }\n    this.#continueRequestOverrides = overrides;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority > this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (\n        this.#interceptResolutionState.action === 'abort' ||\n        this.#interceptResolutionState.action === 'respond'\n      ) {\n        return;\n      }\n      this.#interceptResolutionState.action =\n        InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n\n  async #continue(overrides: ContinueRequestOverrides = {}): Promise<void> {\n    const {url, method, postData, headers} = overrides;\n    this.#interceptionHandled = true;\n\n    const postDataBinaryBase64 = postData\n      ? Buffer.from(postData).toString('base64')\n      : undefined;\n\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.continueRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.continueRequest', {\n        requestId: this._interceptionId,\n        url,\n        method,\n        postData: postDataBinaryBase64,\n        headers: headers ? headersArray(headers) : undefined,\n      })\n      .catch(error => {\n        this.#interceptionHandled = false;\n        return handleError(error);\n      });\n  }\n\n  override async respond(\n    response: Partial<ResponseForRequest>,\n    priority?: number\n  ): Promise<void> {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return this.#respond(response);\n    }\n    this.#responseForRequest = response;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority > this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Respond;\n    }\n  }\n\n  async #respond(response: Partial<ResponseForRequest>): Promise<void> {\n    this.#interceptionHandled = true;\n\n    const responseBody: Buffer | null =\n      response.body && isString(response.body)\n        ? Buffer.from(response.body)\n        : (response.body as Buffer) || null;\n\n    const responseHeaders: Record<string, string | string[]> = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n\n        responseHeaders[header.toLowerCase()] = Array.isArray(value)\n          ? value.map(item => {\n              return String(item);\n            })\n          : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (responseBody && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(\n        Buffer.byteLength(responseBody)\n      );\n    }\n\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.fulfillRequest', {\n        requestId: this._interceptionId,\n        responseCode: status,\n        responsePhrase: STATUS_TEXTS[status],\n        responseHeaders: headersArray(responseHeaders),\n        body: responseBody ? responseBody.toString('base64') : undefined,\n      })\n      .catch(error => {\n        this.#interceptionHandled = false;\n        return handleError(error);\n      });\n  }\n\n  override async abort(\n    errorCode: ErrorCode = 'failed',\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return this.#abort(errorReason);\n    }\n    this.#abortErrorReason = errorReason;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority >= this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority,\n      };\n      return;\n    }\n  }\n\n  async #abort(\n    errorReason: Protocol.Network.ErrorReason | null\n  ): Promise<void> {\n    this.#interceptionHandled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.failRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.failRequest', {\n        requestId: this._interceptionId,\n        errorReason: errorReason || 'Failed',\n      })\n      .catch(handleError);\n  }\n}\n\nconst errorReasons: Record<ErrorCode, Protocol.Network.ErrorReason> = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed',\n} as const;\n\nasync function handleError(error: ProtocolError) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}