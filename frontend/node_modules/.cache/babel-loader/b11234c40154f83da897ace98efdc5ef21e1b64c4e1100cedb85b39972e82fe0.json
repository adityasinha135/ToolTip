{"ast":null,"code":"import { TimeoutError } from '../common/Errors.js';\n/**\n * Creates and returns a deferred object along with the resolve/reject functions.\n *\n * If the deferred has not been resolved/rejected within the `timeout` period,\n * the deferred gets resolves with a timeout error. `timeout` has to be greater than 0 or\n * it is ignored.\n *\n * @internal\n */\nexport class Deferred {\n  #isResolved = false;\n  #isRejected = false;\n  #value;\n  #resolver = () => {};\n  #taskPromise = new Promise(resolve => {\n    this.#resolver = resolve;\n  });\n  #timeoutId;\n  constructor(opts) {\n    this.#timeoutId = opts && opts.timeout > 0 ? setTimeout(() => {\n      this.reject(new TimeoutError(opts.message));\n    }, opts.timeout) : undefined;\n  }\n  #finish(value) {\n    clearTimeout(this.#timeoutId);\n    this.#value = value;\n    this.#resolver();\n  }\n  resolve(value) {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isResolved = true;\n    this.#finish(value);\n  }\n  reject(error) {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isRejected = true;\n    this.#finish(error);\n  }\n  resolved() {\n    return this.#isResolved;\n  }\n  finished() {\n    return this.#isResolved || this.#isRejected;\n  }\n  value() {\n    return this.#value;\n  }\n  async valueOrThrow() {\n    await this.#taskPromise;\n    if (this.#isRejected) {\n      throw this.#value;\n    }\n    return this.#value;\n  }\n  static create(opts) {\n    return new Deferred(opts);\n  }\n  static async race(awaitables) {\n    const deferredWithTimeout = new Set();\n    try {\n      const promises = awaitables.map(value => {\n        if (value instanceof Deferred) {\n          if (value.#timeoutId) {\n            deferredWithTimeout.add(value);\n          }\n          return value.valueOrThrow();\n        }\n        return value;\n      });\n      // eslint-disable-next-line no-restricted-syntax\n      return await Promise.race(promises);\n    } finally {\n      for (const deferred of deferredWithTimeout) {\n        // We need to stop the timeout else\n        // Node.JS will keep running the event loop till the\n        // timer executes\n        deferred.reject(new Error('Timeout cleared'));\n      }\n    }\n  }\n}","map":{"version":3,"names":["TimeoutError","Deferred","isResolved","isRejected","value","resolver","#resolver","taskPromise","Promise","resolve","timeoutId","constructor","opts","timeout","setTimeout","reject","message","undefined","finish","#finish","clearTimeout","error","resolved","finished","valueOrThrow","create","race","awaitables","deferredWithTimeout","Set","promises","map","add","deferred","Error"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/util/Deferred.ts"],"sourcesContent":["import {TimeoutError} from '../common/Errors.js';\n\n/**\n * @internal\n */\nexport interface DeferredOptions {\n  message: string;\n  timeout: number;\n}\n\n/**\n * Creates and returns a deferred object along with the resolve/reject functions.\n *\n * If the deferred has not been resolved/rejected within the `timeout` period,\n * the deferred gets resolves with a timeout error. `timeout` has to be greater than 0 or\n * it is ignored.\n *\n * @internal\n */\nexport class Deferred<T> {\n  #isResolved = false;\n  #isRejected = false;\n  #value: T | Error | undefined;\n  #resolver: (value: void) => void = () => {};\n  #taskPromise = new Promise<void>(resolve => {\n    this.#resolver = resolve;\n  });\n  #timeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(opts?: DeferredOptions) {\n    this.#timeoutId =\n      opts && opts.timeout > 0\n        ? setTimeout(() => {\n            this.reject(new TimeoutError(opts.message));\n          }, opts.timeout)\n        : undefined;\n  }\n\n  #finish(value: T | Error) {\n    clearTimeout(this.#timeoutId);\n    this.#value = value;\n    this.#resolver();\n  }\n\n  resolve(value: T): void {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isResolved = true;\n    this.#finish(value);\n  }\n\n  reject(error: Error): void {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isRejected = true;\n    this.#finish(error);\n  }\n\n  resolved(): boolean {\n    return this.#isResolved;\n  }\n\n  finished(): boolean {\n    return this.#isResolved || this.#isRejected;\n  }\n\n  value(): T | Error | undefined {\n    return this.#value;\n  }\n\n  async valueOrThrow(): Promise<T> {\n    await this.#taskPromise;\n    if (this.#isRejected) {\n      throw this.#value;\n    }\n    return this.#value as T;\n  }\n\n  static create<R>(opts?: DeferredOptions): Deferred<R> {\n    return new Deferred<R>(opts);\n  }\n\n  static async race<R>(\n    awaitables: Array<Promise<R> | Deferred<R>>\n  ): Promise<R> {\n    const deferredWithTimeout = new Set<Deferred<R>>();\n    try {\n      const promises = awaitables.map(value => {\n        if (value instanceof Deferred) {\n          if (value.#timeoutId) {\n            deferredWithTimeout.add(value);\n          }\n\n          return value.valueOrThrow();\n        }\n\n        return value;\n      });\n      // eslint-disable-next-line no-restricted-syntax\n      return await Promise.race(promises);\n    } finally {\n      for (const deferred of deferredWithTimeout) {\n        // We need to stop the timeout else\n        // Node.JS will keep running the event loop till the\n        // timer executes\n        deferred.reject(new Error('Timeout cleared'));\n      }\n    }\n  }\n}\n"],"mappings":"AAAA,SAAQA,YAAY,QAAO,qBAAqB;AAUhD;;;;;;;;;AASA,OAAM,MAAOC,QAAQ;EACnB,CAAAC,UAAW,GAAG,KAAK;EACnB,CAAAC,UAAW,GAAG,KAAK;EACnB,CAAAC,KAAM;EACN,CAAAC,QAAS,GAA0BC,CAAA,KAAK,CAAE,CAAC;EAC3C,CAAAC,WAAY,GAAG,IAAIC,OAAO,CAAOC,OAAO,IAAG;IACzC,IAAI,CAAC,CAAAJ,QAAS,GAAGI,OAAO;EAC1B,CAAC,CAAC;EACF,CAAAC,SAAU;EAEVC,YAAYC,IAAsB;IAChC,IAAI,CAAC,CAAAF,SAAU,GACbE,IAAI,IAAIA,IAAI,CAACC,OAAO,GAAG,CAAC,GACpBC,UAAU,CAAC,MAAK;MACd,IAAI,CAACC,MAAM,CAAC,IAAIf,YAAY,CAACY,IAAI,CAACI,OAAO,CAAC,CAAC;IAC7C,CAAC,EAAEJ,IAAI,CAACC,OAAO,CAAC,GAChBI,SAAS;EACjB;EAEA,CAAAC,MAAOC,CAACf,KAAgB;IACtBgB,YAAY,CAAC,IAAI,CAAC,CAAAV,SAAU,CAAC;IAC7B,IAAI,CAAC,CAAAN,KAAM,GAAGA,KAAK;IACnB,IAAI,CAAC,CAAAC,QAAS,EAAE;EAClB;EAEAI,OAAOA,CAACL,KAAQ;IACd,IAAI,IAAI,CAAC,CAAAD,UAAW,IAAI,IAAI,CAAC,CAAAD,UAAW,EAAE;MACxC;;IAEF,IAAI,CAAC,CAAAA,UAAW,GAAG,IAAI;IACvB,IAAI,CAAC,CAAAgB,MAAO,CAACd,KAAK,CAAC;EACrB;EAEAW,MAAMA,CAACM,KAAY;IACjB,IAAI,IAAI,CAAC,CAAAlB,UAAW,IAAI,IAAI,CAAC,CAAAD,UAAW,EAAE;MACxC;;IAEF,IAAI,CAAC,CAAAC,UAAW,GAAG,IAAI;IACvB,IAAI,CAAC,CAAAe,MAAO,CAACG,KAAK,CAAC;EACrB;EAEAC,QAAQA,CAAA;IACN,OAAO,IAAI,CAAC,CAAApB,UAAW;EACzB;EAEAqB,QAAQA,CAAA;IACN,OAAO,IAAI,CAAC,CAAArB,UAAW,IAAI,IAAI,CAAC,CAAAC,UAAW;EAC7C;EAEAC,KAAKA,CAAA;IACH,OAAO,IAAI,CAAC,CAAAA,KAAM;EACpB;EAEA,MAAMoB,YAAYA,CAAA;IAChB,MAAM,IAAI,CAAC,CAAAjB,WAAY;IACvB,IAAI,IAAI,CAAC,CAAAJ,UAAW,EAAE;MACpB,MAAM,IAAI,CAAC,CAAAC,KAAM;;IAEnB,OAAO,IAAI,CAAC,CAAAA,KAAW;EACzB;EAEA,OAAOqB,MAAMA,CAAIb,IAAsB;IACrC,OAAO,IAAIX,QAAQ,CAAIW,IAAI,CAAC;EAC9B;EAEA,aAAac,IAAIA,CACfC,UAA2C;IAE3C,MAAMC,mBAAmB,GAAG,IAAIC,GAAG,EAAe;IAClD,IAAI;MACF,MAAMC,QAAQ,GAAGH,UAAU,CAACI,GAAG,CAAC3B,KAAK,IAAG;QACtC,IAAIA,KAAK,YAAYH,QAAQ,EAAE;UAC7B,IAAIG,KAAK,CAAC,CAAAM,SAAU,EAAE;YACpBkB,mBAAmB,CAACI,GAAG,CAAC5B,KAAK,CAAC;;UAGhC,OAAOA,KAAK,CAACoB,YAAY,EAAE;;QAG7B,OAAOpB,KAAK;MACd,CAAC,CAAC;MACF;MACA,OAAO,MAAMI,OAAO,CAACkB,IAAI,CAACI,QAAQ,CAAC;KACpC,SAAS;MACR,KAAK,MAAMG,QAAQ,IAAIL,mBAAmB,EAAE;QAC1C;QACA;QACA;QACAK,QAAQ,CAAClB,MAAM,CAAC,IAAImB,KAAK,CAAC,iBAAiB,CAAC,CAAC;;;EAGnD"},"metadata":{},"sourceType":"module","externalDependencies":[]}