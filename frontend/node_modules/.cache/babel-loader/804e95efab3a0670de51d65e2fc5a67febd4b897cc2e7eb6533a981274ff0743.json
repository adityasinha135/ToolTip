{"ast":null,"code":"/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { Connection } from './Connection.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { InitializationStatus, CDPTarget } from './Target.js';\nimport { debugError } from './util.js';\n/**\n * ChromeTargetManager uses the CDP's auto-attach mechanism to intercept\n * new targets and allow the rest of Puppeteer to configure listeners while\n * the target is paused.\n *\n * @internal\n */\nexport class ChromeTargetManager extends EventEmitter {\n  #connection;\n  /**\n   * Keeps track of the following events: 'Target.targetCreated',\n   * 'Target.targetDestroyed', 'Target.targetInfoChanged'.\n   *\n   * A target becomes discovered when 'Target.targetCreated' is received.\n   * A target is removed from this map once 'Target.targetDestroyed' is\n   * received.\n   *\n   * `targetFilterCallback` has no effect on this map.\n   */\n  #discoveredTargetsByTargetId = new Map();\n  /**\n   * A target is added to this map once ChromeTargetManager has created\n   * a Target and attached at least once to it.\n   */\n  #attachedTargetsByTargetId = new Map();\n  /**\n   * Tracks which sessions attach to which target.\n   */\n  #attachedTargetsBySessionId = new Map();\n  /**\n   * If a target was filtered out by `targetFilterCallback`, we still receive\n   * events about it from CDP, but we don't forward them to the rest of Puppeteer.\n   */\n  #ignoredTargets = new Set();\n  #targetFilterCallback;\n  #targetFactory;\n  #targetInterceptors = new WeakMap();\n  #attachedToTargetListenersBySession = new WeakMap();\n  #detachedFromTargetListenersBySession = new WeakMap();\n  #initializeDeferred = Deferred.create();\n  #targetsIdsForInit = new Set();\n  constructor(connection, targetFactory, targetFilterCallback) {\n    super();\n    this.#connection = connection;\n    this.#targetFilterCallback = targetFilterCallback;\n    this.#targetFactory = targetFactory;\n    this.#connection.on('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.on('Target.targetInfoChanged', this.#onTargetInfoChanged);\n    this.#connection.on('sessiondetached', this.#onSessionDetached);\n    this.#setupAttachmentListeners(this.#connection);\n    this.#connection.send('Target.setDiscoverTargets', {\n      discover: true,\n      filter: [{\n        type: 'tab',\n        exclude: true\n      }, {}]\n    }).then(this.#storeExistingTargetsForInit).catch(debugError);\n  }\n  #storeExistingTargetsForInit = () => {\n    for (const [targetId, targetInfo] of this.#discoveredTargetsByTargetId.entries()) {\n      const targetForFilter = new CDPTarget(targetInfo, undefined, undefined, this, undefined);\n      if ((!this.#targetFilterCallback || this.#targetFilterCallback(targetForFilter)) && targetInfo.type !== 'browser') {\n        this.#targetsIdsForInit.add(targetId);\n      }\n    }\n  };\n  async initialize() {\n    await this.#connection.send('Target.setAutoAttach', {\n      waitForDebuggerOnStart: true,\n      flatten: true,\n      autoAttach: true\n    });\n    this.#finishInitializationIfReady();\n    await this.#initializeDeferred.valueOrThrow();\n  }\n  dispose() {\n    this.#connection.off('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.off('Target.targetInfoChanged', this.#onTargetInfoChanged);\n    this.#connection.off('sessiondetached', this.#onSessionDetached);\n    this.#removeAttachmentListeners(this.#connection);\n  }\n  getAvailableTargets() {\n    return this.#attachedTargetsByTargetId;\n  }\n  addTargetInterceptor(session, interceptor) {\n    const interceptors = this.#targetInterceptors.get(session) || [];\n    interceptors.push(interceptor);\n    this.#targetInterceptors.set(session, interceptors);\n  }\n  removeTargetInterceptor(client, interceptor) {\n    const interceptors = this.#targetInterceptors.get(client) || [];\n    this.#targetInterceptors.set(client, interceptors.filter(currentInterceptor => {\n      return currentInterceptor !== interceptor;\n    }));\n  }\n  #setupAttachmentListeners(session) {\n    const listener = event => {\n      return this.#onAttachedToTarget(session, event);\n    };\n    assert(!this.#attachedToTargetListenersBySession.has(session));\n    this.#attachedToTargetListenersBySession.set(session, listener);\n    session.on('Target.attachedToTarget', listener);\n    const detachedListener = event => {\n      return this.#onDetachedFromTarget(session, event);\n    };\n    assert(!this.#detachedFromTargetListenersBySession.has(session));\n    this.#detachedFromTargetListenersBySession.set(session, detachedListener);\n    session.on('Target.detachedFromTarget', detachedListener);\n  }\n  #removeAttachmentListeners(session) {\n    if (this.#attachedToTargetListenersBySession.has(session)) {\n      session.off('Target.attachedToTarget', this.#attachedToTargetListenersBySession.get(session));\n      this.#attachedToTargetListenersBySession.delete(session);\n    }\n    if (this.#detachedFromTargetListenersBySession.has(session)) {\n      session.off('Target.detachedFromTarget', this.#detachedFromTargetListenersBySession.get(session));\n      this.#detachedFromTargetListenersBySession.delete(session);\n    }\n  }\n  #onSessionDetached = session => {\n    this.#removeAttachmentListeners(session);\n    this.#targetInterceptors.delete(session);\n  };\n  #onTargetCreated = async event => {\n    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);\n    this.emit(\"targetDiscovered\" /* TargetManagerEmittedEvents.TargetDiscovered */, event.targetInfo);\n    // The connection is already attached to the browser target implicitly,\n    // therefore, no new CDPSession is created and we have special handling\n    // here.\n    if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {\n      if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {\n        return;\n      }\n      const target = this.#targetFactory(event.targetInfo, undefined);\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);\n    }\n  };\n  #onTargetDestroyed = event => {\n    const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);\n    this.#discoveredTargetsByTargetId.delete(event.targetId);\n    this.#finishInitializationIfReady(event.targetId);\n    if (targetInfo?.type === 'service_worker' && this.#attachedTargetsByTargetId.has(event.targetId)) {\n      // Special case for service workers: report TargetGone event when\n      // the worker is destroyed.\n      const target = this.#attachedTargetsByTargetId.get(event.targetId);\n      this.emit(\"targetGone\" /* TargetManagerEmittedEvents.TargetGone */, target);\n      this.#attachedTargetsByTargetId.delete(event.targetId);\n    }\n  };\n  #onTargetInfoChanged = event => {\n    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);\n    if (this.#ignoredTargets.has(event.targetInfo.targetId) || !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) || !event.targetInfo.attached) {\n      return;\n    }\n    const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);\n    if (!target) {\n      return;\n    }\n    const previousURL = target.url();\n    const wasInitialized = target._initializedDeferred.value() === InitializationStatus.SUCCESS;\n    target._targetInfoChanged(event.targetInfo);\n    if (wasInitialized && previousURL !== target.url()) {\n      this.emit(\"targetChanged\" /* TargetManagerEmittedEvents.TargetChanged */, {\n        target: target,\n        wasInitialized,\n        previousURL\n      });\n    }\n  };\n  #onAttachedToTarget = async (parentSession, event) => {\n    const targetInfo = event.targetInfo;\n    const session = this.#connection.session(event.sessionId);\n    if (!session) {\n      throw new Error(`Session ${event.sessionId} was not created.`);\n    }\n    const silentDetach = async () => {\n      await session.send('Runtime.runIfWaitingForDebugger').catch(debugError);\n      // We don't use `session.detach()` because that dispatches all commands on\n      // the connection instead of the parent session.\n      await parentSession.send('Target.detachFromTarget', {\n        sessionId: session.id()\n      }).catch(debugError);\n    };\n    if (!this.#connection.isAutoAttached(targetInfo.targetId)) {\n      return;\n    }\n    // Special case for service workers: being attached to service workers will\n    // prevent them from ever being destroyed. Therefore, we silently detach\n    // from service workers unless the connection was manually created via\n    // `page.worker()`. To determine this, we use\n    // `this.#connection.isAutoAttached(targetInfo.targetId)`. In the future, we\n    // should determine if a target is auto-attached or not with the help of\n    // CDP.\n    if (targetInfo.type === 'service_worker' && this.#connection.isAutoAttached(targetInfo.targetId)) {\n      this.#finishInitializationIfReady(targetInfo.targetId);\n      await silentDetach();\n      if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {\n        return;\n      }\n      const target = this.#targetFactory(targetInfo);\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);\n      this.emit(\"targetAvailable\" /* TargetManagerEmittedEvents.TargetAvailable */, target);\n      return;\n    }\n    const existingTarget = this.#attachedTargetsByTargetId.has(targetInfo.targetId);\n    const target = existingTarget ? this.#attachedTargetsByTargetId.get(targetInfo.targetId) : this.#targetFactory(targetInfo, session);\n    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {\n      this.#ignoredTargets.add(targetInfo.targetId);\n      this.#finishInitializationIfReady(targetInfo.targetId);\n      await silentDetach();\n      return;\n    }\n    if (!existingTarget) {\n      target._initialize();\n    }\n    this.#setupAttachmentListeners(session);\n    if (existingTarget) {\n      this.#attachedTargetsBySessionId.set(session.id(), this.#attachedTargetsByTargetId.get(targetInfo.targetId));\n    } else {\n      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);\n      this.#attachedTargetsBySessionId.set(session.id(), target);\n    }\n    for (const interceptor of this.#targetInterceptors.get(parentSession) || []) {\n      if (!(parentSession instanceof Connection)) {\n        // Sanity check: if parent session is not a connection, it should be\n        // present in #attachedTargetsBySessionId.\n        assert(this.#attachedTargetsBySessionId.has(parentSession.id()));\n      }\n      interceptor(target, parentSession instanceof Connection ? null : this.#attachedTargetsBySessionId.get(parentSession.id()));\n    }\n    this.#targetsIdsForInit.delete(target._targetId);\n    if (!existingTarget) {\n      this.emit(\"targetAvailable\" /* TargetManagerEmittedEvents.TargetAvailable */, target);\n    }\n    this.#finishInitializationIfReady();\n    // TODO: the browser might be shutting down here. What do we do with the\n    // error?\n    await Promise.all([session.send('Target.setAutoAttach', {\n      waitForDebuggerOnStart: true,\n      flatten: true,\n      autoAttach: true\n    }), session.send('Runtime.runIfWaitingForDebugger')]).catch(debugError);\n  };\n  #finishInitializationIfReady(targetId) {\n    targetId !== undefined && this.#targetsIdsForInit.delete(targetId);\n    if (this.#targetsIdsForInit.size === 0) {\n      this.#initializeDeferred.resolve();\n    }\n  }\n  #onDetachedFromTarget = (_parentSession, event) => {\n    const target = this.#attachedTargetsBySessionId.get(event.sessionId);\n    this.#attachedTargetsBySessionId.delete(event.sessionId);\n    if (!target) {\n      return;\n    }\n    this.#attachedTargetsByTargetId.delete(target._targetId);\n    this.emit(\"targetGone\" /* TargetManagerEmittedEvents.TargetGone */, target);\n  };\n}","map":{"version":3,"names":["assert","Deferred","Connection","EventEmitter","InitializationStatus","CDPTarget","debugError","ChromeTargetManager","connection","discoveredTargetsByTargetId","Map","attachedTargetsByTargetId","attachedTargetsBySessionId","ignoredTargets","Set","targetFilterCallback","targetFactory","targetInterceptors","WeakMap","attachedToTargetListenersBySession","detachedFromTargetListenersBySession","initializeDeferred","create","targetsIdsForInit","constructor","on","onTargetCreated","onTargetDestroyed","onTargetInfoChanged","onSessionDetached","setupAttachmentListeners","send","discover","filter","type","exclude","then","storeExistingTargetsForInit","catch","#storeExistingTargetsForInit","targetId","targetInfo","entries","targetForFilter","undefined","add","initialize","waitForDebuggerOnStart","flatten","autoAttach","finishInitializationIfReady","valueOrThrow","dispose","off","removeAttachmentListeners","getAvailableTargets","addTargetInterceptor","session","interceptor","interceptors","get","push","set","removeTargetInterceptor","client","currentInterceptor","#setupAttachmentListeners","listener","event","onAttachedToTarget","has","detachedListener","onDetachedFromTarget","#removeAttachmentListeners","delete","emit","attached","target","_initialize","previousURL","url","wasInitialized","_initializedDeferred","value","SUCCESS","_targetInfoChanged","#onAttachedToTarget","parentSession","sessionId","Error","silentDetach","id","isAutoAttached","existingTarget","_targetId","Promise","all","#finishInitializationIfReady","size","resolve","#onDetachedFromTarget","_parentSession"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/ChromeTargetManager.ts"],"sourcesContent":["/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Protocol} from 'devtools-protocol';\n\nimport {TargetFilterCallback} from '../api/Browser.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\n\nimport {CDPSession, Connection} from './Connection.js';\nimport {EventEmitter} from './EventEmitter.js';\nimport {InitializationStatus, CDPTarget} from './Target.js';\nimport {\n  TargetInterceptor,\n  TargetFactory,\n  TargetManager,\n  TargetManagerEmittedEvents,\n} from './TargetManager.js';\nimport {debugError} from './util.js';\n\n/**\n * ChromeTargetManager uses the CDP's auto-attach mechanism to intercept\n * new targets and allow the rest of Puppeteer to configure listeners while\n * the target is paused.\n *\n * @internal\n */\nexport class ChromeTargetManager extends EventEmitter implements TargetManager {\n  #connection: Connection;\n  /**\n   * Keeps track of the following events: 'Target.targetCreated',\n   * 'Target.targetDestroyed', 'Target.targetInfoChanged'.\n   *\n   * A target becomes discovered when 'Target.targetCreated' is received.\n   * A target is removed from this map once 'Target.targetDestroyed' is\n   * received.\n   *\n   * `targetFilterCallback` has no effect on this map.\n   */\n  #discoveredTargetsByTargetId = new Map<string, Protocol.Target.TargetInfo>();\n  /**\n   * A target is added to this map once ChromeTargetManager has created\n   * a Target and attached at least once to it.\n   */\n  #attachedTargetsByTargetId = new Map<string, CDPTarget>();\n  /**\n   * Tracks which sessions attach to which target.\n   */\n  #attachedTargetsBySessionId = new Map<string, CDPTarget>();\n  /**\n   * If a target was filtered out by `targetFilterCallback`, we still receive\n   * events about it from CDP, but we don't forward them to the rest of Puppeteer.\n   */\n  #ignoredTargets = new Set<string>();\n  #targetFilterCallback: TargetFilterCallback | undefined;\n  #targetFactory: TargetFactory;\n\n  #targetInterceptors = new WeakMap<\n    CDPSession | Connection,\n    TargetInterceptor[]\n  >();\n\n  #attachedToTargetListenersBySession = new WeakMap<\n    CDPSession | Connection,\n    (event: Protocol.Target.AttachedToTargetEvent) => Promise<void>\n  >();\n  #detachedFromTargetListenersBySession = new WeakMap<\n    CDPSession | Connection,\n    (event: Protocol.Target.DetachedFromTargetEvent) => void\n  >();\n\n  #initializeDeferred = Deferred.create<void>();\n  #targetsIdsForInit = new Set<string>();\n\n  constructor(\n    connection: Connection,\n    targetFactory: TargetFactory,\n    targetFilterCallback?: TargetFilterCallback\n  ) {\n    super();\n    this.#connection = connection;\n    this.#targetFilterCallback = targetFilterCallback;\n    this.#targetFactory = targetFactory;\n\n    this.#connection.on('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.on('Target.targetInfoChanged', this.#onTargetInfoChanged);\n    this.#connection.on('sessiondetached', this.#onSessionDetached);\n    this.#setupAttachmentListeners(this.#connection);\n\n    this.#connection\n      .send('Target.setDiscoverTargets', {\n        discover: true,\n        filter: [{type: 'tab', exclude: true}, {}],\n      })\n      .then(this.#storeExistingTargetsForInit)\n      .catch(debugError);\n  }\n\n  #storeExistingTargetsForInit = () => {\n    for (const [\n      targetId,\n      targetInfo,\n    ] of this.#discoveredTargetsByTargetId.entries()) {\n      const targetForFilter = new CDPTarget(\n        targetInfo,\n        undefined,\n        undefined,\n        this,\n        undefined\n      );\n      if (\n        (!this.#targetFilterCallback ||\n          this.#targetFilterCallback(targetForFilter)) &&\n        targetInfo.type !== 'browser'\n      ) {\n        this.#targetsIdsForInit.add(targetId);\n      }\n    }\n  };\n\n  async initialize(): Promise<void> {\n    await this.#connection.send('Target.setAutoAttach', {\n      waitForDebuggerOnStart: true,\n      flatten: true,\n      autoAttach: true,\n    });\n    this.#finishInitializationIfReady();\n    await this.#initializeDeferred.valueOrThrow();\n  }\n\n  dispose(): void {\n    this.#connection.off('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.off('Target.targetInfoChanged', this.#onTargetInfoChanged);\n    this.#connection.off('sessiondetached', this.#onSessionDetached);\n\n    this.#removeAttachmentListeners(this.#connection);\n  }\n\n  getAvailableTargets(): Map<string, CDPTarget> {\n    return this.#attachedTargetsByTargetId;\n  }\n\n  addTargetInterceptor(\n    session: CDPSession | Connection,\n    interceptor: TargetInterceptor\n  ): void {\n    const interceptors = this.#targetInterceptors.get(session) || [];\n    interceptors.push(interceptor);\n    this.#targetInterceptors.set(session, interceptors);\n  }\n\n  removeTargetInterceptor(\n    client: CDPSession | Connection,\n    interceptor: TargetInterceptor\n  ): void {\n    const interceptors = this.#targetInterceptors.get(client) || [];\n    this.#targetInterceptors.set(\n      client,\n      interceptors.filter(currentInterceptor => {\n        return currentInterceptor !== interceptor;\n      })\n    );\n  }\n\n  #setupAttachmentListeners(session: CDPSession | Connection): void {\n    const listener = (event: Protocol.Target.AttachedToTargetEvent) => {\n      return this.#onAttachedToTarget(session, event);\n    };\n    assert(!this.#attachedToTargetListenersBySession.has(session));\n    this.#attachedToTargetListenersBySession.set(session, listener);\n    session.on('Target.attachedToTarget', listener);\n\n    const detachedListener = (\n      event: Protocol.Target.DetachedFromTargetEvent\n    ) => {\n      return this.#onDetachedFromTarget(session, event);\n    };\n    assert(!this.#detachedFromTargetListenersBySession.has(session));\n    this.#detachedFromTargetListenersBySession.set(session, detachedListener);\n    session.on('Target.detachedFromTarget', detachedListener);\n  }\n\n  #removeAttachmentListeners(session: CDPSession | Connection): void {\n    if (this.#attachedToTargetListenersBySession.has(session)) {\n      session.off(\n        'Target.attachedToTarget',\n        this.#attachedToTargetListenersBySession.get(session)!\n      );\n      this.#attachedToTargetListenersBySession.delete(session);\n    }\n\n    if (this.#detachedFromTargetListenersBySession.has(session)) {\n      session.off(\n        'Target.detachedFromTarget',\n        this.#detachedFromTargetListenersBySession.get(session)!\n      );\n      this.#detachedFromTargetListenersBySession.delete(session);\n    }\n  }\n\n  #onSessionDetached = (session: CDPSession) => {\n    this.#removeAttachmentListeners(session);\n    this.#targetInterceptors.delete(session);\n  };\n\n  #onTargetCreated = async (event: Protocol.Target.TargetCreatedEvent) => {\n    this.#discoveredTargetsByTargetId.set(\n      event.targetInfo.targetId,\n      event.targetInfo\n    );\n\n    this.emit(TargetManagerEmittedEvents.TargetDiscovered, event.targetInfo);\n\n    // The connection is already attached to the browser target implicitly,\n    // therefore, no new CDPSession is created and we have special handling\n    // here.\n    if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {\n      if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {\n        return;\n      }\n      const target = this.#targetFactory(event.targetInfo, undefined);\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);\n    }\n  };\n\n  #onTargetDestroyed = (event: Protocol.Target.TargetDestroyedEvent) => {\n    const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);\n    this.#discoveredTargetsByTargetId.delete(event.targetId);\n    this.#finishInitializationIfReady(event.targetId);\n    if (\n      targetInfo?.type === 'service_worker' &&\n      this.#attachedTargetsByTargetId.has(event.targetId)\n    ) {\n      // Special case for service workers: report TargetGone event when\n      // the worker is destroyed.\n      const target = this.#attachedTargetsByTargetId.get(event.targetId);\n      this.emit(TargetManagerEmittedEvents.TargetGone, target);\n      this.#attachedTargetsByTargetId.delete(event.targetId);\n    }\n  };\n\n  #onTargetInfoChanged = (event: Protocol.Target.TargetInfoChangedEvent) => {\n    this.#discoveredTargetsByTargetId.set(\n      event.targetInfo.targetId,\n      event.targetInfo\n    );\n\n    if (\n      this.#ignoredTargets.has(event.targetInfo.targetId) ||\n      !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) ||\n      !event.targetInfo.attached\n    ) {\n      return;\n    }\n\n    const target = this.#attachedTargetsByTargetId.get(\n      event.targetInfo.targetId\n    );\n    if (!target) {\n      return;\n    }\n    const previousURL = target.url();\n    const wasInitialized =\n      target._initializedDeferred.value() === InitializationStatus.SUCCESS;\n\n    target._targetInfoChanged(event.targetInfo);\n\n    if (wasInitialized && previousURL !== target.url()) {\n      this.emit(TargetManagerEmittedEvents.TargetChanged, {\n        target: target,\n        wasInitialized,\n        previousURL,\n      });\n    }\n  };\n\n  #onAttachedToTarget = async (\n    parentSession: Connection | CDPSession,\n    event: Protocol.Target.AttachedToTargetEvent\n  ) => {\n    const targetInfo = event.targetInfo;\n    const session = this.#connection.session(event.sessionId);\n    if (!session) {\n      throw new Error(`Session ${event.sessionId} was not created.`);\n    }\n\n    const silentDetach = async () => {\n      await session.send('Runtime.runIfWaitingForDebugger').catch(debugError);\n      // We don't use `session.detach()` because that dispatches all commands on\n      // the connection instead of the parent session.\n      await parentSession\n        .send('Target.detachFromTarget', {\n          sessionId: session.id(),\n        })\n        .catch(debugError);\n    };\n\n    if (!this.#connection.isAutoAttached(targetInfo.targetId)) {\n      return;\n    }\n\n    // Special case for service workers: being attached to service workers will\n    // prevent them from ever being destroyed. Therefore, we silently detach\n    // from service workers unless the connection was manually created via\n    // `page.worker()`. To determine this, we use\n    // `this.#connection.isAutoAttached(targetInfo.targetId)`. In the future, we\n    // should determine if a target is auto-attached or not with the help of\n    // CDP.\n    if (\n      targetInfo.type === 'service_worker' &&\n      this.#connection.isAutoAttached(targetInfo.targetId)\n    ) {\n      this.#finishInitializationIfReady(targetInfo.targetId);\n      await silentDetach();\n      if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {\n        return;\n      }\n      const target = this.#targetFactory(targetInfo);\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);\n      this.emit(TargetManagerEmittedEvents.TargetAvailable, target);\n      return;\n    }\n\n    const existingTarget = this.#attachedTargetsByTargetId.has(\n      targetInfo.targetId\n    );\n\n    const target = existingTarget\n      ? this.#attachedTargetsByTargetId.get(targetInfo.targetId)!\n      : this.#targetFactory(targetInfo, session);\n\n    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {\n      this.#ignoredTargets.add(targetInfo.targetId);\n      this.#finishInitializationIfReady(targetInfo.targetId);\n      await silentDetach();\n      return;\n    }\n\n    if (!existingTarget) {\n      target._initialize();\n    }\n\n    this.#setupAttachmentListeners(session);\n\n    if (existingTarget) {\n      this.#attachedTargetsBySessionId.set(\n        session.id(),\n        this.#attachedTargetsByTargetId.get(targetInfo.targetId)!\n      );\n    } else {\n      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);\n      this.#attachedTargetsBySessionId.set(session.id(), target);\n    }\n\n    for (const interceptor of this.#targetInterceptors.get(parentSession) ||\n      []) {\n      if (!(parentSession instanceof Connection)) {\n        // Sanity check: if parent session is not a connection, it should be\n        // present in #attachedTargetsBySessionId.\n        assert(this.#attachedTargetsBySessionId.has(parentSession.id()));\n      }\n      interceptor(\n        target,\n        parentSession instanceof Connection\n          ? null\n          : this.#attachedTargetsBySessionId.get(parentSession.id())!\n      );\n    }\n\n    this.#targetsIdsForInit.delete(target._targetId);\n    if (!existingTarget) {\n      this.emit(TargetManagerEmittedEvents.TargetAvailable, target);\n    }\n    this.#finishInitializationIfReady();\n\n    // TODO: the browser might be shutting down here. What do we do with the\n    // error?\n    await Promise.all([\n      session.send('Target.setAutoAttach', {\n        waitForDebuggerOnStart: true,\n        flatten: true,\n        autoAttach: true,\n      }),\n      session.send('Runtime.runIfWaitingForDebugger'),\n    ]).catch(debugError);\n  };\n\n  #finishInitializationIfReady(targetId?: string): void {\n    targetId !== undefined && this.#targetsIdsForInit.delete(targetId);\n    if (this.#targetsIdsForInit.size === 0) {\n      this.#initializeDeferred.resolve();\n    }\n  }\n\n  #onDetachedFromTarget = (\n    _parentSession: Connection | CDPSession,\n    event: Protocol.Target.DetachedFromTargetEvent\n  ) => {\n    const target = this.#attachedTargetsBySessionId.get(event.sessionId);\n\n    this.#attachedTargetsBySessionId.delete(event.sessionId);\n\n    if (!target) {\n      return;\n    }\n\n    this.#attachedTargetsByTargetId.delete(target._targetId);\n    this.emit(TargetManagerEmittedEvents.TargetGone, target);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}