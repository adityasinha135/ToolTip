{"ast":null,"code":"/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';\nimport { LifecycleWatcher } from './LifecycleWatcher.js';\nimport { addPageBinding, createJSHandle, debugError, getPageContent, setPageContent, withSourcePuppeteerURLIfNone } from './util.js';\nimport { TaskManager, WaitTask } from './WaitTask.js';\n/**\n * @internal\n */\nexport class IsolatedWorld {\n  #frame;\n  #document;\n  #context = Deferred.create();\n  #detached = false;\n  // Set of bindings that have been registered in the current context.\n  #contextBindings = new Set();\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map();\n  #taskManager = new TaskManager();\n  get taskManager() {\n    return this.#taskManager;\n  }\n  get _bindings() {\n    return this.#bindings;\n  }\n  constructor(frame) {\n    // Keep own reference to client because it might differ from the FrameManager's\n    // client for OOP iframes.\n    this.#frame = frame;\n    this.#client.on('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n  get #client() {\n    return this.#frame._client();\n  }\n  get #frameManager() {\n    return this.#frame._frameManager;\n  }\n  get #timeoutSettings() {\n    return this.#frameManager.timeoutSettings;\n  }\n  frame() {\n    return this.#frame;\n  }\n  clearContext() {\n    this.#document = undefined;\n    this.#context = Deferred.create();\n  }\n  setContext(context) {\n    this.#contextBindings.clear();\n    this.#context.resolve(context);\n    void this.#taskManager.rerunAll();\n  }\n  hasContext() {\n    return this.#context.resolved();\n  }\n  _detach() {\n    this.#detached = true;\n    this.#client.off('Runtime.bindingCalled', this.#onBindingCalled);\n    this.#taskManager.terminateAll(new Error('waitForFunction failed: frame got detached.'));\n  }\n  executionContext() {\n    if (this.#detached) {\n      throw new Error(`Execution context is not available in detached frame \"${this.#frame.url()}\" (are you trying to evaluate?)`);\n    }\n    if (this.#context === null) {\n      throw new Error(`Execution content promise is missing`);\n    }\n    return this.#context.valueOrThrow();\n  }\n  async evaluateHandle(pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n    const context = await this.executionContext();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n  async evaluate(pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n    const context = await this.executionContext();\n    return context.evaluate(pageFunction, ...args);\n  }\n  async $(selector) {\n    const document = await this.document();\n    return document.$(selector);\n  }\n  async $$(selector) {\n    const document = await this.document();\n    return document.$$(selector);\n  }\n  async document() {\n    if (this.#document) {\n      return this.#document;\n    }\n    const context = await this.executionContext();\n    this.#document = await context.evaluateHandle(() => {\n      return document;\n    });\n    return this.#document;\n  }\n  async $x(expression) {\n    const document = await this.document();\n    return document.$x(expression);\n  }\n  async $eval(selector, pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    const document = await this.document();\n    return document.$eval(selector, pageFunction, ...args);\n  }\n  async $$eval(selector, pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    const document = await this.document();\n    return document.$$eval(selector, pageFunction, ...args);\n  }\n  async content() {\n    return await this.evaluate(getPageContent);\n  }\n  async setContent(html, options = {}) {\n    const {\n      waitUntil = ['load'],\n      timeout = this.#timeoutSettings.navigationTimeout()\n    } = options;\n    await setPageContent(this, html);\n    const watcher = new LifecycleWatcher(this.#frameManager, this.#frame, waitUntil, timeout);\n    const error = await Deferred.race([watcher.terminationPromise(), watcher.lifecyclePromise()]);\n    watcher.dispose();\n    if (error) {\n      throw error;\n    }\n  }\n  async click(selector, options) {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.click(options);\n    await handle.dispose();\n  }\n  async focus(selector) {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.focus();\n    await handle.dispose();\n  }\n  async hover(selector) {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.hover();\n    await handle.dispose();\n  }\n  async select(selector, ...values) {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    const result = await handle.select(...values);\n    await handle.dispose();\n    return result;\n  }\n  async tap(selector) {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.tap();\n    await handle.dispose();\n  }\n  async type(selector, text, options) {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.type(text, options);\n    await handle.dispose();\n  }\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async _addBindingToContext(context, name) {\n    if (this.#contextBindings.has(name)) {\n      return;\n    }\n    await this.#mutex.acquire();\n    try {\n      await context._client.send('Runtime.addBinding', context._contextName ? {\n        name,\n        executionContextName: context._contextName\n      } : {\n        name,\n        executionContextId: context._contextId\n      });\n      await context.evaluate(addPageBinding, 'internal', name);\n      this.#contextBindings.add(name);\n    } catch (error) {\n      // We could have tried to evaluate in a context which was already\n      // destroyed. This happens, for example, if the page is navigated while\n      // we are trying to add the binding\n      if (error instanceof Error) {\n        // Destroyed context.\n        if (error.message.includes('Execution context was destroyed')) {\n          return;\n        }\n        // Missing context.\n        if (error.message.includes('Cannot find context with specified id')) {\n          return;\n        }\n      }\n      debugError(error);\n    } finally {\n      this.#mutex.release();\n    }\n  }\n  #onBindingCalled = async event => {\n    let payload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {\n      type,\n      name,\n      seq,\n      args,\n      isTrivial\n    } = payload;\n    if (type !== 'internal') {\n      return;\n    }\n    if (!this.#contextBindings.has(name)) {\n      return;\n    }\n    try {\n      const context = await this.#context.valueOrThrow();\n      if (event.executionContextId !== context._contextId) {\n        return;\n      }\n      const binding = this._bindings.get(name);\n      await binding?.run(context, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  };\n  waitForFunction(pageFunction, options = {}, ...args) {\n    const {\n      polling = 'raf',\n      timeout = this.#timeoutSettings.timeout(),\n      root,\n      signal\n    } = options;\n    if (typeof polling === 'number' && polling < 0) {\n      throw new Error('Cannot poll with non-positive interval');\n    }\n    const waitTask = new WaitTask(this, {\n      polling,\n      root,\n      timeout,\n      signal\n    }, pageFunction, ...args);\n    return waitTask.result;\n  }\n  async title() {\n    return this.evaluate(() => {\n      return document.title;\n    });\n  }\n  async adoptBackendNode(backendNodeId) {\n    const executionContext = await this.executionContext();\n    const {\n      object\n    } = await this.#client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: executionContext._contextId\n    });\n    return createJSHandle(executionContext, object);\n  }\n  async adoptHandle(handle) {\n    const context = await this.executionContext();\n    assert(handle.executionContext() !== context, 'Cannot adopt handle that already belongs to this execution context');\n    const nodeInfo = await this.#client.send('DOM.describeNode', {\n      objectId: handle.id\n    });\n    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);\n  }\n  async transferHandle(handle) {\n    const context = await this.executionContext();\n    if (handle.executionContext() === context) {\n      return handle;\n    }\n    const info = await this.#client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId\n    });\n    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);\n    await handle.dispose();\n    return newHandle;\n  }\n}\nclass Mutex {\n  #locked = false;\n  #acquirers = [];\n  // This is FIFO.\n  acquire() {\n    if (!this.#locked) {\n      this.#locked = true;\n      return Promise.resolve();\n    }\n    const deferred = Deferred.create();\n    this.#acquirers.push(deferred.resolve.bind(deferred));\n    return deferred.valueOrThrow();\n  }\n  release() {\n    const resolve = this.#acquirers.shift();\n    if (!resolve) {\n      this.#locked = false;\n      return;\n    }\n    resolve();\n  }\n}","map":{"version":3,"names":["assert","Deferred","MAIN_WORLD","PUPPETEER_WORLD","LifecycleWatcher","addPageBinding","createJSHandle","debugError","getPageContent","setPageContent","withSourcePuppeteerURLIfNone","TaskManager","WaitTask","IsolatedWorld","frame","document","context","create","detached","contextBindings","Set","bindings","Map","taskManager","_bindings","constructor","client","on","onBindingCalled","#client","_client","frameManager","#frameManager","_frameManager","timeoutSettings","#timeoutSettings","clearContext","undefined","setContext","clear","resolve","rerunAll","hasContext","resolved","_detach","off","terminateAll","Error","executionContext","url","valueOrThrow","evaluateHandle","pageFunction","args","name","evaluate","$","selector","$$","$x","expression","$eval","$$eval","content","setContent","html","options","waitUntil","timeout","navigationTimeout","watcher","error","race","terminationPromise","lifecyclePromise","dispose","click","handle","focus","hover","select","values","result","tap","type","text","mutex","Mutex","_addBindingToContext","has","acquire","send","_contextName","executionContextName","executionContextId","_contextId","add","message","includes","release","event","payload","JSON","parse","seq","isTrivial","binding","get","run","err","waitForFunction","polling","root","signal","waitTask","title","adoptBackendNode","backendNodeId","object","adoptHandle","nodeInfo","objectId","id","node","transferHandle","info","remoteObject","newHandle","locked","acquirers","Promise","deferred","push","bind","shift"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/IsolatedWorld.ts"],"sourcesContent":["/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Protocol} from 'devtools-protocol';\n\nimport type {ClickOptions, ElementHandle} from '../api/ElementHandle.js';\nimport {Realm} from '../api/Frame.js';\nimport {KeyboardTypeOptions} from '../api/Input.js';\nimport {JSHandle} from '../api/JSHandle.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\n\nimport {Binding} from './Binding.js';\nimport {CDPSession} from './Connection.js';\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {Frame} from './Frame.js';\nimport {FrameManager} from './FrameManager.js';\nimport {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {LifecycleWatcher, PuppeteerLifeCycleEvent} from './LifecycleWatcher.js';\nimport {TimeoutSettings} from './TimeoutSettings.js';\nimport {\n  BindingPayload,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  InnerLazyParams,\n  NodeFor,\n} from './types.js';\nimport {\n  addPageBinding,\n  createJSHandle,\n  debugError,\n  getPageContent,\n  setPageContent,\n  withSourcePuppeteerURLIfNone,\n} from './util.js';\nimport {TaskManager, WaitTask} from './WaitTask.js';\n\n/**\n * @public\n */\nexport interface WaitForSelectorOptions {\n  /**\n   * Wait for the selected element to be present in DOM and to be visible, i.e.\n   * to not have `display: none` or `visibility: hidden` CSS properties.\n   *\n   * @defaultValue `false`\n   */\n  visible?: boolean;\n  /**\n   * Wait for the selected element to not be found in the DOM or to be hidden,\n   * i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *\n   * @defaultValue `false`\n   */\n  hidden?: boolean;\n  /**\n   * Maximum time to wait in milliseconds. Pass `0` to disable timeout.\n   *\n   * The default value can be changed by using {@link Page.setDefaultTimeout}\n   *\n   * @defaultValue `30_000` (30 seconds)\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitForSelector call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @internal\n */\nexport interface PageBinding {\n  name: string;\n  pptrFunction: Function;\n}\n\n/**\n * @internal\n */\nexport interface IsolatedWorldChart {\n  [key: string]: IsolatedWorld;\n  [MAIN_WORLD]: IsolatedWorld;\n  [PUPPETEER_WORLD]: IsolatedWorld;\n}\n\n/**\n * @internal\n */\nexport class IsolatedWorld implements Realm {\n  #frame: Frame;\n  #document?: ElementHandle<Document>;\n  #context = Deferred.create<ExecutionContext>();\n  #detached = false;\n\n  // Set of bindings that have been registered in the current context.\n  #contextBindings = new Set<string>();\n\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map<string, Binding>();\n  #taskManager = new TaskManager();\n\n  get taskManager(): TaskManager {\n    return this.#taskManager;\n  }\n\n  get _bindings(): Map<string, Binding> {\n    return this.#bindings;\n  }\n\n  constructor(frame: Frame) {\n    // Keep own reference to client because it might differ from the FrameManager's\n    // client for OOP iframes.\n    this.#frame = frame;\n    this.#client.on('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n\n  get #client(): CDPSession {\n    return this.#frame._client();\n  }\n\n  get #frameManager(): FrameManager {\n    return this.#frame._frameManager;\n  }\n\n  get #timeoutSettings(): TimeoutSettings {\n    return this.#frameManager.timeoutSettings;\n  }\n\n  frame(): Frame {\n    return this.#frame;\n  }\n\n  clearContext(): void {\n    this.#document = undefined;\n    this.#context = Deferred.create();\n  }\n\n  setContext(context: ExecutionContext): void {\n    this.#contextBindings.clear();\n    this.#context.resolve(context);\n    void this.#taskManager.rerunAll();\n  }\n\n  hasContext(): boolean {\n    return this.#context.resolved();\n  }\n\n  _detach(): void {\n    this.#detached = true;\n    this.#client.off('Runtime.bindingCalled', this.#onBindingCalled);\n    this.#taskManager.terminateAll(\n      new Error('waitForFunction failed: frame got detached.')\n    );\n  }\n\n  executionContext(): Promise<ExecutionContext> {\n    if (this.#detached) {\n      throw new Error(\n        `Execution context is not available in detached frame \"${this.#frame.url()}\" (are you trying to evaluate?)`\n      );\n    }\n    if (this.#context === null) {\n      throw new Error(`Execution content promise is missing`);\n    }\n    return this.#context.valueOrThrow();\n  }\n\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    const context = await this.executionContext();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    const context = await this.executionContext();\n    return context.evaluate(pageFunction, ...args);\n  }\n\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const document = await this.document();\n    return document.$(selector);\n  }\n\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    const document = await this.document();\n    return document.$$(selector);\n  }\n\n  async document(): Promise<ElementHandle<Document>> {\n    if (this.#document) {\n      return this.#document;\n    }\n    const context = await this.executionContext();\n    this.#document = await context.evaluateHandle(() => {\n      return document;\n    });\n    return this.#document;\n  }\n\n  async $x(expression: string): Promise<Array<ElementHandle<Node>>> {\n    const document = await this.document();\n    return document.$x(expression);\n  }\n\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    const document = await this.document();\n    return document.$eval(selector, pageFunction, ...args);\n  }\n\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    const document = await this.document();\n    return document.$$eval(selector, pageFunction, ...args);\n  }\n\n  async content(): Promise<string> {\n    return await this.evaluate(getPageContent);\n  }\n\n  async setContent(\n    html: string,\n    options: {\n      timeout?: number;\n      waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n    } = {}\n  ): Promise<void> {\n    const {\n      waitUntil = ['load'],\n      timeout = this.#timeoutSettings.navigationTimeout(),\n    } = options;\n\n    await setPageContent(this, html);\n\n    const watcher = new LifecycleWatcher(\n      this.#frameManager,\n      this.#frame,\n      waitUntil,\n      timeout\n    );\n    const error = await Deferred.race<void | Error | undefined>([\n      watcher.terminationPromise(),\n      watcher.lifecyclePromise(),\n    ]);\n    watcher.dispose();\n    if (error) {\n      throw error;\n    }\n  }\n\n  async click(\n    selector: string,\n    options?: Readonly<ClickOptions>\n  ): Promise<void> {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.click(options);\n    await handle.dispose();\n  }\n\n  async focus(selector: string): Promise<void> {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.focus();\n    await handle.dispose();\n  }\n\n  async hover(selector: string): Promise<void> {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.hover();\n    await handle.dispose();\n  }\n\n  async select(selector: string, ...values: string[]): Promise<string[]> {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    const result = await handle.select(...values);\n    await handle.dispose();\n    return result;\n  }\n\n  async tap(selector: string): Promise<void> {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.tap();\n    await handle.dispose();\n  }\n\n  async type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    const handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.type(text, options);\n    await handle.dispose();\n  }\n\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async _addBindingToContext(\n    context: ExecutionContext,\n    name: string\n  ): Promise<void> {\n    if (this.#contextBindings.has(name)) {\n      return;\n    }\n\n    await this.#mutex.acquire();\n    try {\n      await context._client.send(\n        'Runtime.addBinding',\n        context._contextName\n          ? {\n              name,\n              executionContextName: context._contextName,\n            }\n          : {\n              name,\n              executionContextId: context._contextId,\n            }\n      );\n\n      await context.evaluate(addPageBinding, 'internal', name);\n\n      this.#contextBindings.add(name);\n    } catch (error) {\n      // We could have tried to evaluate in a context which was already\n      // destroyed. This happens, for example, if the page is navigated while\n      // we are trying to add the binding\n      if (error instanceof Error) {\n        // Destroyed context.\n        if (error.message.includes('Execution context was destroyed')) {\n          return;\n        }\n        // Missing context.\n        if (error.message.includes('Cannot find context with specified id')) {\n          return;\n        }\n      }\n\n      debugError(error);\n    } finally {\n      this.#mutex.release();\n    }\n  }\n\n  #onBindingCalled = async (\n    event: Protocol.Runtime.BindingCalledEvent\n  ): Promise<void> => {\n    let payload: BindingPayload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {type, name, seq, args, isTrivial} = payload;\n    if (type !== 'internal') {\n      return;\n    }\n    if (!this.#contextBindings.has(name)) {\n      return;\n    }\n\n    try {\n      const context = await this.#context.valueOrThrow();\n      if (event.executionContextId !== context._contextId) {\n        return;\n      }\n\n      const binding = this._bindings.get(name);\n      await binding?.run(context, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  };\n\n  waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<InnerLazyParams<Params>> = EvaluateFunc<\n      InnerLazyParams<Params>\n    >,\n  >(\n    pageFunction: Func | string,\n    options: {\n      polling?: 'raf' | 'mutation' | number;\n      timeout?: number;\n      root?: ElementHandle<Node>;\n      signal?: AbortSignal;\n    } = {},\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    const {\n      polling = 'raf',\n      timeout = this.#timeoutSettings.timeout(),\n      root,\n      signal,\n    } = options;\n    if (typeof polling === 'number' && polling < 0) {\n      throw new Error('Cannot poll with non-positive interval');\n    }\n    const waitTask = new WaitTask(\n      this,\n      {\n        polling,\n        root,\n        timeout,\n        signal,\n      },\n      pageFunction as unknown as\n        | ((...args: unknown[]) => Promise<Awaited<ReturnType<Func>>>)\n        | string,\n      ...args\n    );\n    return waitTask.result;\n  }\n\n  async title(): Promise<string> {\n    return this.evaluate(() => {\n      return document.title;\n    });\n  }\n\n  async adoptBackendNode(\n    backendNodeId?: Protocol.DOM.BackendNodeId\n  ): Promise<JSHandle<Node>> {\n    const executionContext = await this.executionContext();\n    const {object} = await this.#client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: executionContext._contextId,\n    });\n    return createJSHandle(executionContext, object) as JSHandle<Node>;\n  }\n\n  async adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    const context = await this.executionContext();\n    assert(\n      handle.executionContext() !== context,\n      'Cannot adopt handle that already belongs to this execution context'\n    );\n    const nodeInfo = await this.#client.send('DOM.describeNode', {\n      objectId: handle.id,\n    });\n    return (await this.adoptBackendNode(nodeInfo.node.backendNodeId)) as T;\n  }\n\n  async transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    const context = await this.executionContext();\n    if (handle.executionContext() === context) {\n      return handle;\n    }\n    const info = await this.#client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId,\n    });\n    const newHandle = (await this.adoptBackendNode(\n      info.node.backendNodeId\n    )) as T;\n    await handle.dispose();\n    return newHandle;\n  }\n}\n\nclass Mutex {\n  #locked = false;\n  #acquirers: Array<() => void> = [];\n\n  // This is FIFO.\n  acquire(): Promise<void> {\n    if (!this.#locked) {\n      this.#locked = true;\n      return Promise.resolve();\n    }\n    const deferred = Deferred.create<void>();\n    this.#acquirers.push(deferred.resolve.bind(deferred));\n    return deferred.valueOrThrow();\n  }\n\n  release(): void {\n    const resolve = this.#acquirers.shift();\n    if (!resolve) {\n      this.#locked = false;\n      return;\n    }\n    resolve();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}