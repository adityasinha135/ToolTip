{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getQueryHandlerAndSelector } from '../common/GetQueryHandler.js';\nimport { LazyArg } from '../common/LazyArg.js';\nimport { importFSPromises } from '../common/util.js';\nimport { FunctionLocator, NodeLocator } from './locators/locators.js';\n/**\n * Represents a DOM frame.\n *\n * To understand frames, you can think of frames as `<iframe>` elements. Just\n * like iframes, frames can be nested, and when JavaScript is executed in a\n * frame, the JavaScript does not effect frames inside the ambient frame the\n * JavaScript executes in.\n *\n * @example\n * At any point in time, {@link Page | pages} expose their current frame\n * tree via the {@link Page.mainFrame} and {@link Frame.childFrames} methods.\n *\n * @example\n * An example of dumping frame tree:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *       dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @example\n * An example of getting text from an iframe element:\n *\n * ```ts\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @remarks\n * Frame lifecycles are controlled by three events that are all dispatched on\n * the parent {@link Frame.page | page}:\n *\n * - {@link PageEmittedEvents.FrameAttached}\n * - {@link PageEmittedEvents.FrameNavigated}\n * - {@link PageEmittedEvents.FrameDetached}\n *\n * @public\n */\nexport class Frame {\n  /**\n   * @internal\n   */\n  _id;\n  /**\n   * @internal\n   */\n  _parentId;\n  /**\n   * @internal\n   */\n  worlds;\n  /**\n   * @internal\n   */\n  _name;\n  /**\n   * @internal\n   */\n  _hasStartedLoading = false;\n  /**\n   * @internal\n   */\n  constructor() {}\n  /**\n   * The page associated with the frame.\n   */\n  page() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Is `true` if the frame is an out-of-process (OOP) frame. Otherwise,\n   * `false`.\n   */\n  isOOPFrame() {\n    throw new Error('Not implemented');\n  }\n  async goto() {\n    throw new Error('Not implemented');\n  }\n  async waitForNavigation() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  _client() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  executionContext() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  mainRealm() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  isolatedRealm() {\n    throw new Error('Not implemented');\n  }\n  async evaluateHandle() {\n    throw new Error('Not implemented');\n  }\n  async evaluate() {\n    throw new Error('Not implemented');\n  }\n  locator(selectorOrFunc) {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n  async $() {\n    throw new Error('Not implemented');\n  }\n  async $$() {\n    throw new Error('Not implemented');\n  }\n  async $eval() {\n    throw new Error('Not implemented');\n  }\n  async $$eval() {\n    throw new Error('Not implemented');\n  }\n  async $x() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Waits for an element matching the given selector to appear in the frame.\n   *\n   * This method works across navigations.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  async waitForSelector(selector, options = {}) {\n    const {\n      updatedSelector,\n      QueryHandler\n    } = getQueryHandlerAndSelector(selector);\n    return await QueryHandler.waitFor(this, updatedSelector, options);\n  }\n  /**\n   * @deprecated Use {@link Frame.waitForSelector} with the `xpath` prefix.\n   *\n   * Example: `await frame.waitForSelector('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the Frame.\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * For a code example, see the example for {@link Frame.waitForSelector}. That\n   * function behaves identically other than taking a CSS selector rather than\n   * an XPath.\n   *\n   * @param xpath - the XPath expression to wait for.\n   * @param options - options to configure the visibility of the element and how\n   * long to wait before timing out.\n   */\n  async waitForXPath(xpath, options = {}) {\n    if (xpath.startsWith('//')) {\n      xpath = `.${xpath}`;\n    }\n    return this.waitForSelector(`xpath/${xpath}`, options);\n  }\n  /**\n   * @example\n   * The `waitForFunction` can be used to observe viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   * .  const browser = await puppeteer.launch();\n   * .  const page = await browser.newPage();\n   * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n   * .  page.setViewport({width: 50, height: 50});\n   * .  await watchDog;\n   * .  await browser.close();\n   * })();\n   * ```\n   *\n   * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await frame.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {}, // empty options object\n   *   selector\n   * );\n   * ```\n   *\n   * @param pageFunction - the function to evaluate in the frame context.\n   * @param options - options to configure the polling method and timeout.\n   * @param args - arguments to pass to the `pageFunction`.\n   * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n   */\n  waitForFunction(pageFunction, options = {}, ...args) {\n    return this.mainRealm().waitForFunction(pageFunction, options, ...args);\n  }\n  /**\n   * The full HTML contents of the frame, including the DOCTYPE.\n   */\n  async content() {\n    throw new Error('Not implemented');\n  }\n  async setContent() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * The frame's `name` attribute as specified in the tag.\n   *\n   * @remarks\n   * If the name is empty, it returns the `id` attribute instead.\n   *\n   * @remarks\n   * This value is calculated once when the frame is created, and will not\n   * update if the attribute is changed later.\n   */\n  name() {\n    return this._name || '';\n  }\n  /**\n   * The frame's URL.\n   */\n  url() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * The parent frame, if any. Detached and main frames return `null`.\n   */\n  parentFrame() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * An array of child frames.\n   */\n  childFrames() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Is`true` if the frame has been detached. Otherwise, `false`.\n   */\n  isDetached() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Adds a `<script>` tag into the page with the desired url or content.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  async addScriptTag(options) {\n    let {\n      content = '',\n      type\n    } = options;\n    const {\n      path\n    } = options;\n    if (+!!options.url + +!!path + +!!content !== 1) {\n      throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');\n    }\n    if (path) {\n      const fs = await importFSPromises();\n      content = await fs.readFile(path, 'utf8');\n      content += `//# sourceURL=${path.replace(/\\n/g, '')}`;\n    }\n    type = type ?? 'text/javascript';\n    return this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({\n      Deferred\n    }, {\n      url,\n      id,\n      type,\n      content\n    }) => {\n      const deferred = Deferred.create();\n      const script = document.createElement('script');\n      script.type = type;\n      script.text = content;\n      if (url) {\n        script.src = url;\n        script.addEventListener('load', () => {\n          return deferred.resolve();\n        }, {\n          once: true\n        });\n        script.addEventListener('error', event => {\n          deferred.reject(new Error(event.message ?? 'Could not load script'));\n        }, {\n          once: true\n        });\n      } else {\n        deferred.resolve();\n      }\n      if (id) {\n        script.id = id;\n      }\n      document.head.appendChild(script);\n      await deferred.valueOrThrow();\n      return script;\n    }, LazyArg.create(context => {\n      return context.puppeteerUtil;\n    }), {\n      ...options,\n      type,\n      content\n    }));\n  }\n  async addStyleTag(options) {\n    let {\n      content = ''\n    } = options;\n    const {\n      path\n    } = options;\n    if (+!!options.url + +!!path + +!!content !== 1) {\n      throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');\n    }\n    if (path) {\n      const fs = await importFSPromises();\n      content = await fs.readFile(path, 'utf8');\n      content += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n      options.content = content;\n    }\n    return this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({\n      Deferred\n    }, {\n      url,\n      content\n    }) => {\n      const deferred = Deferred.create();\n      let element;\n      if (!url) {\n        element = document.createElement('style');\n        element.appendChild(document.createTextNode(content));\n      } else {\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = url;\n        element = link;\n      }\n      element.addEventListener('load', () => {\n        deferred.resolve();\n      }, {\n        once: true\n      });\n      element.addEventListener('error', event => {\n        deferred.reject(new Error(event.message ?? 'Could not load style'));\n      }, {\n        once: true\n      });\n      document.head.appendChild(element);\n      await deferred.valueOrThrow();\n      return element;\n    }, LazyArg.create(context => {\n      return context.puppeteerUtil;\n    }), options));\n  }\n  /**\n   * Clicks the first element found that matches `selector`.\n   *\n   * @remarks\n   * If `click()` triggers a navigation event and there's a separate\n   * `page.waitForNavigation()` promise to be resolved, you may end up with a\n   * race condition that yields unexpected results. The correct pattern for\n   * click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   frame.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   */\n  click(selector, options = {}) {\n    return this.isolatedRealm().click(selector, options);\n  }\n  /**\n   * Focuses the first element that matches the `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  async focus(selector) {\n    return this.isolatedRealm().focus(selector);\n  }\n  /**\n   * Hovers the pointer over the center of the first element that matches the\n   * `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  hover(selector) {\n    return this.isolatedRealm().hover(selector);\n  }\n  /**\n   * Selects a set of value on the first `<select>` element that matches the\n   * `selector`.\n   *\n   * @example\n   *\n   * ```ts\n   * frame.select('select#colors', 'blue'); // single selection\n   * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param values - The array of values to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   * @returns the list of values that were successfully selected.\n   * @throws Throws if there's no `<select>` matching `selector`.\n   */\n  select(selector, ...values) {\n    return this.isolatedRealm().select(selector, ...values);\n  }\n  /**\n   * Taps the first element that matches the `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  tap(selector) {\n    return this.isolatedRealm().tap(selector);\n  }\n  /**\n   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n   * in the text.\n   *\n   * @remarks\n   * To press a special key, like `Control` or `ArrowDown`, use\n   * {@link Keyboard.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await frame.type('#mytextarea', 'Hello'); // Types instantly\n   * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @param selector - the selector for the element to type into. If there are\n   * multiple the first will be used.\n   * @param text - text to type into the element\n   * @param options - takes one option, `delay`, which sets the time to wait\n   * between key presses in milliseconds. Defaults to `0`.\n   */\n  type(selector, text, options) {\n    return this.isolatedRealm().type(selector, text, options);\n  }\n  /**\n   * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.\n   *\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```ts\n   * await frame.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n  waitForTimeout(milliseconds) {\n    return new Promise(resolve => {\n      setTimeout(resolve, milliseconds);\n    });\n  }\n  /**\n   * The frame's title.\n   */\n  async title() {\n    throw new Error('Not implemented');\n  }\n  waitForDevicePrompt() {\n    throw new Error('Not implemented');\n  }\n}","map":{"version":3,"names":["getQueryHandlerAndSelector","LazyArg","importFSPromises","FunctionLocator","NodeLocator","Frame","_id","_parentId","worlds","_name","_hasStartedLoading","constructor","page","Error","isOOPFrame","goto","waitForNavigation","_client","executionContext","mainRealm","isolatedRealm","evaluateHandle","evaluate","locator","selectorOrFunc","create","$","$$","$eval","$$eval","$x","waitForSelector","selector","options","updatedSelector","QueryHandler","waitFor","waitForXPath","xpath","startsWith","waitForFunction","pageFunction","args","content","setContent","name","url","parentFrame","childFrames","isDetached","addScriptTag","type","path","fs","readFile","replace","transferHandle","Deferred","id","deferred","script","document","createElement","text","src","addEventListener","resolve","once","event","reject","message","head","appendChild","valueOrThrow","context","puppeteerUtil","addStyleTag","element","createTextNode","link","rel","href","click","focus","hover","select","values","tap","waitForTimeout","milliseconds","Promise","setTimeout","title","waitForDevicePrompt"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/api/Frame.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ClickOptions, ElementHandle} from '../api/ElementHandle.js';\nimport {HTTPResponse} from '../api/HTTPResponse.js';\nimport {Page, WaitTimeoutOptions} from '../api/Page.js';\nimport {CDPSession} from '../common/Connection.js';\nimport {DeviceRequestPrompt} from '../common/DeviceRequestPrompt.js';\nimport {ExecutionContext} from '../common/ExecutionContext.js';\nimport {getQueryHandlerAndSelector} from '../common/GetQueryHandler.js';\nimport {\n  IsolatedWorldChart,\n  WaitForSelectorOptions,\n} from '../common/IsolatedWorld.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport {PuppeteerLifeCycleEvent} from '../common/LifecycleWatcher.js';\nimport {\n  Awaitable,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  InnerLazyParams,\n  NodeFor,\n} from '../common/types.js';\nimport {importFSPromises} from '../common/util.js';\nimport {TaskManager} from '../common/WaitTask.js';\n\nimport {KeyboardTypeOptions} from './Input.js';\nimport {JSHandle} from './JSHandle.js';\nimport {Locator, FunctionLocator, NodeLocator} from './locators/locators.js';\n\n/**\n * @internal\n */\nexport interface Realm {\n  taskManager: TaskManager;\n  waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<InnerLazyParams<Params>> = EvaluateFunc<\n      InnerLazyParams<Params>\n    >,\n  >(\n    pageFunction: Func | string,\n    options: {\n      polling?: 'raf' | 'mutation' | number;\n      timeout?: number;\n      root?: ElementHandle<Node>;\n      signal?: AbortSignal;\n    },\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T>;\n  transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T>;\n  evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n  click(selector: string, options: Readonly<ClickOptions>): Promise<void>;\n  focus(selector: string): Promise<void>;\n  hover(selector: string): Promise<void>;\n  select(selector: string, ...values: string[]): Promise<string[]>;\n  tap(selector: string): Promise<void>;\n  type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void>;\n}\n\n/**\n * @public\n */\nexport interface FrameWaitForFunctionOptions {\n  /**\n   * An interval at which the `pageFunction` is executed, defaults to `raf`. If\n   * `polling` is a number, then it is treated as an interval in milliseconds at\n   * which the function would be executed. If `polling` is a string, then it can\n   * be one of the following values:\n   *\n   * - `raf` - to constantly execute `pageFunction` in `requestAnimationFrame`\n   *   callback. This is the tightest polling mode which is suitable to observe\n   *   styling changes.\n   *\n   * - `mutation` - to execute `pageFunction` on every DOM mutation.\n   */\n  polling?: 'raf' | 'mutation' | number;\n  /**\n   * Maximum time to wait in milliseconds. Defaults to `30000` (30 seconds).\n   * Pass `0` to disable the timeout. Puppeteer's default timeout can be changed\n   * using {@link Page.setDefaultTimeout}.\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitForFunction call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface FrameAddScriptTagOptions {\n  /**\n   * URL of the script to be added.\n   */\n  url?: string;\n  /**\n   * Path to a JavaScript file to be injected into the frame.\n   *\n   * @remarks\n   * If `path` is a relative path, it is resolved relative to the current\n   * working directory (`process.cwd()` in Node.js).\n   */\n  path?: string;\n  /**\n   * JavaScript to be injected into the frame.\n   */\n  content?: string;\n  /**\n   * Sets the `type` of the script. Use `module` in order to load an ES2015 module.\n   */\n  type?: string;\n  /**\n   * Sets the `id` of the script.\n   */\n  id?: string;\n}\n\n/**\n * @public\n */\nexport interface FrameAddStyleTagOptions {\n  /**\n   * the URL of the CSS file to be added.\n   */\n  url?: string;\n  /**\n   * The path to a CSS file to be injected into the frame.\n   * @remarks\n   * If `path` is a relative path, it is resolved relative to the current\n   * working directory (`process.cwd()` in Node.js).\n   */\n  path?: string;\n  /**\n   * Raw CSS content to be injected into the frame.\n   */\n  content?: string;\n}\n\n/**\n * Represents a DOM frame.\n *\n * To understand frames, you can think of frames as `<iframe>` elements. Just\n * like iframes, frames can be nested, and when JavaScript is executed in a\n * frame, the JavaScript does not effect frames inside the ambient frame the\n * JavaScript executes in.\n *\n * @example\n * At any point in time, {@link Page | pages} expose their current frame\n * tree via the {@link Page.mainFrame} and {@link Frame.childFrames} methods.\n *\n * @example\n * An example of dumping frame tree:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *       dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @example\n * An example of getting text from an iframe element:\n *\n * ```ts\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @remarks\n * Frame lifecycles are controlled by three events that are all dispatched on\n * the parent {@link Frame.page | page}:\n *\n * - {@link PageEmittedEvents.FrameAttached}\n * - {@link PageEmittedEvents.FrameNavigated}\n * - {@link PageEmittedEvents.FrameDetached}\n *\n * @public\n */\nexport class Frame {\n  /**\n   * @internal\n   */\n  _id!: string;\n  /**\n   * @internal\n   */\n  _parentId?: string;\n\n  /**\n   * @internal\n   */\n  worlds!: IsolatedWorldChart;\n\n  /**\n   * @internal\n   */\n  _name?: string;\n\n  /**\n   * @internal\n   */\n  _hasStartedLoading = false;\n\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * The page associated with the frame.\n   */\n  page(): Page {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Is `true` if the frame is an out-of-process (OOP) frame. Otherwise,\n   * `false`.\n   */\n  isOOPFrame(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Navigates a frame to the given url.\n   *\n   * @remarks\n   * Navigation to `about:blank` or navigation to the same URL with a different\n   * hash will succeed and return `null`.\n   *\n   * :::warning\n   *\n   * Headless mode doesn't support navigation to a PDF document. See the {@link\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n   * issue}.\n   *\n   * :::\n   *\n   * @param url - the URL to navigate the frame to. This should include the\n   * scheme, e.g. `https://`.\n   * @param options - navigation options. `waitUntil` is useful to define when\n   * the navigation should be considered successful - see the docs for\n   * {@link PuppeteerLifeCycleEvent} for more details.\n   *\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   * @throws This method will throw an error if:\n   *\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   * - target URL is invalid.\n   * - the `timeout` is exceeded during navigation.\n   * - the remote server does not respond or is unreachable.\n   * - the main resource failed to load.\n   *\n   * This method will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n   * Server Error\". The status code for such responses can be retrieved by\n   * calling {@link HTTPResponse.status}.\n   */\n  async goto(\n    url: string,\n    options?: {\n      referer?: string;\n      referrerPolicy?: string;\n      timeout?: number;\n      waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n    }\n  ): Promise<HTTPResponse | null>;\n  async goto(): Promise<HTTPResponse | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Waits for the frame to navigate. It is useful for when you run code which\n   * will indirectly cause the frame to navigate.\n   *\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   // The navigation promise resolves after navigation has finished\n   *   frame.waitForNavigation(),\n   *   // Clicking the link will indirectly cause a navigation\n   *   frame.click('a.my-link'),\n   * ]);\n   * ```\n   *\n   * @param options - options to configure when the navigation is consided\n   * finished.\n   * @returns a promise that resolves when the frame navigates to a new URL.\n   */\n  async waitForNavigation(options?: {\n    timeout?: number;\n    waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n  }): Promise<HTTPResponse | null>;\n  async waitForNavigation(): Promise<HTTPResponse | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  _client(): CDPSession {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  executionContext(): Promise<ExecutionContext> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  mainRealm(): Realm {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  isolatedRealm(): Realm {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Behaves identically to {@link Page.evaluateHandle} except it's run within\n   * the context of this frame.\n   *\n   * @see {@link Page.evaluateHandle} for details.\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Behaves identically to {@link Page.evaluate} except it's run within the\n   * the context of this frame.\n   *\n   * @see {@link Page.evaluate} for details.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(): Promise<Awaited<ReturnType<Func>>> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Creates a locator for the provided selector. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Selector extends string>(\n    selector: Selector\n  ): Locator<NodeFor<Selector>>;\n\n  /**\n   * Creates a locator for the provided function. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Ret>(func: () => Awaitable<Ret>): Locator<Ret>;\n  locator<Selector extends string, Ret>(\n    selectorOrFunc: Selector | (() => Awaitable<Ret>)\n  ): Locator<NodeFor<Selector>> | Locator<Ret> {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n  /**\n   * Queries the frame for an element matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null>;\n  async $<Selector extends string>(): Promise<ElementHandle<\n    NodeFor<Selector>\n  > | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Queries the frame for all elements matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>>;\n  async $$<Selector extends string>(): Promise<\n    Array<ElementHandle<NodeFor<Selector>>>\n  > {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the frame.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await frame.$eval('#search', el => el.value);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in the frame's context.\n   * The first element matching the selector will be passed to the function as\n   * its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(): Promise<Awaited<ReturnType<Func>>> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the frame.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```js\n   * const divsCounts = await frame.$$eval('div', divs => divs.length);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in the frame's context.\n   * An array of elements matching the given selector will be passed to the\n   * function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(): Promise<Awaited<ReturnType<Func>>> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @deprecated Use {@link Frame.$$} with the `xpath` prefix.\n   *\n   * Example: `await frame.$$('xpath/' + xpathExpression)`\n   *\n   * This method evaluates the given XPath expression and returns the results.\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   * @param expression - the XPath expression to evaluate.\n   */\n  async $x(expression: string): Promise<Array<ElementHandle<Node>>>;\n  async $x(): Promise<Array<ElementHandle<Node>>> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Waits for an element matching the given selector to appear in the frame.\n   *\n   * This method works across navigations.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.waitFor(\n      this,\n      updatedSelector,\n      options\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  /**\n   * @deprecated Use {@link Frame.waitForSelector} with the `xpath` prefix.\n   *\n   * Example: `await frame.waitForSelector('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the Frame.\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * For a code example, see the example for {@link Frame.waitForSelector}. That\n   * function behaves identically other than taking a CSS selector rather than\n   * an XPath.\n   *\n   * @param xpath - the XPath expression to wait for.\n   * @param options - options to configure the visibility of the element and how\n   * long to wait before timing out.\n   */\n  async waitForXPath(\n    xpath: string,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<Node> | null> {\n    if (xpath.startsWith('//')) {\n      xpath = `.${xpath}`;\n    }\n    return this.waitForSelector(`xpath/${xpath}`, options);\n  }\n\n  /**\n   * @example\n   * The `waitForFunction` can be used to observe viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   * .  const browser = await puppeteer.launch();\n   * .  const page = await browser.newPage();\n   * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n   * .  page.setViewport({width: 50, height: 50});\n   * .  await watchDog;\n   * .  await browser.close();\n   * })();\n   * ```\n   *\n   * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await frame.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {}, // empty options object\n   *   selector\n   * );\n   * ```\n   *\n   * @param pageFunction - the function to evaluate in the frame context.\n   * @param options - options to configure the polling method and timeout.\n   * @param args - arguments to pass to the `pageFunction`.\n   * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n   */\n  waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    options: FrameWaitForFunctionOptions = {},\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return this.mainRealm().waitForFunction(\n      pageFunction,\n      options,\n      ...args\n    ) as Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  }\n  /**\n   * The full HTML contents of the frame, including the DOCTYPE.\n   */\n  async content(): Promise<string> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Set the content of the frame.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - Options to configure how long before timing out and at\n   * what point to consider the content setting successful.\n   */\n  async setContent(\n    html: string,\n    options?: {\n      timeout?: number;\n      waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n    }\n  ): Promise<void>;\n  async setContent(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The frame's `name` attribute as specified in the tag.\n   *\n   * @remarks\n   * If the name is empty, it returns the `id` attribute instead.\n   *\n   * @remarks\n   * This value is calculated once when the frame is created, and will not\n   * update if the attribute is changed later.\n   */\n  name(): string {\n    return this._name || '';\n  }\n\n  /**\n   * The frame's URL.\n   */\n  url(): string {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The parent frame, if any. Detached and main frames return `null`.\n   */\n  parentFrame(): Frame | null {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * An array of child frames.\n   */\n  childFrames(): Frame[] {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Is`true` if the frame has been detached. Otherwise, `false`.\n   */\n  isDetached(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Adds a `<script>` tag into the page with the desired url or content.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  async addScriptTag(\n    options: FrameAddScriptTagOptions\n  ): Promise<ElementHandle<HTMLScriptElement>> {\n    let {content = '', type} = options;\n    const {path} = options;\n    if (+!!options.url + +!!path + +!!content !== 1) {\n      throw new Error(\n        'Exactly one of `url`, `path`, or `content` must be specified.'\n      );\n    }\n\n    if (path) {\n      const fs = await importFSPromises();\n      content = await fs.readFile(path, 'utf8');\n      content += `//# sourceURL=${path.replace(/\\n/g, '')}`;\n    }\n\n    type = type ?? 'text/javascript';\n\n    return this.mainRealm().transferHandle(\n      await this.isolatedRealm().evaluateHandle(\n        async ({Deferred}, {url, id, type, content}) => {\n          const deferred = Deferred.create<void>();\n          const script = document.createElement('script');\n          script.type = type;\n          script.text = content;\n          if (url) {\n            script.src = url;\n            script.addEventListener(\n              'load',\n              () => {\n                return deferred.resolve();\n              },\n              {once: true}\n            );\n            script.addEventListener(\n              'error',\n              event => {\n                deferred.reject(\n                  new Error(event.message ?? 'Could not load script')\n                );\n              },\n              {once: true}\n            );\n          } else {\n            deferred.resolve();\n          }\n          if (id) {\n            script.id = id;\n          }\n          document.head.appendChild(script);\n          await deferred.valueOrThrow();\n          return script;\n        },\n        LazyArg.create(context => {\n          return context.puppeteerUtil;\n        }),\n        {...options, type, content}\n      )\n    );\n  }\n\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired URL or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * @returns An {@link ElementHandle | element handle} to the loaded `<link>`\n   * or `<style>` element.\n   */\n  async addStyleTag(\n    options: Omit<FrameAddStyleTagOptions, 'url'>\n  ): Promise<ElementHandle<HTMLStyleElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLLinkElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLStyleElement | HTMLLinkElement>> {\n    let {content = ''} = options;\n    const {path} = options;\n    if (+!!options.url + +!!path + +!!content !== 1) {\n      throw new Error(\n        'Exactly one of `url`, `path`, or `content` must be specified.'\n      );\n    }\n\n    if (path) {\n      const fs = await importFSPromises();\n\n      content = await fs.readFile(path, 'utf8');\n      content += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n      options.content = content;\n    }\n\n    return this.mainRealm().transferHandle(\n      await this.isolatedRealm().evaluateHandle(\n        async ({Deferred}, {url, content}) => {\n          const deferred = Deferred.create<void>();\n          let element: HTMLStyleElement | HTMLLinkElement;\n          if (!url) {\n            element = document.createElement('style');\n            element.appendChild(document.createTextNode(content!));\n          } else {\n            const link = document.createElement('link');\n            link.rel = 'stylesheet';\n            link.href = url;\n            element = link;\n          }\n          element.addEventListener(\n            'load',\n            () => {\n              deferred.resolve();\n            },\n            {once: true}\n          );\n          element.addEventListener(\n            'error',\n            event => {\n              deferred.reject(\n                new Error(\n                  (event as ErrorEvent).message ?? 'Could not load style'\n                )\n              );\n            },\n            {once: true}\n          );\n          document.head.appendChild(element);\n          await deferred.valueOrThrow();\n          return element;\n        },\n        LazyArg.create(context => {\n          return context.puppeteerUtil;\n        }),\n        options\n      )\n    );\n  }\n\n  /**\n   * Clicks the first element found that matches `selector`.\n   *\n   * @remarks\n   * If `click()` triggers a navigation event and there's a separate\n   * `page.waitForNavigation()` promise to be resolved, you may end up with a\n   * race condition that yields unexpected results. The correct pattern for\n   * click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   frame.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   */\n  click(selector: string, options: Readonly<ClickOptions> = {}): Promise<void> {\n    return this.isolatedRealm().click(selector, options);\n  }\n\n  /**\n   * Focuses the first element that matches the `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  async focus(selector: string): Promise<void> {\n    return this.isolatedRealm().focus(selector);\n  }\n\n  /**\n   * Hovers the pointer over the center of the first element that matches the\n   * `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  hover(selector: string): Promise<void> {\n    return this.isolatedRealm().hover(selector);\n  }\n\n  /**\n   * Selects a set of value on the first `<select>` element that matches the\n   * `selector`.\n   *\n   * @example\n   *\n   * ```ts\n   * frame.select('select#colors', 'blue'); // single selection\n   * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param values - The array of values to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   * @returns the list of values that were successfully selected.\n   * @throws Throws if there's no `<select>` matching `selector`.\n   */\n  select(selector: string, ...values: string[]): Promise<string[]> {\n    return this.isolatedRealm().select(selector, ...values);\n  }\n\n  /**\n   * Taps the first element that matches the `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  tap(selector: string): Promise<void> {\n    return this.isolatedRealm().tap(selector);\n  }\n\n  /**\n   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n   * in the text.\n   *\n   * @remarks\n   * To press a special key, like `Control` or `ArrowDown`, use\n   * {@link Keyboard.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await frame.type('#mytextarea', 'Hello'); // Types instantly\n   * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @param selector - the selector for the element to type into. If there are\n   * multiple the first will be used.\n   * @param text - text to type into the element\n   * @param options - takes one option, `delay`, which sets the time to wait\n   * between key presses in milliseconds. Defaults to `0`.\n   */\n  type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    return this.isolatedRealm().type(selector, text, options);\n  }\n\n  /**\n   * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.\n   *\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```ts\n   * await frame.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n  waitForTimeout(milliseconds: number): Promise<void> {\n    return new Promise(resolve => {\n      setTimeout(resolve, milliseconds);\n    });\n  }\n\n  /**\n   * The frame's title.\n   */\n  async title(): Promise<string> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   frame.waitForDevicePrompt(),\n   *   frame.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  waitForDevicePrompt(\n    options?: WaitTimeoutOptions\n  ): Promise<DeviceRequestPrompt>;\n  waitForDevicePrompt(): Promise<DeviceRequestPrompt> {\n    throw new Error('Not implemented');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}