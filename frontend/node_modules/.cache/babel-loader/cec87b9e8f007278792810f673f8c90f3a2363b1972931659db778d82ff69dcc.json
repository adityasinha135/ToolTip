{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert.js';\nimport { createDebuggableDeferred } from '../util/DebuggableDeferred.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { HTTPRequest } from './HTTPRequest.js';\nimport { HTTPResponse } from './HTTPResponse.js';\nimport { NetworkEventManager } from './NetworkEventManager.js';\nimport { debugError, isString } from './util.js';\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished')\n};\n/**\n * @internal\n */\nexport class NetworkManager extends EventEmitter {\n  #client;\n  #ignoreHTTPSErrors;\n  #frameManager;\n  #networkEventManager = new NetworkEventManager();\n  #extraHTTPHeaders = {};\n  #credentials;\n  #attemptedAuthentications = new Set();\n  #userRequestInterceptionEnabled = false;\n  #protocolRequestInterceptionEnabled = false;\n  #userCacheDisabled = false;\n  #emulatedNetworkConditions = {\n    offline: false,\n    upload: -1,\n    download: -1,\n    latency: 0\n  };\n  #deferredInit;\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    this.#client = client;\n    this.#ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this.#frameManager = frameManager;\n    this.#client.on('Fetch.requestPaused', this.#onRequestPaused.bind(this));\n    this.#client.on('Fetch.authRequired', this.#onAuthRequired.bind(this));\n    this.#client.on('Network.requestWillBeSent', this.#onRequestWillBeSent.bind(this));\n    this.#client.on('Network.requestServedFromCache', this.#onRequestServedFromCache.bind(this));\n    this.#client.on('Network.responseReceived', this.#onResponseReceived.bind(this));\n    this.#client.on('Network.loadingFinished', this.#onLoadingFinished.bind(this));\n    this.#client.on('Network.loadingFailed', this.#onLoadingFailed.bind(this));\n    this.#client.on('Network.responseReceivedExtraInfo', this.#onResponseReceivedExtraInfo.bind(this));\n  }\n  /**\n   * Initialize calls should avoid async dependencies between CDP calls as those\n   * might not resolve until after the target is resumed causing a deadlock.\n   */\n  initialize() {\n    if (this.#deferredInit) {\n      return this.#deferredInit.valueOrThrow();\n    }\n    this.#deferredInit = createDebuggableDeferred('NetworkManager initialization timed out');\n    const init = Promise.all([this.#ignoreHTTPSErrors ? this.#client.send('Security.setIgnoreCertificateErrors', {\n      ignore: true\n    }) : null, this.#client.send('Network.enable')]);\n    const deferredInitPromise = this.#deferredInit;\n    init.then(() => {\n      deferredInitPromise.resolve();\n    }).catch(err => {\n      deferredInitPromise.reject(err);\n    });\n    return this.#deferredInit.valueOrThrow();\n  }\n  async authenticate(credentials) {\n    this.#credentials = credentials;\n    await this.#updateProtocolRequestInterception();\n  }\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this.#extraHTTPHeaders = {};\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert(isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this.#extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n    await this.#client.send('Network.setExtraHTTPHeaders', {\n      headers: this.#extraHTTPHeaders\n    });\n  }\n  extraHTTPHeaders() {\n    return Object.assign({}, this.#extraHTTPHeaders);\n  }\n  inFlightRequestsCount() {\n    return this.#networkEventManager.inFlightRequestsCount();\n  }\n  async setOfflineMode(value) {\n    this.#emulatedNetworkConditions.offline = value;\n    await this.#updateNetworkConditions();\n  }\n  async emulateNetworkConditions(networkConditions) {\n    this.#emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;\n    this.#emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;\n    this.#emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;\n    await this.#updateNetworkConditions();\n  }\n  async #updateNetworkConditions() {\n    await this.#client.send('Network.emulateNetworkConditions', {\n      offline: this.#emulatedNetworkConditions.offline,\n      latency: this.#emulatedNetworkConditions.latency,\n      uploadThroughput: this.#emulatedNetworkConditions.upload,\n      downloadThroughput: this.#emulatedNetworkConditions.download\n    });\n  }\n  async setUserAgent(userAgent, userAgentMetadata) {\n    await this.#client.send('Network.setUserAgentOverride', {\n      userAgent: userAgent,\n      userAgentMetadata: userAgentMetadata\n    });\n  }\n  async setCacheEnabled(enabled) {\n    this.#userCacheDisabled = !enabled;\n    await this.#updateProtocolCacheDisabled();\n  }\n  async setRequestInterception(value) {\n    this.#userRequestInterceptionEnabled = value;\n    await this.#updateProtocolRequestInterception();\n  }\n  async #updateProtocolRequestInterception() {\n    const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;\n    if (enabled === this.#protocolRequestInterceptionEnabled) {\n      return;\n    }\n    this.#protocolRequestInterceptionEnabled = enabled;\n    if (enabled) {\n      await Promise.all([this.#updateProtocolCacheDisabled(), this.#client.send('Fetch.enable', {\n        handleAuthRequests: true,\n        patterns: [{\n          urlPattern: '*'\n        }]\n      })]);\n    } else {\n      await Promise.all([this.#updateProtocolCacheDisabled(), this.#client.send('Fetch.disable')]);\n    }\n  }\n  #cacheDisabled() {\n    return this.#userCacheDisabled;\n  }\n  async #updateProtocolCacheDisabled() {\n    await this.#client.send('Network.setCacheDisabled', {\n      cacheDisabled: this.#cacheDisabled()\n    });\n  }\n  #onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this.#userRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const {\n        requestId: networkRequestId\n      } = event;\n      this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);\n      /**\n       * CDP may have sent a Fetch.requestPaused event already. Check for it.\n       */\n      const requestPausedEvent = this.#networkEventManager.getRequestPaused(networkRequestId);\n      if (requestPausedEvent) {\n        const {\n          requestId: fetchRequestId\n        } = requestPausedEvent;\n        this.#patchRequestEventHeaders(event, requestPausedEvent);\n        this.#onRequest(event, fetchRequestId);\n        this.#networkEventManager.forgetRequestPaused(networkRequestId);\n      }\n      return;\n    }\n    this.#onRequest(event, undefined);\n  }\n  #onAuthRequired(event) {\n    let response = 'Default';\n    if (this.#attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this.#credentials) {\n      response = 'ProvideCredentials';\n      this.#attemptedAuthentications.add(event.requestId);\n    }\n    const {\n      username,\n      password\n    } = this.#credentials || {\n      username: undefined,\n      password: undefined\n    };\n    this.#client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    }).catch(debugError);\n  }\n  /**\n   * CDP may send a Fetch.requestPaused without or before a\n   * Network.requestWillBeSent\n   *\n   * CDP may send multiple Fetch.requestPaused\n   * for the same Network.requestWillBeSent.\n   */\n  #onRequestPaused(event) {\n    if (!this.#userRequestInterceptionEnabled && this.#protocolRequestInterceptionEnabled) {\n      this.#client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(debugError);\n    }\n    const {\n      networkId: networkRequestId,\n      requestId: fetchRequestId\n    } = event;\n    if (!networkRequestId) {\n      this.#onRequestWithoutNetworkInstrumentation(event);\n      return;\n    }\n    const requestWillBeSentEvent = (() => {\n      const requestWillBeSentEvent = this.#networkEventManager.getRequestWillBeSent(networkRequestId);\n      // redirect requests have the same `requestId`,\n      if (requestWillBeSentEvent && (requestWillBeSentEvent.request.url !== event.request.url || requestWillBeSentEvent.request.method !== event.request.method)) {\n        this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);\n        return;\n      }\n      return requestWillBeSentEvent;\n    })();\n    if (requestWillBeSentEvent) {\n      this.#patchRequestEventHeaders(requestWillBeSentEvent, event);\n      this.#onRequest(requestWillBeSentEvent, fetchRequestId);\n    } else {\n      this.#networkEventManager.storeRequestPaused(networkRequestId, event);\n    }\n  }\n  #patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {\n    requestWillBeSentEvent.request.headers = {\n      ...requestWillBeSentEvent.request.headers,\n      // includes extra headers, like: Accept, Origin\n      ...requestPausedEvent.request.headers\n    };\n  }\n  #onRequestWithoutNetworkInstrumentation(event) {\n    // If an event has no networkId it should not have any network events. We\n    // still want to dispatch it for the interception by the user.\n    const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;\n    const request = new HTTPRequest(this.#client, frame, event.requestId, this.#userRequestInterceptionEnabled, event, []);\n    this.emit(NetworkManagerEmittedEvents.Request, request);\n    void request.finalizeInterceptions();\n  }\n  #onRequest(event, fetchRequestId) {\n    let redirectChain = [];\n    if (event.redirectResponse) {\n      // We want to emit a response and requestfinished for the\n      // redirectResponse, but we can't do so unless we have a\n      // responseExtraInfo ready to pair it up with. If we don't have any\n      // responseExtraInfos saved in our queue, they we have to wait until\n      // the next one to emit response and requestfinished, *and* we should\n      // also wait to emit this Request too because it should come after the\n      // response/requestfinished.\n      let redirectResponseExtraInfo = null;\n      if (event.redirectHasExtraInfo) {\n        redirectResponseExtraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();\n        if (!redirectResponseExtraInfo) {\n          this.#networkEventManager.queueRedirectInfo(event.requestId, {\n            event,\n            fetchRequestId\n          });\n          return;\n        }\n      }\n      const request = this.#networkEventManager.getRequest(event.requestId);\n      // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n      if (request) {\n        this.#handleRequestRedirect(request, event.redirectResponse, redirectResponseExtraInfo);\n        redirectChain = request._redirectChain;\n      }\n    }\n    const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;\n    const request = new HTTPRequest(this.#client, frame, fetchRequestId, this.#userRequestInterceptionEnabled, event, redirectChain);\n    this.#networkEventManager.storeRequest(event.requestId, request);\n    this.emit(NetworkManagerEmittedEvents.Request, request);\n    void request.finalizeInterceptions();\n  }\n  #onRequestServedFromCache(event) {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    if (request) {\n      request._fromMemoryCache = true;\n    }\n    this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);\n  }\n  #handleRequestRedirect(request, responsePayload, extraInfo) {\n    const response = new HTTPResponse(this.#client, request, responsePayload, extraInfo);\n    request._response = response;\n    request._redirectChain.push(request);\n    response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n    this.#forgetRequest(request, false);\n    this.emit(NetworkManagerEmittedEvents.Response, response);\n    this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n  #emitResponseEvent(responseReceived, extraInfo) {\n    const request = this.#networkEventManager.getRequest(responseReceived.requestId);\n    // FileUpload sends a response without a matching request.\n    if (!request) {\n      return;\n    }\n    const extraInfos = this.#networkEventManager.responseExtraInfo(responseReceived.requestId);\n    if (extraInfos.length) {\n      debugError(new Error('Unexpected extraInfo events for request ' + responseReceived.requestId));\n    }\n    // Chromium sends wrong extraInfo events for responses served from cache.\n    // See https://github.com/puppeteer/puppeteer/issues/9965 and\n    // https://crbug.com/1340398.\n    if (responseReceived.response.fromDiskCache) {\n      extraInfo = null;\n    }\n    const response = new HTTPResponse(this.#client, request, responseReceived.response, extraInfo);\n    request._response = response;\n    this.emit(NetworkManagerEmittedEvents.Response, response);\n  }\n  #onResponseReceived(event) {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    let extraInfo = null;\n    if (request && !request._fromMemoryCache && event.hasExtraInfo) {\n      extraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();\n      if (!extraInfo) {\n        // Wait until we get the corresponding ExtraInfo event.\n        this.#networkEventManager.queueEventGroup(event.requestId, {\n          responseReceivedEvent: event\n        });\n        return;\n      }\n    }\n    this.#emitResponseEvent(event, extraInfo);\n  }\n  #onResponseReceivedExtraInfo(event) {\n    // We may have skipped a redirect response/request pair due to waiting for\n    // this ExtraInfo event. If so, continue that work now that we have the\n    // request.\n    const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(event.requestId);\n    if (redirectInfo) {\n      this.#networkEventManager.responseExtraInfo(event.requestId).push(event);\n      this.#onRequest(redirectInfo.event, redirectInfo.fetchRequestId);\n      return;\n    }\n    // We may have skipped response and loading events because we didn't have\n    // this ExtraInfo event yet. If so, emit those events now.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n      this.#networkEventManager.forgetQueuedEventGroup(event.requestId);\n      this.#emitResponseEvent(queuedEvents.responseReceivedEvent, event);\n      if (queuedEvents.loadingFinishedEvent) {\n        this.#emitLoadingFinished(queuedEvents.loadingFinishedEvent);\n      }\n      if (queuedEvents.loadingFailedEvent) {\n        this.#emitLoadingFailed(queuedEvents.loadingFailedEvent);\n      }\n      return;\n    }\n    // Wait until we get another event that can use this ExtraInfo event.\n    this.#networkEventManager.responseExtraInfo(event.requestId).push(event);\n  }\n  #forgetRequest(request, events) {\n    const requestId = request._requestId;\n    const interceptionId = request._interceptionId;\n    this.#networkEventManager.forgetRequest(requestId);\n    interceptionId !== undefined && this.#attemptedAuthentications.delete(interceptionId);\n    if (events) {\n      this.#networkEventManager.forget(requestId);\n    }\n  }\n  #onLoadingFinished(event) {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n      queuedEvents.loadingFinishedEvent = event;\n    } else {\n      this.#emitLoadingFinished(event);\n    }\n  }\n  #emitLoadingFinished(event) {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n      return;\n    }\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    if (request.response()) {\n      request.response()?._resolveBody(null);\n    }\n    this.#forgetRequest(request, true);\n    this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n  #onLoadingFailed(event) {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n      queuedEvents.loadingFailedEvent = event;\n    } else {\n      this.#emitLoadingFailed(event);\n    }\n  }\n  #emitLoadingFailed(event) {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n      return;\n    }\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) {\n      response._resolveBody(null);\n    }\n    this.#forgetRequest(request, true);\n    this.emit(NetworkManagerEmittedEvents.RequestFailed, request);\n  }\n}","map":{"version":3,"names":["assert","createDebuggableDeferred","EventEmitter","HTTPRequest","HTTPResponse","NetworkEventManager","debugError","isString","NetworkManagerEmittedEvents","Request","Symbol","RequestServedFromCache","Response","RequestFailed","RequestFinished","NetworkManager","client","ignoreHTTPSErrors","frameManager","networkEventManager","extraHTTPHeaders","credentials","attemptedAuthentications","Set","userRequestInterceptionEnabled","protocolRequestInterceptionEnabled","userCacheDisabled","emulatedNetworkConditions","offline","upload","download","latency","deferredInit","constructor","on","onRequestPaused","bind","onAuthRequired","onRequestWillBeSent","onRequestServedFromCache","onResponseReceived","onLoadingFinished","onLoadingFailed","onResponseReceivedExtraInfo","initialize","valueOrThrow","init","Promise","all","send","ignore","deferredInitPromise","then","resolve","catch","err","reject","authenticate","updateProtocolRequestInterception","setExtraHTTPHeaders","key","Object","keys","value","toLowerCase","headers","assign","inFlightRequestsCount","setOfflineMode","updateNetworkConditions","emulateNetworkConditions","networkConditions","#updateNetworkConditions","uploadThroughput","downloadThroughput","setUserAgent","userAgent","userAgentMetadata","setCacheEnabled","enabled","updateProtocolCacheDisabled","setRequestInterception","#updateProtocolRequestInterception","handleAuthRequests","patterns","urlPattern","cacheDisabled","#cacheDisabled","#updateProtocolCacheDisabled","#onRequestWillBeSent","event","request","url","startsWith","requestId","networkRequestId","storeRequestWillBeSent","requestPausedEvent","getRequestPaused","fetchRequestId","patchRequestEventHeaders","onRequest","forgetRequestPaused","undefined","#onAuthRequired","response","has","add","username","password","authChallengeResponse","#onRequestPaused","networkId","onRequestWithoutNetworkInstrumentation","requestWillBeSentEvent","getRequestWillBeSent","method","forgetRequestWillBeSent","storeRequestPaused","#patchRequestEventHeaders","#onRequestWithoutNetworkInstrumentation","frame","frameId","emit","finalizeInterceptions","#onRequest","redirectChain","redirectResponse","redirectResponseExtraInfo","redirectHasExtraInfo","responseExtraInfo","shift","queueRedirectInfo","getRequest","handleRequestRedirect","_redirectChain","storeRequest","#onRequestServedFromCache","_fromMemoryCache","#handleRequestRedirect","responsePayload","extraInfo","_response","push","_resolveBody","Error","forgetRequest","emitResponseEvent","#emitResponseEvent","responseReceived","extraInfos","length","fromDiskCache","#onResponseReceived","hasExtraInfo","queueEventGroup","responseReceivedEvent","#onResponseReceivedExtraInfo","redirectInfo","takeQueuedRedirectInfo","queuedEvents","getQueuedEventGroup","forgetQueuedEventGroup","loadingFinishedEvent","emitLoadingFinished","loadingFailedEvent","emitLoadingFailed","#forgetRequest","events","_requestId","interceptionId","_interceptionId","delete","forget","#onLoadingFinished","#emitLoadingFinished","#onLoadingFailed","#emitLoadingFailed","_failureText","errorText"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/NetworkManager.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Protocol} from 'devtools-protocol';\n\nimport {assert} from '../util/assert.js';\nimport {createDebuggableDeferred} from '../util/DebuggableDeferred.js';\nimport {Deferred} from '../util/Deferred.js';\n\nimport {CDPSession} from './Connection.js';\nimport {EventEmitter} from './EventEmitter.js';\nimport {FrameManager} from './FrameManager.js';\nimport {HTTPRequest} from './HTTPRequest.js';\nimport {HTTPResponse} from './HTTPResponse.js';\nimport {FetchRequestId, NetworkEventManager} from './NetworkEventManager.js';\nimport {debugError, isString} from './util.js';\n\n/**\n * @public\n */\nexport interface Credentials {\n  username: string;\n  password: string;\n}\n\n/**\n * @public\n */\nexport interface NetworkConditions {\n  // Download speed (bytes/s)\n  download: number;\n  // Upload speed (bytes/s)\n  upload: number;\n  // Latency (ms)\n  latency: number;\n}\n/**\n * @public\n */\nexport interface InternalNetworkConditions extends NetworkConditions {\n  offline: boolean;\n}\n\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished'),\n} as const;\n\n/**\n * @internal\n */\nexport class NetworkManager extends EventEmitter {\n  #client: CDPSession;\n  #ignoreHTTPSErrors: boolean;\n  #frameManager: Pick<FrameManager, 'frame'>;\n  #networkEventManager = new NetworkEventManager();\n  #extraHTTPHeaders: Record<string, string> = {};\n  #credentials?: Credentials;\n  #attemptedAuthentications = new Set<string>();\n  #userRequestInterceptionEnabled = false;\n  #protocolRequestInterceptionEnabled = false;\n  #userCacheDisabled = false;\n  #emulatedNetworkConditions: InternalNetworkConditions = {\n    offline: false,\n    upload: -1,\n    download: -1,\n    latency: 0,\n  };\n  #deferredInit?: Deferred<void>;\n\n  constructor(\n    client: CDPSession,\n    ignoreHTTPSErrors: boolean,\n    frameManager: Pick<FrameManager, 'frame'>\n  ) {\n    super();\n    this.#client = client;\n    this.#ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this.#frameManager = frameManager;\n\n    this.#client.on('Fetch.requestPaused', this.#onRequestPaused.bind(this));\n    this.#client.on('Fetch.authRequired', this.#onAuthRequired.bind(this));\n    this.#client.on(\n      'Network.requestWillBeSent',\n      this.#onRequestWillBeSent.bind(this)\n    );\n    this.#client.on(\n      'Network.requestServedFromCache',\n      this.#onRequestServedFromCache.bind(this)\n    );\n    this.#client.on(\n      'Network.responseReceived',\n      this.#onResponseReceived.bind(this)\n    );\n    this.#client.on(\n      'Network.loadingFinished',\n      this.#onLoadingFinished.bind(this)\n    );\n    this.#client.on('Network.loadingFailed', this.#onLoadingFailed.bind(this));\n    this.#client.on(\n      'Network.responseReceivedExtraInfo',\n      this.#onResponseReceivedExtraInfo.bind(this)\n    );\n  }\n\n  /**\n   * Initialize calls should avoid async dependencies between CDP calls as those\n   * might not resolve until after the target is resumed causing a deadlock.\n   */\n  initialize(): Promise<void> {\n    if (this.#deferredInit) {\n      return this.#deferredInit.valueOrThrow();\n    }\n    this.#deferredInit = createDebuggableDeferred(\n      'NetworkManager initialization timed out'\n    );\n    const init = Promise.all([\n      this.#ignoreHTTPSErrors\n        ? this.#client.send('Security.setIgnoreCertificateErrors', {\n            ignore: true,\n          })\n        : null,\n      this.#client.send('Network.enable'),\n    ]);\n    const deferredInitPromise = this.#deferredInit;\n    init\n      .then(() => {\n        deferredInitPromise.resolve();\n      })\n      .catch(err => {\n        deferredInitPromise.reject(err);\n      });\n    return this.#deferredInit.valueOrThrow();\n  }\n\n  async authenticate(credentials?: Credentials): Promise<void> {\n    this.#credentials = credentials;\n    await this.#updateProtocolRequestInterception();\n  }\n\n  async setExtraHTTPHeaders(\n    extraHTTPHeaders: Record<string, string>\n  ): Promise<void> {\n    this.#extraHTTPHeaders = {};\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert(\n        isString(value),\n        `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`\n      );\n      this.#extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n    await this.#client.send('Network.setExtraHTTPHeaders', {\n      headers: this.#extraHTTPHeaders,\n    });\n  }\n\n  extraHTTPHeaders(): Record<string, string> {\n    return Object.assign({}, this.#extraHTTPHeaders);\n  }\n\n  inFlightRequestsCount(): number {\n    return this.#networkEventManager.inFlightRequestsCount();\n  }\n\n  async setOfflineMode(value: boolean): Promise<void> {\n    this.#emulatedNetworkConditions.offline = value;\n    await this.#updateNetworkConditions();\n  }\n\n  async emulateNetworkConditions(\n    networkConditions: NetworkConditions | null\n  ): Promise<void> {\n    this.#emulatedNetworkConditions.upload = networkConditions\n      ? networkConditions.upload\n      : -1;\n    this.#emulatedNetworkConditions.download = networkConditions\n      ? networkConditions.download\n      : -1;\n    this.#emulatedNetworkConditions.latency = networkConditions\n      ? networkConditions.latency\n      : 0;\n\n    await this.#updateNetworkConditions();\n  }\n\n  async #updateNetworkConditions(): Promise<void> {\n    await this.#client.send('Network.emulateNetworkConditions', {\n      offline: this.#emulatedNetworkConditions.offline,\n      latency: this.#emulatedNetworkConditions.latency,\n      uploadThroughput: this.#emulatedNetworkConditions.upload,\n      downloadThroughput: this.#emulatedNetworkConditions.download,\n    });\n  }\n\n  async setUserAgent(\n    userAgent: string,\n    userAgentMetadata?: Protocol.Emulation.UserAgentMetadata\n  ): Promise<void> {\n    await this.#client.send('Network.setUserAgentOverride', {\n      userAgent: userAgent,\n      userAgentMetadata: userAgentMetadata,\n    });\n  }\n\n  async setCacheEnabled(enabled: boolean): Promise<void> {\n    this.#userCacheDisabled = !enabled;\n    await this.#updateProtocolCacheDisabled();\n  }\n\n  async setRequestInterception(value: boolean): Promise<void> {\n    this.#userRequestInterceptionEnabled = value;\n    await this.#updateProtocolRequestInterception();\n  }\n\n  async #updateProtocolRequestInterception(): Promise<void> {\n    const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;\n    if (enabled === this.#protocolRequestInterceptionEnabled) {\n      return;\n    }\n    this.#protocolRequestInterceptionEnabled = enabled;\n    if (enabled) {\n      await Promise.all([\n        this.#updateProtocolCacheDisabled(),\n        this.#client.send('Fetch.enable', {\n          handleAuthRequests: true,\n          patterns: [{urlPattern: '*'}],\n        }),\n      ]);\n    } else {\n      await Promise.all([\n        this.#updateProtocolCacheDisabled(),\n        this.#client.send('Fetch.disable'),\n      ]);\n    }\n  }\n\n  #cacheDisabled(): boolean {\n    return this.#userCacheDisabled;\n  }\n\n  async #updateProtocolCacheDisabled(): Promise<void> {\n    await this.#client.send('Network.setCacheDisabled', {\n      cacheDisabled: this.#cacheDisabled(),\n    });\n  }\n\n  #onRequestWillBeSent(event: Protocol.Network.RequestWillBeSentEvent): void {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (\n      this.#userRequestInterceptionEnabled &&\n      !event.request.url.startsWith('data:')\n    ) {\n      const {requestId: networkRequestId} = event;\n\n      this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);\n\n      /**\n       * CDP may have sent a Fetch.requestPaused event already. Check for it.\n       */\n      const requestPausedEvent =\n        this.#networkEventManager.getRequestPaused(networkRequestId);\n      if (requestPausedEvent) {\n        const {requestId: fetchRequestId} = requestPausedEvent;\n        this.#patchRequestEventHeaders(event, requestPausedEvent);\n        this.#onRequest(event, fetchRequestId);\n        this.#networkEventManager.forgetRequestPaused(networkRequestId);\n      }\n\n      return;\n    }\n    this.#onRequest(event, undefined);\n  }\n\n  #onAuthRequired(event: Protocol.Fetch.AuthRequiredEvent): void {\n    let response: Protocol.Fetch.AuthChallengeResponse['response'] = 'Default';\n    if (this.#attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this.#credentials) {\n      response = 'ProvideCredentials';\n      this.#attemptedAuthentications.add(event.requestId);\n    }\n    const {username, password} = this.#credentials || {\n      username: undefined,\n      password: undefined,\n    };\n    this.#client\n      .send('Fetch.continueWithAuth', {\n        requestId: event.requestId,\n        authChallengeResponse: {response, username, password},\n      })\n      .catch(debugError);\n  }\n\n  /**\n   * CDP may send a Fetch.requestPaused without or before a\n   * Network.requestWillBeSent\n   *\n   * CDP may send multiple Fetch.requestPaused\n   * for the same Network.requestWillBeSent.\n   */\n  #onRequestPaused(event: Protocol.Fetch.RequestPausedEvent): void {\n    if (\n      !this.#userRequestInterceptionEnabled &&\n      this.#protocolRequestInterceptionEnabled\n    ) {\n      this.#client\n        .send('Fetch.continueRequest', {\n          requestId: event.requestId,\n        })\n        .catch(debugError);\n    }\n\n    const {networkId: networkRequestId, requestId: fetchRequestId} = event;\n\n    if (!networkRequestId) {\n      this.#onRequestWithoutNetworkInstrumentation(event);\n      return;\n    }\n\n    const requestWillBeSentEvent = (() => {\n      const requestWillBeSentEvent =\n        this.#networkEventManager.getRequestWillBeSent(networkRequestId);\n\n      // redirect requests have the same `requestId`,\n      if (\n        requestWillBeSentEvent &&\n        (requestWillBeSentEvent.request.url !== event.request.url ||\n          requestWillBeSentEvent.request.method !== event.request.method)\n      ) {\n        this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);\n        return;\n      }\n      return requestWillBeSentEvent;\n    })();\n\n    if (requestWillBeSentEvent) {\n      this.#patchRequestEventHeaders(requestWillBeSentEvent, event);\n      this.#onRequest(requestWillBeSentEvent, fetchRequestId);\n    } else {\n      this.#networkEventManager.storeRequestPaused(networkRequestId, event);\n    }\n  }\n\n  #patchRequestEventHeaders(\n    requestWillBeSentEvent: Protocol.Network.RequestWillBeSentEvent,\n    requestPausedEvent: Protocol.Fetch.RequestPausedEvent\n  ): void {\n    requestWillBeSentEvent.request.headers = {\n      ...requestWillBeSentEvent.request.headers,\n      // includes extra headers, like: Accept, Origin\n      ...requestPausedEvent.request.headers,\n    };\n  }\n\n  #onRequestWithoutNetworkInstrumentation(\n    event: Protocol.Fetch.RequestPausedEvent\n  ): void {\n    // If an event has no networkId it should not have any network events. We\n    // still want to dispatch it for the interception by the user.\n    const frame = event.frameId\n      ? this.#frameManager.frame(event.frameId)\n      : null;\n\n    const request = new HTTPRequest(\n      this.#client,\n      frame,\n      event.requestId,\n      this.#userRequestInterceptionEnabled,\n      event,\n      []\n    );\n    this.emit(NetworkManagerEmittedEvents.Request, request);\n    void request.finalizeInterceptions();\n  }\n\n  #onRequest(\n    event: Protocol.Network.RequestWillBeSentEvent,\n    fetchRequestId?: FetchRequestId\n  ): void {\n    let redirectChain: HTTPRequest[] = [];\n    if (event.redirectResponse) {\n      // We want to emit a response and requestfinished for the\n      // redirectResponse, but we can't do so unless we have a\n      // responseExtraInfo ready to pair it up with. If we don't have any\n      // responseExtraInfos saved in our queue, they we have to wait until\n      // the next one to emit response and requestfinished, *and* we should\n      // also wait to emit this Request too because it should come after the\n      // response/requestfinished.\n      let redirectResponseExtraInfo = null;\n      if (event.redirectHasExtraInfo) {\n        redirectResponseExtraInfo = this.#networkEventManager\n          .responseExtraInfo(event.requestId)\n          .shift();\n        if (!redirectResponseExtraInfo) {\n          this.#networkEventManager.queueRedirectInfo(event.requestId, {\n            event,\n            fetchRequestId,\n          });\n          return;\n        }\n      }\n\n      const request = this.#networkEventManager.getRequest(event.requestId);\n      // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n      if (request) {\n        this.#handleRequestRedirect(\n          request,\n          event.redirectResponse,\n          redirectResponseExtraInfo\n        );\n        redirectChain = request._redirectChain;\n      }\n    }\n    const frame = event.frameId\n      ? this.#frameManager.frame(event.frameId)\n      : null;\n\n    const request = new HTTPRequest(\n      this.#client,\n      frame,\n      fetchRequestId,\n      this.#userRequestInterceptionEnabled,\n      event,\n      redirectChain\n    );\n    this.#networkEventManager.storeRequest(event.requestId, request);\n    this.emit(NetworkManagerEmittedEvents.Request, request);\n    void request.finalizeInterceptions();\n  }\n\n  #onRequestServedFromCache(\n    event: Protocol.Network.RequestServedFromCacheEvent\n  ): void {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    if (request) {\n      request._fromMemoryCache = true;\n    }\n    this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);\n  }\n\n  #handleRequestRedirect(\n    request: HTTPRequest,\n    responsePayload: Protocol.Network.Response,\n    extraInfo: Protocol.Network.ResponseReceivedExtraInfoEvent | null\n  ): void {\n    const response = new HTTPResponse(\n      this.#client,\n      request,\n      responsePayload,\n      extraInfo\n    );\n    request._response = response;\n    request._redirectChain.push(request);\n    response._resolveBody(\n      new Error('Response body is unavailable for redirect responses')\n    );\n    this.#forgetRequest(request, false);\n    this.emit(NetworkManagerEmittedEvents.Response, response);\n    this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  #emitResponseEvent(\n    responseReceived: Protocol.Network.ResponseReceivedEvent,\n    extraInfo: Protocol.Network.ResponseReceivedExtraInfoEvent | null\n  ): void {\n    const request = this.#networkEventManager.getRequest(\n      responseReceived.requestId\n    );\n    // FileUpload sends a response without a matching request.\n    if (!request) {\n      return;\n    }\n\n    const extraInfos = this.#networkEventManager.responseExtraInfo(\n      responseReceived.requestId\n    );\n    if (extraInfos.length) {\n      debugError(\n        new Error(\n          'Unexpected extraInfo events for request ' +\n            responseReceived.requestId\n        )\n      );\n    }\n\n    // Chromium sends wrong extraInfo events for responses served from cache.\n    // See https://github.com/puppeteer/puppeteer/issues/9965 and\n    // https://crbug.com/1340398.\n    if (responseReceived.response.fromDiskCache) {\n      extraInfo = null;\n    }\n\n    const response = new HTTPResponse(\n      this.#client,\n      request,\n      responseReceived.response,\n      extraInfo\n    );\n    request._response = response;\n    this.emit(NetworkManagerEmittedEvents.Response, response);\n  }\n\n  #onResponseReceived(event: Protocol.Network.ResponseReceivedEvent): void {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    let extraInfo = null;\n    if (request && !request._fromMemoryCache && event.hasExtraInfo) {\n      extraInfo = this.#networkEventManager\n        .responseExtraInfo(event.requestId)\n        .shift();\n      if (!extraInfo) {\n        // Wait until we get the corresponding ExtraInfo event.\n        this.#networkEventManager.queueEventGroup(event.requestId, {\n          responseReceivedEvent: event,\n        });\n        return;\n      }\n    }\n    this.#emitResponseEvent(event, extraInfo);\n  }\n\n  #onResponseReceivedExtraInfo(\n    event: Protocol.Network.ResponseReceivedExtraInfoEvent\n  ): void {\n    // We may have skipped a redirect response/request pair due to waiting for\n    // this ExtraInfo event. If so, continue that work now that we have the\n    // request.\n    const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(\n      event.requestId\n    );\n    if (redirectInfo) {\n      this.#networkEventManager.responseExtraInfo(event.requestId).push(event);\n      this.#onRequest(redirectInfo.event, redirectInfo.fetchRequestId);\n      return;\n    }\n\n    // We may have skipped response and loading events because we didn't have\n    // this ExtraInfo event yet. If so, emit those events now.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(\n      event.requestId\n    );\n    if (queuedEvents) {\n      this.#networkEventManager.forgetQueuedEventGroup(event.requestId);\n      this.#emitResponseEvent(queuedEvents.responseReceivedEvent, event);\n      if (queuedEvents.loadingFinishedEvent) {\n        this.#emitLoadingFinished(queuedEvents.loadingFinishedEvent);\n      }\n      if (queuedEvents.loadingFailedEvent) {\n        this.#emitLoadingFailed(queuedEvents.loadingFailedEvent);\n      }\n      return;\n    }\n\n    // Wait until we get another event that can use this ExtraInfo event.\n    this.#networkEventManager.responseExtraInfo(event.requestId).push(event);\n  }\n\n  #forgetRequest(request: HTTPRequest, events: boolean): void {\n    const requestId = request._requestId;\n    const interceptionId = request._interceptionId;\n\n    this.#networkEventManager.forgetRequest(requestId);\n    interceptionId !== undefined &&\n      this.#attemptedAuthentications.delete(interceptionId);\n\n    if (events) {\n      this.#networkEventManager.forget(requestId);\n    }\n  }\n\n  #onLoadingFinished(event: Protocol.Network.LoadingFinishedEvent): void {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(\n      event.requestId\n    );\n    if (queuedEvents) {\n      queuedEvents.loadingFinishedEvent = event;\n    } else {\n      this.#emitLoadingFinished(event);\n    }\n  }\n\n  #emitLoadingFinished(event: Protocol.Network.LoadingFinishedEvent): void {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n      return;\n    }\n\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    if (request.response()) {\n      request.response()?._resolveBody(null);\n    }\n    this.#forgetRequest(request, true);\n    this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  #onLoadingFailed(event: Protocol.Network.LoadingFailedEvent): void {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(\n      event.requestId\n    );\n    if (queuedEvents) {\n      queuedEvents.loadingFailedEvent = event;\n    } else {\n      this.#emitLoadingFailed(event);\n    }\n  }\n\n  #emitLoadingFailed(event: Protocol.Network.LoadingFailedEvent): void {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n      return;\n    }\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) {\n      response._resolveBody(null);\n    }\n    this.#forgetRequest(request, true);\n    this.emit(NetworkManagerEmittedEvents.RequestFailed, request);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}