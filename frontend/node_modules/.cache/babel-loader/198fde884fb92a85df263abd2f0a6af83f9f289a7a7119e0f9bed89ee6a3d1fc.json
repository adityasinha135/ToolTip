{"ast":null,"code":"import { JSHandle } from '../api/JSHandle.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { debugError } from './util.js';\n/**\n * @internal\n */\nexport class Binding {\n  #name;\n  #fn;\n  constructor(name, fn) {\n    this.#name = name;\n    this.#fn = fn;\n  }\n  get name() {\n    return this.#name;\n  }\n  /**\n   * @param context - Context to run the binding in; the context should have\n   * the binding added to it beforehand.\n   * @param id - ID of the call. This should come from the CDP\n   * `onBindingCalled` response.\n   * @param args - Plain arguments from CDP.\n   */\n  async run(context, id, args, isTrivial) {\n    const garbage = [];\n    try {\n      if (!isTrivial) {\n        // Getting non-trivial arguments.\n        const handles = await context.evaluateHandle((name, seq) => {\n          // @ts-expect-error Code is evaluated in a different context.\n          return globalThis[name].args.get(seq);\n        }, this.#name, id);\n        try {\n          const properties = await handles.getProperties();\n          for (const [index, handle] of properties) {\n            // This is not straight-forward since some arguments can stringify, but\n            // aren't plain objects so add subtypes when the use-case arises.\n            if (index in args) {\n              switch (handle.remoteObject().subtype) {\n                case 'node':\n                  args[+index] = handle;\n                  break;\n                default:\n                  garbage.push(handle.dispose());\n              }\n            } else {\n              garbage.push(handle.dispose());\n            }\n          }\n        } finally {\n          await handles.dispose();\n        }\n      }\n      await context.evaluate((name, seq, result) => {\n        // @ts-expect-error Code is evaluated in a different context.\n        const callbacks = globalThis[name].callbacks;\n        callbacks.get(seq).resolve(result);\n        callbacks.delete(seq);\n      }, this.#name, id, await this.#fn(...args));\n      for (const arg of args) {\n        if (arg instanceof JSHandle) {\n          garbage.push(arg.dispose());\n        }\n      }\n    } catch (error) {\n      if (isErrorLike(error)) {\n        await context.evaluate((name, seq, message, stack) => {\n          const error = new Error(message);\n          error.stack = stack;\n          // @ts-expect-error Code is evaluated in a different context.\n          const callbacks = globalThis[name].callbacks;\n          callbacks.get(seq).reject(error);\n          callbacks.delete(seq);\n        }, this.#name, id, error.message, error.stack).catch(debugError);\n      } else {\n        await context.evaluate((name, seq, error) => {\n          // @ts-expect-error Code is evaluated in a different context.\n          const callbacks = globalThis[name].callbacks;\n          callbacks.get(seq).reject(error);\n          callbacks.delete(seq);\n        }, this.#name, id, error).catch(debugError);\n      }\n    } finally {\n      await Promise.all(garbage);\n    }\n  }\n}","map":{"version":3,"names":["JSHandle","isErrorLike","debugError","Binding","name","fn","constructor","run","context","id","args","isTrivial","garbage","handles","evaluateHandle","seq","globalThis","get","properties","getProperties","index","handle","remoteObject","subtype","push","dispose","evaluate","result","callbacks","resolve","delete","arg","error","message","stack","Error","reject","catch","Promise","all"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/Binding.ts"],"sourcesContent":["import {JSHandle} from '../api/JSHandle.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\n\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {debugError} from './util.js';\n\n/**\n * @internal\n */\nexport class Binding {\n  #name: string;\n  #fn: (...args: unknown[]) => unknown;\n  constructor(name: string, fn: (...args: unknown[]) => unknown) {\n    this.#name = name;\n    this.#fn = fn;\n  }\n\n  get name(): string {\n    return this.#name;\n  }\n\n  /**\n   * @param context - Context to run the binding in; the context should have\n   * the binding added to it beforehand.\n   * @param id - ID of the call. This should come from the CDP\n   * `onBindingCalled` response.\n   * @param args - Plain arguments from CDP.\n   */\n  async run(\n    context: ExecutionContext,\n    id: number,\n    args: unknown[],\n    isTrivial: boolean\n  ): Promise<void> {\n    const garbage = [];\n    try {\n      if (!isTrivial) {\n        // Getting non-trivial arguments.\n        const handles = await context.evaluateHandle(\n          (name, seq) => {\n            // @ts-expect-error Code is evaluated in a different context.\n            return globalThis[name].args.get(seq);\n          },\n          this.#name,\n          id\n        );\n        try {\n          const properties = await handles.getProperties();\n          for (const [index, handle] of properties) {\n            // This is not straight-forward since some arguments can stringify, but\n            // aren't plain objects so add subtypes when the use-case arises.\n            if (index in args) {\n              switch (handle.remoteObject().subtype) {\n                case 'node':\n                  args[+index] = handle;\n                  break;\n                default:\n                  garbage.push(handle.dispose());\n              }\n            } else {\n              garbage.push(handle.dispose());\n            }\n          }\n        } finally {\n          await handles.dispose();\n        }\n      }\n\n      await context.evaluate(\n        (name, seq, result) => {\n          // @ts-expect-error Code is evaluated in a different context.\n          const callbacks = globalThis[name].callbacks;\n          callbacks.get(seq).resolve(result);\n          callbacks.delete(seq);\n        },\n        this.#name,\n        id,\n        await this.#fn(...args)\n      );\n\n      for (const arg of args) {\n        if (arg instanceof JSHandle) {\n          garbage.push(arg.dispose());\n        }\n      }\n    } catch (error) {\n      if (isErrorLike(error)) {\n        await context\n          .evaluate(\n            (name, seq, message, stack) => {\n              const error = new Error(message);\n              error.stack = stack;\n              // @ts-expect-error Code is evaluated in a different context.\n              const callbacks = globalThis[name].callbacks;\n              callbacks.get(seq).reject(error);\n              callbacks.delete(seq);\n            },\n            this.#name,\n            id,\n            error.message,\n            error.stack\n          )\n          .catch(debugError);\n      } else {\n        await context\n          .evaluate(\n            (name, seq, error) => {\n              // @ts-expect-error Code is evaluated in a different context.\n              const callbacks = globalThis[name].callbacks;\n              callbacks.get(seq).reject(error);\n              callbacks.delete(seq);\n            },\n            this.#name,\n            id,\n            error\n          )\n          .catch(debugError);\n      }\n    } finally {\n      await Promise.all(garbage);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}