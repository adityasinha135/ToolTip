{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { NetworkManagerEmittedEvents } from '../common/NetworkManager.js';\nimport { paperFormats } from '../common/PDFOptions.js';\nimport { importFSPromises, isNumber, isString, waitForEvent, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { FunctionLocator, Locator, NodeLocator } from './locators/locators.js';\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEmittedEvents} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link Page.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nexport class Page extends EventEmitter {\n  #handlerMap = new WeakMap();\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n  /**\n   * `true` if the service worker are being bypassed, `false` otherwise.\n   */\n  isServiceWorkerBypassed() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * `true` if drag events are being intercepted, `false` otherwise.\n   */\n  isDragInterceptionEnabled() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * `true` if the page has JavaScript enabled, `false` otherwise.\n   */\n  isJavaScriptEnabled() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Listen to page events.\n   *\n   * :::note\n   *\n   * This method exists to define event typings and handle proper wireup of\n   * cooperative request interception. Actual event listening and dispatching is\n   * delegated to {@link EventEmitter}.\n   *\n   * :::\n   */\n  on(eventName, handler) {\n    if (eventName === 'request') {\n      const wrap = this.#handlerMap.get(handler) || (event => {\n        event.enqueueInterceptAction(() => {\n          return handler(event);\n        });\n      });\n      this.#handlerMap.set(handler, wrap);\n      return super.on(eventName, wrap);\n    }\n    return super.on(eventName, handler);\n  }\n  once(eventName, handler) {\n    // Note: this method only exists to define the types; we delegate the impl\n    // to EventEmitter.\n    return super.once(eventName, handler);\n  }\n  off(eventName, handler) {\n    if (eventName === 'request') {\n      handler = this.#handlerMap.get(handler) || handler;\n    }\n    return super.off(eventName, handler);\n  }\n  waitForFileChooser() {\n    throw new Error('Not implemented');\n  }\n  async setGeolocation() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * A target this page was created from.\n   */\n  target() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Get the browser the page belongs to.\n   */\n  browser() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Get the browser context that the page belongs to.\n   */\n  browserContext() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * The page's main frame.\n   *\n   * @remarks\n   * Page is guaranteed to have a main frame which persists during navigations.\n   */\n  mainFrame() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Creates a Chrome Devtools Protocol session attached to the page.\n   */\n  createCDPSession() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * {@inheritDoc Keyboard}\n   */\n  get keyboard() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * {@inheritDoc Touchscreen}\n   */\n  get touchscreen() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * {@inheritDoc Coverage}\n   */\n  get coverage() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * {@inheritDoc Tracing}\n   */\n  get tracing() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * {@inheritDoc Accessibility}\n   */\n  get accessibility() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * An array of all frames attached to the page.\n   */\n  frames() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * All of the dedicated {@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n   * WebWorkers} associated with the page.\n   *\n   * @remarks\n   * This does not contain ServiceWorkers\n   */\n  workers() {\n    throw new Error('Not implemented');\n  }\n  async setRequestInterception() {\n    throw new Error('Not implemented');\n  }\n  async setBypassServiceWorker() {\n    throw new Error('Not implemented');\n  }\n  async setDragInterception() {\n    throw new Error('Not implemented');\n  }\n  setOfflineMode() {\n    throw new Error('Not implemented');\n  }\n  emulateNetworkConditions() {\n    throw new Error('Not implemented');\n  }\n  setDefaultNavigationTimeout() {\n    throw new Error('Not implemented');\n  }\n  setDefaultTimeout() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Maximum time in milliseconds.\n   */\n  getDefaultTimeout() {\n    throw new Error('Not implemented');\n  }\n  locator(selectorOrFunc) {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n  /**\n   * A shortcut for {@link Locator.race} that does not require static imports.\n   *\n   * @internal\n   */\n  locatorRace(locators) {\n    return Locator.race(locators);\n  }\n  /**\n   * Runs `document.querySelector` within the page. If no element matches the\n   * selector, the return value resolves to `null`.\n   *\n   * @param selector - A `selector` to query page for\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query page for.\n   */\n  async $(selector) {\n    return this.mainFrame().$(selector);\n  }\n  /**\n   * The method runs `document.querySelectorAll` within the page. If no elements\n   * match the selector, the return value resolves to `[]`.\n   * @remarks\n   * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n   * @param selector - A `selector` to query page for\n   */\n  async $$(selector) {\n    return this.mainFrame().$$(selector);\n  }\n  async evaluateHandle() {\n    throw new Error('Not implemented');\n  }\n  async queryObjects() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * This method runs `document.querySelector` within the page and passes the\n   * result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   *\n   * If no element is found matching `selector`, the method will throw an error.\n   *\n   * If `pageFunction` returns a promise `$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await page.$eval('#search', el => el.value);\n   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n   * const html = await page.$eval('.main-container', el => el.outerHTML);\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * const searchValue = await page.$eval(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const searchValue = await page.$eval<string>(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of `document.querySelector(selector)` as its\n   * first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $eval(selector, pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    return this.mainFrame().$eval(selector, pageFunction, ...args);\n  }\n  /**\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the page and passes the result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * // get the amount of divs on the page\n   * const divCount = await page.$$eval('div', divs => divs.length);\n   *\n   * // get the text content of all the `.options` elements:\n   * const options = await page.$$eval('div > span.options', options => {\n   *   return options.map(option => option.textContent);\n   * });\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element[]`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n   *   return elements.map(e => e.value);\n   * });\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const allInputValues = await page.$$eval<string[]>(\n   *   'input',\n   *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of\n   * `Array.from(document.querySelectorAll(selector))` as its first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $$eval(selector, pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    return this.mainFrame().$$eval(selector, pageFunction, ...args);\n  }\n  /**\n   * The method evaluates the XPath expression relative to the page document as\n   * its context node. If there are no such elements, the method resolves to an\n   * empty array.\n   *\n   * @remarks\n   * Shortcut for {@link Frame.$x | Page.mainFrame().$x(expression) }.\n   *\n   * @param expression - Expression to evaluate\n   */\n  async $x(expression) {\n    return this.mainFrame().$x(expression);\n  }\n  async cookies() {\n    throw new Error('Not implemented');\n  }\n  async deleteCookie() {\n    throw new Error('Not implemented');\n  }\n  async setCookie() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Adds a `<script>` tag into the page with the desired URL or content.\n   *\n   * @remarks\n   * Shortcut for\n   * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  async addScriptTag(options) {\n    return this.mainFrame().addScriptTag(options);\n  }\n  async addStyleTag(options) {\n    return this.mainFrame().addStyleTag(options);\n  }\n  async exposeFunction() {\n    throw new Error('Not implemented');\n  }\n  async removeExposedFunction() {\n    throw new Error('Not implemented');\n  }\n  async authenticate() {\n    throw new Error('Not implemented');\n  }\n  async setExtraHTTPHeaders() {\n    throw new Error('Not implemented');\n  }\n  async setUserAgent() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Object containing metrics as key/value pairs.\n   *\n   * @returns\n   *\n   * - `Timestamp` : The timestamp when the metrics sample was taken.\n   *\n   * - `Documents` : Number of documents in the page.\n   *\n   * - `Frames` : Number of frames in the page.\n   *\n   * - `JSEventListeners` : Number of events in the page.\n   *\n   * - `Nodes` : Number of DOM nodes in the page.\n   *\n   * - `LayoutCount` : Total number of full or partial page layout.\n   *\n   * - `RecalcStyleCount` : Total number of page style recalculations.\n   *\n   * - `LayoutDuration` : Combined durations of all page layouts.\n   *\n   * - `RecalcStyleDuration` : Combined duration of all page style\n   *   recalculations.\n   *\n   * - `ScriptDuration` : Combined duration of JavaScript execution.\n   *\n   * - `TaskDuration` : Combined duration of all tasks performed by the browser.\n   *\n   * - `JSHeapUsedSize` : Used JavaScript heap size.\n   *\n   * - `JSHeapTotalSize` : Total JavaScript heap size.\n   *\n   * @remarks\n   * All timestamps are in monotonic time: monotonically increasing time\n   * in seconds since an arbitrary point in the past.\n   */\n  async metrics() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * The page's URL.\n   * @remarks Shortcut for\n   * {@link Frame.url | page.mainFrame().url()}.\n   */\n  url() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * The full HTML contents of the page, including the DOCTYPE.\n   */\n  async content() {\n    throw new Error('Not implemented');\n  }\n  async setContent() {\n    throw new Error('Not implemented');\n  }\n  async goto() {\n    throw new Error('Not implemented');\n  }\n  async reload() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Waits for the page to navigate to a new URL or to reload. It is useful when\n   * you run code that will indirectly cause the page to navigate.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(), // The promise resolves after navigation has finished\n   *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n   * ]);\n   * ```\n   *\n   * @remarks\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @param options - Navigation parameters which might have the following\n   * properties:\n   * @returns A `Promise` which resolves to the main resource response.\n   *\n   * - In case of multiple redirects, the navigation will resolve with the\n   *   response of the last redirect.\n   * - In case of navigation to a different anchor or navigation due to History\n   *   API usage, the navigation will resolve with `null`.\n   */\n  async waitForNavigation(options = {}) {\n    return await this.mainFrame().waitForNavigation(options);\n  }\n  async waitForRequest() {\n    throw new Error('Not implemented');\n  }\n  async waitForResponse() {\n    throw new Error('Not implemented');\n  }\n  async waitForNetworkIdle() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  async _waitForNetworkIdle(networkManager, idleTime, timeout, closedDeferred) {\n    const idleDeferred = Deferred.create();\n    const abortDeferred = Deferred.create();\n    let idleTimer;\n    const cleanup = () => {\n      clearTimeout(idleTimer);\n      abortDeferred.reject(new Error('abort'));\n    };\n    const evaluate = () => {\n      clearTimeout(idleTimer);\n      if (networkManager.inFlightRequestsCount() === 0) {\n        idleTimer = setTimeout(() => {\n          return idleDeferred.resolve();\n        }, idleTime);\n      }\n    };\n    const listenToEvent = event => {\n      return waitForEvent(networkManager, event, () => {\n        evaluate();\n        return false;\n      }, timeout, abortDeferred);\n    };\n    const eventPromises = [listenToEvent(NetworkManagerEmittedEvents.Request), listenToEvent(NetworkManagerEmittedEvents.Response), listenToEvent(NetworkManagerEmittedEvents.RequestFailed)];\n    evaluate();\n    // We don't want to reject the closed deferred when\n    // the race if finished so we pass the Promise instead\n    const closedPromise = closedDeferred.valueOrThrow();\n    await Deferred.race([idleDeferred, ...eventPromises, closedPromise]).then(r => {\n      cleanup();\n      return r;\n    }, error => {\n      cleanup();\n      throw error;\n    });\n  }\n  async waitForFrame() {\n    throw new Error('Not implemented');\n  }\n  async goBack() {\n    throw new Error('Not implemented');\n  }\n  async goForward() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Brings page to front (activates tab).\n   */\n  async bringToFront() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Emulates a given device's metrics and user agent.\n   *\n   * To aid emulation, Puppeteer provides a list of known devices that can be\n   * via {@link KnownDevices}.\n   *\n   * @remarks\n   * This method is a shortcut for calling two methods:\n   * {@link Page.setUserAgent} and {@link Page.setViewport}.\n   *\n   * @remarks\n   * This method will resize the page. A lot of websites don't expect phones to\n   * change size, so you should emulate before navigating to the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import {KnownDevices} from 'puppeteer';\n   * const iPhone = KnownDevices['iPhone 6'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulate(iPhone);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   */\n  async emulate(device) {\n    await Promise.all([this.setUserAgent(device.userAgent), this.setViewport(device.viewport)]);\n  }\n  async setJavaScriptEnabled() {\n    throw new Error('Not implemented');\n  }\n  async setBypassCSP() {\n    throw new Error('Not implemented');\n  }\n  async emulateMediaType() {\n    throw new Error('Not implemented');\n  }\n  async emulateCPUThrottling() {\n    throw new Error('Not implemented');\n  }\n  async emulateMediaFeatures() {\n    throw new Error('Not implemented');\n  }\n  async emulateTimezone() {\n    throw new Error('Not implemented');\n  }\n  async emulateIdleState() {\n    throw new Error('Not implemented');\n  }\n  async emulateVisionDeficiency() {\n    throw new Error('Not implemented');\n  }\n  async setViewport() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Current page viewport settings.\n   *\n   * @returns\n   *\n   * - `width`: page's width in pixels\n   *\n   * - `height`: page's height in pixels\n   *\n   * - `deviceScaleFactor`: Specify device scale factor (can be though of as\n   *   dpr). Defaults to `1`.\n   *\n   * - `isMobile`: Whether the meta viewport tag is taken into account. Defaults\n   *   to `false`.\n   *\n   * - `hasTouch`: Specifies if viewport supports touch events. Defaults to\n   *   `false`.\n   *\n   * - `isLandScape`: Specifies if viewport is in landscape mode. Defaults to\n   *   `false`.\n   */\n  viewport() {\n    throw new Error('Not implemented');\n  }\n  async evaluate() {\n    throw new Error('Not implemented');\n  }\n  async evaluateOnNewDocument() {\n    throw new Error('Not implemented');\n  }\n  async removeScriptToEvaluateOnNewDocument() {\n    throw new Error('Not implemented');\n  }\n  async setCacheEnabled() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  async _maybeWriteBufferToFile(path, buffer) {\n    if (!path) {\n      return;\n    }\n    const fs = await importFSPromises();\n    await fs.writeFile(path, buffer);\n  }\n  async screenshot() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  _getPDFOptions(options = {}, lengthUnit = 'in') {\n    const defaults = {\n      scale: 1,\n      displayHeaderFooter: false,\n      headerTemplate: '',\n      footerTemplate: '',\n      printBackground: false,\n      landscape: false,\n      pageRanges: '',\n      preferCSSPageSize: false,\n      omitBackground: false,\n      timeout: 30000\n    };\n    let width = 8.5;\n    let height = 11;\n    if (options.format) {\n      const format = paperFormats[options.format.toLowerCase()];\n      assert(format, 'Unknown paper format: ' + options.format);\n      width = format.width;\n      height = format.height;\n    } else {\n      width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;\n      height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;\n    }\n    const margin = {\n      top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,\n      left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,\n      bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,\n      right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0\n    };\n    const output = {\n      ...defaults,\n      ...options,\n      width,\n      height,\n      margin\n    };\n    return output;\n  }\n  async createPDFStream() {\n    throw new Error('Not implemented');\n  }\n  async pdf() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * The page's title\n   *\n   * @remarks\n   * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n   */\n  async title() {\n    throw new Error('Not implemented');\n  }\n  async close() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Indicates that the page has been closed.\n   * @returns\n   */\n  isClosed() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * {@inheritDoc Mouse}\n   */\n  get mouse() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.mouse} to click in the center of the\n   * element. If there's no element matching `selector`, the method throws an\n   * error.\n   * @remarks Bear in mind that if `click()` triggers a navigation event and\n   * there's a separate `page.waitForNavigation()` promise to be resolved, you\n   * may end up with a race condition that yields unexpected results. The\n   * correct pattern for click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   page.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n   * @param selector - A `selector` to search for element to click. If there are\n   * multiple elements satisfying the `selector`, the first will be clicked\n   * @param options - `Object`\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully clicked. The Promise will be rejected if there is no element\n   * matching `selector`.\n   */\n  click(selector, options) {\n    return this.mainFrame().click(selector, options);\n  }\n  /**\n   * This method fetches an element with `selector` and focuses it. If there's no\n   * element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }\n   * of an element to focus. If there are multiple elements satisfying the\n   * selector, the first will be focused.\n   * @returns Promise which resolves when the element matching selector is\n   * successfully focused. The promise will be rejected if there is no element\n   * matching selector.\n   * @remarks\n   * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.\n   */\n  focus(selector) {\n    return this.mainFrame().focus(selector);\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.mouse}\n   * to hover over the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to search for element to hover. If there are multiple elements satisfying\n   * the selector, the first will be hovered.\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully hovered. Promise gets rejected if there's no element matching\n   * `selector`.\n   * @remarks\n   * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n   */\n  hover(selector) {\n    return this.mainFrame().hover(selector);\n  }\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * page.select('select#colors', 'blue'); // single selection\n   * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to query the page for\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first one\n   * is taken into account.\n   * @returns\n   *\n   * @remarks\n   * Shortcut for {@link Frame.select | page.mainFrame().select()}\n   */\n  select(selector, ...values) {\n    return this.mainFrame().select(selector, ...values);\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.touchscreen}\n   * to tap in the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to search for element to tap. If there are multiple elements satisfying the\n   * selector, the first will be tapped.\n   * @returns\n   * @remarks\n   * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n   */\n  tap(selector) {\n    return this.mainFrame().tap(selector);\n  }\n  /**\n   * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n   * in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n   * @example\n   *\n   * ```ts\n   * await page.type('#mytextarea', 'Hello');\n   * // Types instantly\n   * await page.type('#mytextarea', 'World', {delay: 100});\n   * // Types slower, like a user\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to type into. If there are multiple elements satisfying the\n   * selector, the first will be used.\n   * @param text - A text to type into a focused element.\n   * @param options - have property `delay` which is the Time to wait between\n   * key presses in milliseconds. Defaults to `0`.\n   * @returns\n   * @remarks\n   */\n  type(selector, text, options) {\n    return this.mainFrame().type(selector, text, options);\n  }\n  /**\n   * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.\n   *\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```ts\n   * await page.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n  waitForTimeout(milliseconds) {\n    return this.mainFrame().waitForTimeout(milliseconds);\n  }\n  /**\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately. If\n   * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigations:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by selector string\n   * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n   * selector is not found in DOM.\n   * @remarks\n   * The optional Parameter in Arguments `options` are:\n   *\n   * - `visible`: A boolean wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n   *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n   *   `false`.\n   *\n   * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n   *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n   *   by using the {@link Page.setDefaultTimeout} method.\n   */\n  async waitForSelector(selector, options = {}) {\n    return await this.mainFrame().waitForSelector(selector, options);\n  }\n  /**\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigation\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForXPath('//img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param xpath - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an\n   * element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by xpath string is\n   * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is\n   * not found in DOM, otherwise resolves to `ElementHandle`.\n   * @remarks\n   * The optional Argument `options` have properties:\n   *\n   * - `visible`: A boolean to wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: A boolean wait for element to not be found in the DOM or to be\n   *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *   Defaults to `false`.\n   *\n   * - `timeout`: A number which is maximum time to wait for in milliseconds.\n   *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default\n   *   value can be changed by using the {@link Page.setDefaultTimeout} method.\n   */\n  waitForXPath(xpath, options) {\n    return this.mainFrame().waitForXPath(xpath, options);\n  }\n  /**\n   * Waits for a function to finish evaluating in the page's context.\n   *\n   * @example\n   * The {@link Page.waitForFunction} can be used to observe viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n   *   await page.setViewport({width: 50, height: 50});\n   *   await watchDog;\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * To pass arguments from node.js to the predicate of\n   * {@link Page.waitForFunction} function:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await page.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {},\n   *   selector\n   * );\n   * ```\n   *\n   * @example\n   * The predicate of {@link Page.waitForFunction} can be asynchronous too:\n   *\n   * ```ts\n   * const username = 'github-username';\n   * await page.waitForFunction(\n   *   async username => {\n   *     const githubResponse = await fetch(\n   *       `https://api.github.com/users/${username}`\n   *     );\n   *     const githubUser = await githubResponse.json();\n   *     // show the avatar\n   *     const img = document.createElement('img');\n   *     img.src = githubUser.avatar_url;\n   *     // wait 3 seconds\n   *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n   *     img.remove();\n   *   },\n   *   {},\n   *   username\n   * );\n   * ```\n   *\n   * @param pageFunction - Function to be evaluated in browser context\n   * @param options - Options for configuring waiting behavior.\n   */\n  waitForFunction(pageFunction, options, ...args) {\n    return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n  }\n  waitForDevicePrompt() {\n    throw new Error('Not implemented');\n  }\n}\n/**\n * @internal\n */\nexport const supportedMetrics = new Set(['Timestamp', 'Documents', 'Frames', 'JSEventListeners', 'Nodes', 'LayoutCount', 'RecalcStyleCount', 'LayoutDuration', 'RecalcStyleDuration', 'ScriptDuration', 'TaskDuration', 'JSHeapUsedSize', 'JSHeapTotalSize']);\n/**\n * @internal\n */\nexport const unitToPixels = {\n  px: 1,\n  in: 96,\n  cm: 37.8,\n  mm: 3.78\n};\nfunction convertPrintParameterToInches(parameter, lengthUnit = 'in') {\n  if (typeof parameter === 'undefined') {\n    return undefined;\n  }\n  let pixels;\n  if (isNumber(parameter)) {\n    // Treat numbers as pixel values to be aligned with phantom's paperSize.\n    pixels = parameter;\n  } else if (isString(parameter)) {\n    const text = parameter;\n    let unit = text.substring(text.length - 2).toLowerCase();\n    let valueText = '';\n    if (unit in unitToPixels) {\n      valueText = text.substring(0, text.length - 2);\n    } else {\n      // In case of unknown unit try to parse the whole parameter as number of pixels.\n      // This is consistent with phantom's paperSize behavior.\n      unit = 'px';\n      valueText = text;\n    }\n    const value = Number(valueText);\n    assert(!isNaN(value), 'Failed to parse parameter value: ' + text);\n    pixels = value * unitToPixels[unit];\n  } else {\n    throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);\n  }\n  return pixels / unitToPixels[lengthUnit];\n}","map":{"version":3,"names":["EventEmitter","NetworkManagerEmittedEvents","paperFormats","importFSPromises","isNumber","isString","waitForEvent","withSourcePuppeteerURLIfNone","assert","Deferred","FunctionLocator","Locator","NodeLocator","Page","handlerMap","WeakMap","constructor","isServiceWorkerBypassed","Error","isDragInterceptionEnabled","isJavaScriptEnabled","on","eventName","handler","wrap","get","event","enqueueInterceptAction","set","once","off","waitForFileChooser","setGeolocation","target","browser","browserContext","mainFrame","createCDPSession","keyboard","touchscreen","coverage","tracing","accessibility","frames","workers","setRequestInterception","setBypassServiceWorker","setDragInterception","setOfflineMode","emulateNetworkConditions","setDefaultNavigationTimeout","setDefaultTimeout","getDefaultTimeout","locator","selectorOrFunc","create","locatorRace","locators","race","$","selector","$$","evaluateHandle","queryObjects","$eval","pageFunction","args","name","$$eval","$x","expression","cookies","deleteCookie","setCookie","addScriptTag","options","addStyleTag","exposeFunction","removeExposedFunction","authenticate","setExtraHTTPHeaders","setUserAgent","metrics","url","content","setContent","goto","reload","waitForNavigation","waitForRequest","waitForResponse","waitForNetworkIdle","_waitForNetworkIdle","networkManager","idleTime","timeout","closedDeferred","idleDeferred","abortDeferred","idleTimer","cleanup","clearTimeout","reject","evaluate","inFlightRequestsCount","setTimeout","resolve","listenToEvent","eventPromises","Request","Response","RequestFailed","closedPromise","valueOrThrow","then","r","error","waitForFrame","goBack","goForward","bringToFront","emulate","device","Promise","all","userAgent","setViewport","viewport","setJavaScriptEnabled","setBypassCSP","emulateMediaType","emulateCPUThrottling","emulateMediaFeatures","emulateTimezone","emulateIdleState","emulateVisionDeficiency","evaluateOnNewDocument","removeScriptToEvaluateOnNewDocument","setCacheEnabled","_maybeWriteBufferToFile","path","buffer","fs","writeFile","screenshot","_getPDFOptions","lengthUnit","defaults","scale","displayHeaderFooter","headerTemplate","footerTemplate","printBackground","landscape","pageRanges","preferCSSPageSize","omitBackground","width","height","format","toLowerCase","convertPrintParameterToInches","margin","top","left","bottom","right","output","createPDFStream","pdf","title","close","isClosed","mouse","click","focus","hover","select","values","tap","type","text","waitForTimeout","milliseconds","waitForSelector","waitForXPath","xpath","waitForFunction","waitForDevicePrompt","supportedMetrics","Set","unitToPixels","px","in","cm","mm","parameter","undefined","pixels","unit","substring","length","valueText","value","Number","isNaN"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/api/Page.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Readable} from 'stream';\n\nimport {Protocol} from 'devtools-protocol';\n\nimport type {HTTPRequest} from '../api/HTTPRequest.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {Accessibility} from '../common/Accessibility.js';\nimport type {CDPSession} from '../common/Connection.js';\nimport type {ConsoleMessage} from '../common/ConsoleMessage.js';\nimport type {Coverage} from '../common/Coverage.js';\nimport {Device} from '../common/Device.js';\nimport {DeviceRequestPrompt} from '../common/DeviceRequestPrompt.js';\nimport {TargetCloseError} from '../common/Errors.js';\nimport {EventEmitter, Handler} from '../common/EventEmitter.js';\nimport type {FileChooser} from '../common/FileChooser.js';\nimport type {WaitForSelectorOptions} from '../common/IsolatedWorld.js';\nimport type {PuppeteerLifeCycleEvent} from '../common/LifecycleWatcher.js';\nimport {\n  Credentials,\n  NetworkConditions,\n  NetworkManagerEmittedEvents,\n} from '../common/NetworkManager.js';\nimport {\n  LowerCasePaperFormat,\n  paperFormats,\n  ParsedPDFOptions,\n  PDFOptions,\n} from '../common/PDFOptions.js';\nimport type {Viewport} from '../common/PuppeteerViewport.js';\nimport type {Tracing} from '../common/Tracing.js';\nimport type {\n  Awaitable,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  NodeFor,\n} from '../common/types.js';\nimport {\n  importFSPromises,\n  isNumber,\n  isString,\n  waitForEvent,\n  withSourcePuppeteerURLIfNone,\n} from '../common/util.js';\nimport type {WebWorker} from '../common/WebWorker.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\n\nimport type {Browser} from './Browser.js';\nimport type {BrowserContext} from './BrowserContext.js';\nimport type {Dialog} from './Dialog.js';\nimport type {ClickOptions, ElementHandle} from './ElementHandle.js';\nimport type {\n  Frame,\n  FrameAddScriptTagOptions,\n  FrameAddStyleTagOptions,\n  FrameWaitForFunctionOptions,\n} from './Frame.js';\nimport {Keyboard, KeyboardTypeOptions, Mouse, Touchscreen} from './Input.js';\nimport type {JSHandle} from './JSHandle.js';\nimport {\n  AwaitedLocator,\n  FunctionLocator,\n  Locator,\n  NodeLocator,\n} from './locators/locators.js';\nimport type {Target} from './Target.js';\n\n/**\n * @public\n */\nexport interface Metrics {\n  Timestamp?: number;\n  Documents?: number;\n  Frames?: number;\n  JSEventListeners?: number;\n  Nodes?: number;\n  LayoutCount?: number;\n  RecalcStyleCount?: number;\n  LayoutDuration?: number;\n  RecalcStyleDuration?: number;\n  ScriptDuration?: number;\n  TaskDuration?: number;\n  JSHeapUsedSize?: number;\n  JSHeapTotalSize?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitTimeoutOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass 0 to disable the timeout.\n   *\n   * The default value can be changed by using the\n   * {@link Page.setDefaultTimeout} method.\n   *\n   * @defaultValue `30000`\n   */\n  timeout?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitForOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass 0 to disable the timeout.\n   *\n   * The default value can be changed by using the\n   * {@link Page.setDefaultTimeout} or {@link Page.setDefaultNavigationTimeout}\n   * methods.\n   *\n   * @defaultValue `30000`\n   */\n  timeout?: number;\n  waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n}\n\n/**\n * @public\n */\nexport interface GeolocationOptions {\n  /**\n   * Latitude between `-90` and `90`.\n   */\n  longitude: number;\n  /**\n   * Longitude between `-180` and `180`.\n   */\n  latitude: number;\n  /**\n   * Optional non-negative accuracy value.\n   */\n  accuracy?: number;\n}\n\n/**\n * @public\n */\nexport interface MediaFeature {\n  name: string;\n  value: string;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotClip {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  /**\n   * @defaultValue `1`\n   */\n  scale?: number;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotOptions {\n  /**\n   * @defaultValue `false`\n   */\n  optimizeForSpeed?: boolean;\n  /**\n   * @defaultValue `png`\n   */\n  type?: 'png' | 'jpeg' | 'webp';\n  /**\n   * The file path to save the image to. The screenshot type will be inferred\n   * from file extension. If path is a relative path, then it is resolved\n   * relative to current working directory. If no path is provided, the image\n   * won't be saved to the disk.\n   */\n  path?: string;\n  /**\n   * When `true`, takes a screenshot of the full page.\n   * @defaultValue `false`\n   */\n  fullPage?: boolean;\n  /**\n   * An object which specifies the clipping region of the page.\n   */\n  clip?: ScreenshotClip;\n  /**\n   * Quality of the image, between 0-100. Not applicable to `png` images.\n   */\n  quality?: number;\n  /**\n   * Hides default white background and allows capturing screenshots with transparency.\n   * @defaultValue `false`\n   */\n  omitBackground?: boolean;\n  /**\n   * Encoding of the image.\n   * @defaultValue `binary`\n   */\n  encoding?: 'base64' | 'binary';\n  /**\n   * Capture the screenshot beyond the viewport.\n   * @defaultValue `true`\n   */\n  captureBeyondViewport?: boolean;\n  /**\n   * Capture the screenshot from the surface, rather than the view.\n   * @defaultValue `true`\n   */\n  fromSurface?: boolean;\n}\n\n/**\n * All the events that a page instance may emit.\n *\n * @public\n */\nexport const enum PageEmittedEvents {\n  /**\n   * Emitted when the page closes.\n   */\n  Close = 'close',\n  /**\n   * Emitted when JavaScript within the page calls one of console API methods,\n   * e.g. `console.log` or `console.dir`. Also emitted if the page throws an\n   * error or a warning.\n   *\n   * @remarks\n   * A `console` event provides a {@link ConsoleMessage} representing the\n   * console message that was logged.\n   *\n   * @example\n   * An example of handling `console` event:\n   *\n   * ```ts\n   * page.on('console', msg => {\n   *   for (let i = 0; i < msg.args().length; ++i)\n   *     console.log(`${i}: ${msg.args()[i]}`);\n   * });\n   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));\n   * ```\n   */\n  Console = 'console',\n  /**\n   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`,\n   * `confirm` or `beforeunload`. Puppeteer can respond to the dialog via\n   * {@link Dialog.accept} or {@link Dialog.dismiss}.\n   */\n  Dialog = 'dialog',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded | DOMContentLoaded }\n   * event is dispatched.\n   */\n  DOMContentLoaded = 'domcontentloaded',\n  /**\n   * Emitted when the page crashes. Will contain an `Error`.\n   */\n  Error = 'error',\n  /** Emitted when a frame is attached. Will contain a {@link Frame}. */\n  FrameAttached = 'frameattached',\n  /** Emitted when a frame is detached. Will contain a {@link Frame}. */\n  FrameDetached = 'framedetached',\n  /**\n   * Emitted when a frame is navigated to a new URL. Will contain a\n   * {@link Frame}.\n   */\n  FrameNavigated = 'framenavigated',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/load | load}\n   * event is dispatched.\n   */\n  Load = 'load',\n  /**\n   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For\n   * the list of metrics see {@link Page.metrics | page.metrics}.\n   *\n   * @remarks\n   * Contains an object with two properties:\n   *\n   * - `title`: the title passed to `console.timeStamp`\n   * - `metrics`: object containing metrics as key/value pairs. The values will\n   *   be `number`s.\n   */\n  Metrics = 'metrics',\n  /**\n   * Emitted when an uncaught exception happens within the page. Contains an\n   * `Error`.\n   */\n  PageError = 'pageerror',\n  /**\n   * Emitted when the page opens a new tab or window.\n   *\n   * Contains a {@link Page} corresponding to the popup window.\n   *\n   * @example\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.click('a[target=_blank]'),\n   * ]);\n   * ```\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.evaluate(() => window.open('https://example.com')),\n   * ]);\n   * ```\n   */\n  Popup = 'popup',\n  /**\n   * Emitted when a page issues a request and contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * The object is readonly. See {@link Page.setRequestInterception} for\n   * intercepting and mutating requests.\n   */\n  Request = 'request',\n  /**\n   * Emitted when a request ended up loading from cache. Contains a\n   * {@link HTTPRequest}.\n   *\n   * @remarks\n   * For certain requests, might contain undefined.\n   * {@link https://crbug.com/750469}\n   */\n  RequestServedFromCache = 'requestservedfromcache',\n  /**\n   * Emitted when a request fails, for example by timing out.\n   *\n   * Contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * HTTP Error responses, such as 404 or 503, are still successful responses\n   * from HTTP standpoint, so request will complete with `requestfinished` event\n   * and not with `requestfailed`.\n   */\n  RequestFailed = 'requestfailed',\n  /**\n   * Emitted when a request finishes successfully. Contains a\n   * {@link HTTPRequest}.\n   */\n  RequestFinished = 'requestfinished',\n  /**\n   * Emitted when a response is received. Contains a {@link HTTPResponse}.\n   */\n  Response = 'response',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is spawned by the page.\n   */\n  WorkerCreated = 'workercreated',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is destroyed by the page.\n   */\n  WorkerDestroyed = 'workerdestroyed',\n}\n\n/**\n * Denotes the objects received by callback functions for page events.\n *\n * See {@link PageEmittedEvents} for more detail on the events and when they are\n * emitted.\n *\n * @public\n */\nexport interface PageEventObject {\n  close: never;\n  console: ConsoleMessage;\n  dialog: Dialog;\n  domcontentloaded: never;\n  error: Error;\n  frameattached: Frame;\n  framedetached: Frame;\n  framenavigated: Frame;\n  load: never;\n  metrics: {title: string; metrics: Metrics};\n  pageerror: Error;\n  popup: Page;\n  request: HTTPRequest;\n  response: HTTPResponse;\n  requestfailed: HTTPRequest;\n  requestfinished: HTTPRequest;\n  requestservedfromcache: HTTPRequest;\n  workercreated: WebWorker;\n  workerdestroyed: WebWorker;\n}\n\n/**\n * @public\n */\nexport interface NewDocumentScriptEvaluation {\n  identifier: string;\n}\n\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEmittedEvents} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link Page.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nexport class Page extends EventEmitter {\n  #handlerMap = new WeakMap<Handler<any>, Handler<any>>();\n\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * `true` if the service worker are being bypassed, `false` otherwise.\n   */\n  isServiceWorkerBypassed(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * `true` if drag events are being intercepted, `false` otherwise.\n   */\n  isDragInterceptionEnabled(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * `true` if the page has JavaScript enabled, `false` otherwise.\n   */\n  isJavaScriptEnabled(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Listen to page events.\n   *\n   * :::note\n   *\n   * This method exists to define event typings and handle proper wireup of\n   * cooperative request interception. Actual event listening and dispatching is\n   * delegated to {@link EventEmitter}.\n   *\n   * :::\n   */\n  override on<K extends keyof PageEventObject>(\n    eventName: K,\n    handler: (event: PageEventObject[K]) => void\n  ): this {\n    if (eventName === 'request') {\n      const wrap =\n        this.#handlerMap.get(handler) ||\n        ((event: HTTPRequest) => {\n          event.enqueueInterceptAction(() => {\n            return handler(event as PageEventObject[K]);\n          });\n        });\n\n      this.#handlerMap.set(handler, wrap);\n\n      return super.on(eventName, wrap);\n    }\n    return super.on(eventName, handler);\n  }\n\n  override once<K extends keyof PageEventObject>(\n    eventName: K,\n    handler: (event: PageEventObject[K]) => void\n  ): this {\n    // Note: this method only exists to define the types; we delegate the impl\n    // to EventEmitter.\n    return super.once(eventName, handler);\n  }\n\n  override off<K extends keyof PageEventObject>(\n    eventName: K,\n    handler: (event: PageEventObject[K]) => void\n  ): this {\n    if (eventName === 'request') {\n      handler = this.#handlerMap.get(handler) || handler;\n    }\n\n    return super.off(eventName, handler);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers file\n   * choosing.\n   *\n   * :::caution\n   *\n   * This must be called before the file chooser is launched. It will not return\n   * a currently active file chooser.\n   *\n   * :::\n   *\n   * @remarks\n   * In the \"headful\" browser, this method results in the native file picker\n   * dialog `not showing up` for the user.\n   *\n   * @example\n   * The following example clicks a button that issues a file chooser\n   * and then responds with `/tmp/myfile.pdf` as if a user has selected this file.\n   *\n   * ```ts\n   * const [fileChooser] = await Promise.all([\n   *   page.waitForFileChooser(),\n   *   page.click('#upload-file-button'),\n   *   // some button that triggers file selection\n   * ]);\n   * await fileChooser.accept(['/tmp/myfile.pdf']);\n   * ```\n   */\n  waitForFileChooser(options?: WaitTimeoutOptions): Promise<FileChooser>;\n  waitForFileChooser(): Promise<FileChooser> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Sets the page's geolocation.\n   *\n   * @remarks\n   * Consider using {@link BrowserContext.overridePermissions} to grant\n   * permissions for the page to read its geolocation.\n   *\n   * @example\n   *\n   * ```ts\n   * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});\n   * ```\n   */\n  async setGeolocation(options: GeolocationOptions): Promise<void>;\n  async setGeolocation(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * A target this page was created from.\n   */\n  target(): Target {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Get the browser the page belongs to.\n   */\n  browser(): Browser {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Get the browser context that the page belongs to.\n   */\n  browserContext(): BrowserContext {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The page's main frame.\n   *\n   * @remarks\n   * Page is guaranteed to have a main frame which persists during navigations.\n   */\n  mainFrame(): Frame {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Creates a Chrome Devtools Protocol session attached to the page.\n   */\n  createCDPSession(): Promise<CDPSession> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Keyboard}\n   */\n  get keyboard(): Keyboard {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Touchscreen}\n   */\n  get touchscreen(): Touchscreen {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Coverage}\n   */\n  get coverage(): Coverage {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Tracing}\n   */\n  get tracing(): Tracing {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Accessibility}\n   */\n  get accessibility(): Accessibility {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * An array of all frames attached to the page.\n   */\n  frames(): Frame[] {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * All of the dedicated {@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n   * WebWorkers} associated with the page.\n   *\n   * @remarks\n   * This does not contain ServiceWorkers\n   */\n  workers(): WebWorker[] {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Activating request interception enables {@link HTTPRequest.abort},\n   * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods. This\n   * provides the capability to modify network requests that are made by a page.\n   *\n   * Once request interception is enabled, every request will stall unless it's\n   * continued, responded or aborted; or completed using the browser cache.\n   *\n   * See the\n   * {@link https://pptr.dev/next/guides/request-interception|Request interception guide}\n   * for more details.\n   *\n   * @example\n   * An example of a nave request interceptor that aborts all image requests:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.setRequestInterception(true);\n   *   page.on('request', interceptedRequest => {\n   *     if (\n   *       interceptedRequest.url().endsWith('.png') ||\n   *       interceptedRequest.url().endsWith('.jpg')\n   *     )\n   *       interceptedRequest.abort();\n   *     else interceptedRequest.continue();\n   *   });\n   *   await page.goto('https://example.com');\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param value - Whether to enable request interception.\n   */\n  async setRequestInterception(value: boolean): Promise<void>;\n  async setRequestInterception(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Toggles ignoring of service worker for each request.\n   *\n   * @param bypass - Whether to bypass service worker and load from network.\n   */\n  async setBypassServiceWorker(bypass: boolean): Promise<void>;\n  async setBypassServiceWorker(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param enabled - Whether to enable drag interception.\n   *\n   * @remarks\n   * Activating drag interception enables the `Input.drag`,\n   * methods This provides the capability to capture drag events emitted\n   * on the page, which can then be used to simulate drag-and-drop.\n   */\n  async setDragInterception(enabled: boolean): Promise<void>;\n  async setDragInterception(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Sets the network connection to offline.\n   *\n   * It does not change the parameters used in {@link Page.emulateNetworkConditions}\n   *\n   * @param enabled - When `true`, enables offline mode for the page.\n   */\n  setOfflineMode(enabled: boolean): Promise<void>;\n  setOfflineMode(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This does not affect WebSockets and WebRTC PeerConnections (see\n   * https://crbug.com/563644). To set the page offline, you can use\n   * {@link Page.setOfflineMode}.\n   *\n   * A list of predefined network conditions can be used by importing\n   * {@link PredefinedNetworkConditions}.\n   *\n   * @example\n   *\n   * ```ts\n   * import {PredefinedNetworkConditions} from 'puppeteer';\n   * const slow3G = PredefinedNetworkConditions['Slow 3G'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulateNetworkConditions(slow3G);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param networkConditions - Passing `null` disables network condition\n   * emulation.\n   */\n  emulateNetworkConditions(\n    networkConditions: NetworkConditions | null\n  ): Promise<void>;\n  emulateNetworkConditions(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This setting will change the default maximum navigation time for the\n   * following methods and related shortcuts:\n   *\n   * - {@link Page.goBack | page.goBack(options)}\n   *\n   * - {@link Page.goForward | page.goForward(options)}\n   *\n   * - {@link Page.goto | page.goto(url,options)}\n   *\n   * - {@link Page.reload | page.reload(options)}\n   *\n   * - {@link Page.setContent | page.setContent(html,options)}\n   *\n   * - {@link Page.waitForNavigation | page.waitForNavigation(options)}\n   *   @param timeout - Maximum navigation time in milliseconds.\n   */\n  setDefaultNavigationTimeout(timeout: number): void;\n  setDefaultNavigationTimeout(): void {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param timeout - Maximum time in milliseconds.\n   */\n  setDefaultTimeout(timeout: number): void;\n  setDefaultTimeout(): void {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Maximum time in milliseconds.\n   */\n  getDefaultTimeout(): number {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Creates a locator for the provided selector. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Selector extends string>(\n    selector: Selector\n  ): Locator<NodeFor<Selector>>;\n\n  /**\n   * Creates a locator for the provided function. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Ret>(func: () => Awaitable<Ret>): Locator<Ret>;\n  locator<Selector extends string, Ret>(\n    selectorOrFunc: Selector | (() => Awaitable<Ret>)\n  ): Locator<NodeFor<Selector>> | Locator<Ret> {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n\n  /**\n   * A shortcut for {@link Locator.race} that does not require static imports.\n   *\n   * @internal\n   */\n  locatorRace<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return Locator.race(locators);\n  }\n\n  /**\n   * Runs `document.querySelector` within the page. If no element matches the\n   * selector, the return value resolves to `null`.\n   *\n   * @param selector - A `selector` to query page for\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query page for.\n   */\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return this.mainFrame().$(selector);\n  }\n\n  /**\n   * The method runs `document.querySelectorAll` within the page. If no elements\n   * match the selector, the return value resolves to `[]`.\n   * @remarks\n   * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n   * @param selector - A `selector` to query page for\n   */\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    return this.mainFrame().$$(selector);\n  }\n\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Page.evaluate | page.evaluate} and\n   * `page.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * If the function passed to `page.evaluateHandle` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle('document');\n   * ```\n   *\n   * @example\n   * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle(() => document.body);\n   * const resultHandle = await page.evaluateHandle(\n   *   body => body.innerHTML,\n   *   aHandle\n   * );\n   * console.log(await resultHandle.jsonValue());\n   * await resultHandle.dispose();\n   * ```\n   *\n   * Most of the time this function returns a {@link JSHandle},\n   * but if `pageFunction` returns a reference to an element,\n   * you instead get an {@link ElementHandle} back:\n   *\n   * @example\n   *\n   * ```ts\n   * const button = await page.evaluateHandle(() =>\n   *   document.querySelector('button')\n   * );\n   * // can call `click` because `button` is an `ElementHandle`\n   * await button.click();\n   * ```\n   *\n   * The TypeScript definitions assume that `evaluateHandle` returns\n   * a `JSHandle`, but if you know it's going to return an\n   * `ElementHandle`, pass it as the generic argument:\n   *\n   * ```ts\n   * const button = await page.evaluateHandle<ElementHandle>(...);\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method iterates the JavaScript heap and finds all objects with the\n   * given prototype.\n   *\n   * @example\n   *\n   * ```ts\n   * // Create a Map object\n   * await page.evaluate(() => (window.map = new Map()));\n   * // Get a handle to the Map object prototype\n   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n   * // Query all map instances into an array\n   * const mapInstances = await page.queryObjects(mapPrototype);\n   * // Count amount of map objects in heap\n   * const count = await page.evaluate(maps => maps.length, mapInstances);\n   * await mapInstances.dispose();\n   * await mapPrototype.dispose();\n   * ```\n   *\n   * @param prototypeHandle - a handle to the object prototype.\n   * @returns Promise which resolves to a handle to an array of objects with\n   * this prototype.\n   */\n  async queryObjects<Prototype>(\n    prototypeHandle: JSHandle<Prototype>\n  ): Promise<JSHandle<Prototype[]>>;\n  async queryObjects<Prototype>(): Promise<JSHandle<Prototype[]>> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method runs `document.querySelector` within the page and passes the\n   * result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   *\n   * If no element is found matching `selector`, the method will throw an error.\n   *\n   * If `pageFunction` returns a promise `$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await page.$eval('#search', el => el.value);\n   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n   * const html = await page.$eval('.main-container', el => el.outerHTML);\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * const searchValue = await page.$eval(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const searchValue = await page.$eval<string>(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of `document.querySelector(selector)` as its\n   * first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    return this.mainFrame().$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the page and passes the result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * // get the amount of divs on the page\n   * const divCount = await page.$$eval('div', divs => divs.length);\n   *\n   * // get the text content of all the `.options` elements:\n   * const options = await page.$$eval('div > span.options', options => {\n   *   return options.map(option => option.textContent);\n   * });\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element[]`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n   *   return elements.map(e => e.value);\n   * });\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const allInputValues = await page.$$eval<string[]>(\n   *   'input',\n   *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of\n   * `Array.from(document.querySelectorAll(selector))` as its first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    return this.mainFrame().$$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * The method evaluates the XPath expression relative to the page document as\n   * its context node. If there are no such elements, the method resolves to an\n   * empty array.\n   *\n   * @remarks\n   * Shortcut for {@link Frame.$x | Page.mainFrame().$x(expression) }.\n   *\n   * @param expression - Expression to evaluate\n   */\n  async $x(expression: string): Promise<Array<ElementHandle<Node>>> {\n    return this.mainFrame().$x(expression);\n  }\n\n  /**\n   * If no URLs are specified, this method returns cookies for the current page\n   * URL. If URLs are specified, only cookies for those URLs are returned.\n   */\n  async cookies(...urls: string[]): Promise<Protocol.Network.Cookie[]>;\n  async cookies(): Promise<Protocol.Network.Cookie[]> {\n    throw new Error('Not implemented');\n  }\n\n  async deleteCookie(\n    ...cookies: Protocol.Network.DeleteCookiesRequest[]\n  ): Promise<void>;\n  async deleteCookie(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @example\n   *\n   * ```ts\n   * await page.setCookie(cookieObject1, cookieObject2);\n   * ```\n   */\n  async setCookie(...cookies: Protocol.Network.CookieParam[]): Promise<void>;\n  async setCookie(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Adds a `<script>` tag into the page with the desired URL or content.\n   *\n   * @remarks\n   * Shortcut for\n   * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  async addScriptTag(\n    options: FrameAddScriptTagOptions\n  ): Promise<ElementHandle<HTMLScriptElement>> {\n    return this.mainFrame().addScriptTag(options);\n  }\n\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired URL or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * Shortcut for\n   * {@link Frame.(addStyleTag:2) | page.mainFrame().addStyleTag(options)}.\n   *\n   * @returns An {@link ElementHandle | element handle} to the injected `<link>`\n   * or `<style>` element.\n   */\n  async addStyleTag(\n    options: Omit<FrameAddStyleTagOptions, 'url'>\n  ): Promise<ElementHandle<HTMLStyleElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLLinkElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLStyleElement | HTMLLinkElement>> {\n    return this.mainFrame().addStyleTag(options);\n  }\n\n  /**\n   * The method adds a function called `name` on the page's `window` object.\n   * When called, the function executes `puppeteerFunction` in node.js and\n   * returns a `Promise` which resolves to the return value of\n   * `puppeteerFunction`.\n   *\n   * If the puppeteerFunction returns a `Promise`, it will be awaited.\n   *\n   * :::note\n   *\n   * Functions installed via `page.exposeFunction` survive navigations.\n   *\n   * :::note\n   *\n   * @example\n   * An example of adding an `md5` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import crypto from 'crypto';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('md5', text =>\n   *     crypto.createHash('md5').update(text).digest('hex')\n   *   );\n   *   await page.evaluate(async () => {\n   *     // use window.md5 to compute hashes\n   *     const myString = 'PUPPETEER';\n   *     const myHash = await window.md5(myString);\n   *     console.log(`md5 of ${myString} is ${myHash}`);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * An example of adding a `window.readfile` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import fs from 'fs';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('readfile', async filePath => {\n   *     return new Promise((resolve, reject) => {\n   *       fs.readFile(filePath, 'utf8', (err, text) => {\n   *         if (err) reject(err);\n   *         else resolve(text);\n   *       });\n   *     });\n   *   });\n   *   await page.evaluate(async () => {\n   *     // use window.readfile to read contents of a file\n   *     const content = await window.readfile('/etc/hosts');\n   *     console.log(content);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param name - Name of the function on the window object\n   * @param pptrFunction - Callback function which will be called in Puppeteer's\n   * context.\n   */\n  async exposeFunction(\n    name: string,\n    pptrFunction: Function | {default: Function}\n  ): Promise<void>;\n  async exposeFunction(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The method removes a previously added function via ${@link Page.exposeFunction}\n   * called `name` from the page's `window` object.\n   */\n  async removeExposedFunction(name: string): Promise<void>;\n  async removeExposedFunction(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Provide credentials for `HTTP authentication`.\n   *\n   * @remarks\n   * To disable authentication, pass `null`.\n   */\n  async authenticate(credentials: Credentials): Promise<void>;\n  async authenticate(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The extra HTTP headers will be sent with every request the page initiates.\n   *\n   * :::tip\n   *\n   * All HTTP header names are lowercased. (HTTP headers are\n   * case-insensitive, so this shouldnt impact your server code.)\n   *\n   * :::\n   *\n   * :::note\n   *\n   * page.setExtraHTTPHeaders does not guarantee the order of headers in\n   * the outgoing requests.\n   *\n   * :::\n   *\n   * @param headers - An object containing additional HTTP headers to be sent\n   * with every request. All header values must be strings.\n   */\n  async setExtraHTTPHeaders(headers: Record<string, string>): Promise<void>;\n  async setExtraHTTPHeaders(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param userAgent - Specific user agent to use in this page\n   * @param userAgentData - Specific user agent client hint data to use in this\n   * page\n   * @returns Promise which resolves when the user agent is set.\n   */\n  async setUserAgent(\n    userAgent: string,\n    userAgentMetadata?: Protocol.Emulation.UserAgentMetadata\n  ): Promise<void>;\n  async setUserAgent(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Object containing metrics as key/value pairs.\n   *\n   * @returns\n   *\n   * - `Timestamp` : The timestamp when the metrics sample was taken.\n   *\n   * - `Documents` : Number of documents in the page.\n   *\n   * - `Frames` : Number of frames in the page.\n   *\n   * - `JSEventListeners` : Number of events in the page.\n   *\n   * - `Nodes` : Number of DOM nodes in the page.\n   *\n   * - `LayoutCount` : Total number of full or partial page layout.\n   *\n   * - `RecalcStyleCount` : Total number of page style recalculations.\n   *\n   * - `LayoutDuration` : Combined durations of all page layouts.\n   *\n   * - `RecalcStyleDuration` : Combined duration of all page style\n   *   recalculations.\n   *\n   * - `ScriptDuration` : Combined duration of JavaScript execution.\n   *\n   * - `TaskDuration` : Combined duration of all tasks performed by the browser.\n   *\n   * - `JSHeapUsedSize` : Used JavaScript heap size.\n   *\n   * - `JSHeapTotalSize` : Total JavaScript heap size.\n   *\n   * @remarks\n   * All timestamps are in monotonic time: monotonically increasing time\n   * in seconds since an arbitrary point in the past.\n   */\n  async metrics(): Promise<Metrics> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The page's URL.\n   * @remarks Shortcut for\n   * {@link Frame.url | page.mainFrame().url()}.\n   */\n  url(): string {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The full HTML contents of the page, including the DOCTYPE.\n   */\n  async content(): Promise<string> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Set the content of the page.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - Parameters that has some properties.\n   * @remarks\n   * The parameter `options` might have the following options.\n   *\n   * - `timeout` : Maximum time in milliseconds for resources to load, defaults\n   *   to 30 seconds, pass `0` to disable timeout. The default value can be\n   *   changed by using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider setting markup succeeded, defaults to\n   *   `load`. Given an array of event strings, setting content is considered\n   *   to be successful after all events have been fired. Events can be\n   *   either:<br/>\n   * - `load` : consider setting content to be finished when the `load` event\n   *   is fired.<br/>\n   * - `domcontentloaded` : consider setting content to be finished when the\n   *   `DOMContentLoaded` event is fired.<br/>\n   * - `networkidle0` : consider setting content to be finished when there are\n   *   no more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider setting content to be finished when there are\n   *   no more than 2 network connections for at least `500` ms.\n   */\n  async setContent(html: string, options?: WaitForOptions): Promise<void>;\n  async setContent(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param url - URL to navigate page to. The URL should include scheme, e.g.\n   * `https://`\n   * @param options - Navigation Parameter\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`:When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   *\n   * - `referer` : Referer header value. If provided it will take preference\n   *   over the referer header value set by\n   *   {@link Page.setExtraHTTPHeaders |page.setExtraHTTPHeaders()}.<br/>\n   * - `referrerPolicy` : ReferrerPolicy. If provided it will take preference\n   *   over the referer-policy header value set by\n   *   {@link Page.setExtraHTTPHeaders |page.setExtraHTTPHeaders()}.\n   *\n   * `page.goto` will throw an error if:\n   *\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   * - target URL is invalid.\n   * - the timeout is exceeded during navigation.\n   * - the remote server does not respond or is unreachable.\n   * - the main resource failed to load.\n   *\n   * `page.goto` will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500\n   * \"Internal Server Error\". The status code for such responses can be\n   * retrieved by calling response.status().\n   *\n   * NOTE: `page.goto` either throws an error or returns a main resource\n   * response. The only exceptions are navigation to about:blank or navigation\n   * to the same URL with a different hash, which would succeed and return null.\n   *\n   * NOTE: Headless mode doesn't support navigation to a PDF document. See the\n   * {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 |\n   * upstream issue}.\n   *\n   * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.\n   */\n  async goto(\n    url: string,\n    options?: WaitForOptions & {referer?: string; referrerPolicy?: string}\n  ): Promise<HTTPResponse | null>;\n  async goto(): Promise<HTTPResponse | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param options - Navigation parameters which might have the following\n   * properties:\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  async reload(options?: WaitForOptions): Promise<HTTPResponse | null>;\n  async reload(): Promise<HTTPResponse | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Waits for the page to navigate to a new URL or to reload. It is useful when\n   * you run code that will indirectly cause the page to navigate.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(), // The promise resolves after navigation has finished\n   *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n   * ]);\n   * ```\n   *\n   * @remarks\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @param options - Navigation parameters which might have the following\n   * properties:\n   * @returns A `Promise` which resolves to the main resource response.\n   *\n   * - In case of multiple redirects, the navigation will resolve with the\n   *   response of the last redirect.\n   * - In case of navigation to a different anchor or navigation due to History\n   *   API usage, the navigation will resolve with `null`.\n   */\n  async waitForNavigation(\n    options: WaitForOptions = {}\n  ): Promise<HTTPResponse | null> {\n    return await this.mainFrame().waitForNavigation(options);\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched request\n   * @example\n   *\n   * ```ts\n   * const firstRequest = await page.waitForRequest(\n   *   'https://example.com/resource'\n   * );\n   * const finalRequest = await page.waitForRequest(\n   *   request => request.url() === 'https://example.com'\n   * );\n   * return finalRequest.response()?.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Waiting Parameters have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass\n   *   `0` to disable the timeout. The default value can be changed by using the\n   *   {@link Page.setDefaultTimeout} method.\n   */\n  async waitForRequest(\n    urlOrPredicate: string | ((req: HTTPRequest) => boolean | Promise<boolean>),\n    options?: {timeout?: number}\n  ): Promise<HTTPRequest>;\n  async waitForRequest(): Promise<HTTPRequest> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for.\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched response.\n   * @example\n   *\n   * ```ts\n   * const firstResponse = await page.waitForResponse(\n   *   'https://example.com/resource'\n   * );\n   * const finalResponse = await page.waitForResponse(\n   *   response =>\n   *     response.url() === 'https://example.com' && response.status() === 200\n   * );\n   * const finalResponse = await page.waitForResponse(async response => {\n   *   return (await response.text()).includes('<html>');\n   * });\n   * return finalResponse.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Parameter have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n   *   pass `0` to disable the timeout. The default value can be changed by using\n   *   the {@link Page.setDefaultTimeout} method.\n   */\n  async waitForResponse(\n    urlOrPredicate:\n      | string\n      | ((res: HTTPResponse) => boolean | Promise<boolean>),\n    options?: {timeout?: number}\n  ): Promise<HTTPResponse>;\n  async waitForResponse(): Promise<HTTPResponse> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when network is idle\n   */\n  async waitForNetworkIdle(options?: {\n    idleTime?: number;\n    timeout?: number;\n  }): Promise<void>;\n  async waitForNetworkIdle(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  protected async _waitForNetworkIdle(\n    networkManager: EventEmitter & {\n      inFlightRequestsCount: () => number;\n    },\n    idleTime: number,\n    timeout: number,\n    closedDeferred: Deferred<TargetCloseError>\n  ): Promise<void> {\n    const idleDeferred = Deferred.create<void>();\n    const abortDeferred = Deferred.create<Error>();\n\n    let idleTimer: NodeJS.Timeout | undefined;\n    const cleanup = () => {\n      clearTimeout(idleTimer);\n      abortDeferred.reject(new Error('abort'));\n    };\n\n    const evaluate = () => {\n      clearTimeout(idleTimer);\n\n      if (networkManager.inFlightRequestsCount() === 0) {\n        idleTimer = setTimeout(() => {\n          return idleDeferred.resolve();\n        }, idleTime);\n      }\n    };\n\n    const listenToEvent = (event: symbol) => {\n      return waitForEvent(\n        networkManager,\n        event,\n        () => {\n          evaluate();\n          return false;\n        },\n        timeout,\n        abortDeferred\n      );\n    };\n\n    const eventPromises = [\n      listenToEvent(NetworkManagerEmittedEvents.Request),\n      listenToEvent(NetworkManagerEmittedEvents.Response),\n      listenToEvent(NetworkManagerEmittedEvents.RequestFailed),\n    ];\n\n    evaluate();\n\n    // We don't want to reject the closed deferred when\n    // the race if finished so we pass the Promise instead\n    const closedPromise = closedDeferred.valueOrThrow();\n\n    await Deferred.race([idleDeferred, ...eventPromises, closedPromise]).then(\n      r => {\n        cleanup();\n        return r;\n      },\n      error => {\n        cleanup();\n        throw error;\n      }\n    );\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for.\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched frame.\n   * @example\n   *\n   * ```ts\n   * const frame = await page.waitForFrame(async frame => {\n   *   return frame.name() === 'Test';\n   * });\n   * ```\n   *\n   * @remarks\n   * Optional Parameter have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n   *   pass `0` to disable the timeout. The default value can be changed by using\n   *   the {@link Page.setDefaultTimeout} method.\n   */\n  async waitForFrame(\n    urlOrPredicate: string | ((frame: Frame) => boolean | Promise<boolean>),\n    options?: {timeout?: number}\n  ): Promise<Frame>;\n  async waitForFrame(): Promise<Frame> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method navigate to the previous page in history.\n   * @param options - Navigation parameters\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go back, resolves to `null`.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil` : When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  async goBack(options?: WaitForOptions): Promise<HTTPResponse | null>;\n  async goBack(): Promise<HTTPResponse | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method navigate to the next page in history.\n   * @param options - Navigation Parameter\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go forward, resolves to `null`.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  async goForward(options?: WaitForOptions): Promise<HTTPResponse | null>;\n  async goForward(): Promise<HTTPResponse | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Brings page to front (activates tab).\n   */\n  async bringToFront(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Emulates a given device's metrics and user agent.\n   *\n   * To aid emulation, Puppeteer provides a list of known devices that can be\n   * via {@link KnownDevices}.\n   *\n   * @remarks\n   * This method is a shortcut for calling two methods:\n   * {@link Page.setUserAgent} and {@link Page.setViewport}.\n   *\n   * @remarks\n   * This method will resize the page. A lot of websites don't expect phones to\n   * change size, so you should emulate before navigating to the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import {KnownDevices} from 'puppeteer';\n   * const iPhone = KnownDevices['iPhone 6'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulate(iPhone);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   */\n  async emulate(device: Device): Promise<void> {\n    await Promise.all([\n      this.setUserAgent(device.userAgent),\n      this.setViewport(device.viewport),\n    ]);\n  }\n\n  /**\n   * @param enabled - Whether or not to enable JavaScript on the page.\n   * @remarks\n   * NOTE: changing this value won't affect scripts that have already been run.\n   * It will take full effect on the next navigation.\n   */\n  async setJavaScriptEnabled(enabled: boolean): Promise<void>;\n  async setJavaScriptEnabled(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Toggles bypassing page's Content-Security-Policy.\n   * @param enabled - sets bypassing of page's Content-Security-Policy.\n   * @remarks\n   * NOTE: CSP bypassing happens at the moment of CSP initialization rather than\n   * evaluation. Usually, this means that `page.setBypassCSP` should be called\n   * before navigating to the domain.\n   */\n  async setBypassCSP(enabled: boolean): Promise<void>;\n  async setBypassCSP(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param type - Changes the CSS media type of the page. The only allowed\n   * values are `screen`, `print` and `null`. Passing `null` disables CSS media\n   * emulation.\n   * @example\n   *\n   * ```ts\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * //  true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * //  false\n   *\n   * await page.emulateMediaType('print');\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * //  false\n   * await page.evaluate(() => matchMedia('print').matches);\n   * //  true\n   *\n   * await page.emulateMediaType(null);\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * //  true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * //  false\n   * ```\n   */\n  async emulateMediaType(type?: string): Promise<void>;\n  async emulateMediaType(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Enables CPU throttling to emulate slow CPUs.\n   * @param factor - slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).\n   */\n  async emulateCPUThrottling(factor: number | null): Promise<void>;\n  async emulateCPUThrottling(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param features - `<?Array<Object>>` Given an array of media feature\n   * objects, emulates CSS media features on the page. Each media feature object\n   * must have the following properties:\n   * @example\n   *\n   * ```ts\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * //  true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * //  false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * //  true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * //  false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * //  true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * //  false\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * //  true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * //  false\n   *\n   * await page.emulateMediaFeatures([{name: 'color-gamut', value: 'p3'}]);\n   * await page.evaluate(() => matchMedia('(color-gamut: srgb)').matches);\n   * //  true\n   * await page.evaluate(() => matchMedia('(color-gamut: p3)').matches);\n   * //  true\n   * await page.evaluate(() => matchMedia('(color-gamut: rec2020)').matches);\n   * //  false\n   * ```\n   */\n  async emulateMediaFeatures(features?: MediaFeature[]): Promise<void>;\n  async emulateMediaFeatures(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param timezoneId - Changes the timezone of the page. See\n   * {@link https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt | ICUs metaZones.txt}\n   * for a list of supported timezone IDs. Passing\n   * `null` disables timezone emulation.\n   */\n  async emulateTimezone(timezoneId?: string): Promise<void>;\n  async emulateTimezone(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Emulates the idle state.\n   * If no arguments set, clears idle state emulation.\n   *\n   * @example\n   *\n   * ```ts\n   * // set idle emulation\n   * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});\n   *\n   * // do some checks here\n   * ...\n   *\n   * // clear idle emulation\n   * await page.emulateIdleState();\n   * ```\n   *\n   * @param overrides - Mock idle state. If not set, clears idle overrides\n   */\n  async emulateIdleState(overrides?: {\n    isUserActive: boolean;\n    isScreenUnlocked: boolean;\n  }): Promise<void>;\n  async emulateIdleState(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Simulates the given vision deficiency on the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.goto('https://v8.dev/blog/10-years');\n   *\n   *   await page.emulateVisionDeficiency('achromatopsia');\n   *   await page.screenshot({path: 'achromatopsia.png'});\n   *\n   *   await page.emulateVisionDeficiency('deuteranopia');\n   *   await page.screenshot({path: 'deuteranopia.png'});\n   *\n   *   await page.emulateVisionDeficiency('blurredVision');\n   *   await page.screenshot({path: 'blurred-vision.png'});\n   *\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param type - the type of deficiency to simulate, or `'none'` to reset.\n   */\n  async emulateVisionDeficiency(\n    type?: Protocol.Emulation.SetEmulatedVisionDeficiencyRequest['type']\n  ): Promise<void>;\n  async emulateVisionDeficiency(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * `page.setViewport` will resize the page. A lot of websites don't expect\n   * phones to change size, so you should set the viewport before navigating to\n   * the page.\n   *\n   * In the case of multiple pages in a single browser, each page can have its\n   * own viewport size.\n   * @example\n   *\n   * ```ts\n   * const page = await browser.newPage();\n   * await page.setViewport({\n   *   width: 640,\n   *   height: 480,\n   *   deviceScaleFactor: 1,\n   * });\n   * await page.goto('https://example.com');\n   * ```\n   *\n   * @param viewport -\n   * @remarks\n   * Argument viewport have following properties:\n   *\n   * - `width`: page width in pixels. required\n   *\n   * - `height`: page height in pixels. required\n   *\n   * - `deviceScaleFactor`: Specify device scale factor (can be thought of as\n   *   DPR). Defaults to `1`.\n   *\n   * - `isMobile`: Whether the meta viewport tag is taken into account. Defaults\n   *   to `false`.\n   *\n   * - `hasTouch`: Specifies if viewport supports touch events. Defaults to `false`\n   *\n   * - `isLandScape`: Specifies if viewport is in landscape mode. Defaults to false.\n   *\n   * NOTE: in certain cases, setting viewport will reload the page in order to\n   * set the isMobile or hasTouch properties.\n   */\n  async setViewport(viewport: Viewport): Promise<void>;\n  async setViewport(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Current page viewport settings.\n   *\n   * @returns\n   *\n   * - `width`: page's width in pixels\n   *\n   * - `height`: page's height in pixels\n   *\n   * - `deviceScaleFactor`: Specify device scale factor (can be though of as\n   *   dpr). Defaults to `1`.\n   *\n   * - `isMobile`: Whether the meta viewport tag is taken into account. Defaults\n   *   to `false`.\n   *\n   * - `hasTouch`: Specifies if viewport supports touch events. Defaults to\n   *   `false`.\n   *\n   * - `isLandScape`: Specifies if viewport is in landscape mode. Defaults to\n   *   `false`.\n   */\n  viewport(): Viewport | null {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Evaluates a function in the page's context and returns the result.\n   *\n   * If the function passed to `page.evaluate` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const result = await frame.evaluate(() => {\n   *   return Promise.resolve(8 * 7);\n   * });\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluate('1 + 2');\n   * ```\n   *\n   * To get the best TypeScript experience, you should pass in as the\n   * generic the type of `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluate(() => 2);\n   * ```\n   *\n   * @example\n   *\n   * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n   * as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const bodyHandle = await page.$('body');\n   * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n   * await bodyHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   *\n   * @returns the return value of `pageFunction`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(): Promise<Awaited<ReturnType<Func>>> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Adds a function which would be invoked in one of the following scenarios:\n   *\n   * - whenever the page is navigated\n   *\n   * - whenever the child frame is attached or navigated. In this case, the\n   *   function is invoked in the context of the newly attached frame.\n   *\n   * The function is invoked after the document was created but before any of\n   * its scripts were run. This is useful to amend the JavaScript environment,\n   * e.g. to seed `Math.random`.\n   * @param pageFunction - Function to be evaluated in browser context\n   * @param args - Arguments to pass to `pageFunction`\n   * @example\n   * An example of overriding the navigator.languages property before the page loads:\n   *\n   * ```ts\n   * // preload.js\n   *\n   * // overwrite the `languages` property to use a custom getter\n   * Object.defineProperty(navigator, 'languages', {\n   *   get: function () {\n   *     return ['en-US', 'en', 'bn'];\n   *   },\n   * });\n   *\n   * // In your puppeteer script, assuming the preload.js file is\n   * // in same folder of our script.\n   * const preloadFile = fs.readFileSync('./preload.js', 'utf8');\n   * await page.evaluateOnNewDocument(preloadFile);\n   * ```\n   */\n  async evaluateOnNewDocument<\n    Params extends unknown[],\n    Func extends (...args: Params) => unknown = (...args: Params) => unknown,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<NewDocumentScriptEvaluation>;\n  async evaluateOnNewDocument(): Promise<NewDocumentScriptEvaluation> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Removes script that injected into page by Page.evaluateOnNewDocument.\n   *\n   * @param identifier - script identifier\n   */\n  async removeScriptToEvaluateOnNewDocument(identifier: string): Promise<void>;\n  async removeScriptToEvaluateOnNewDocument(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Toggles ignoring cache for each request based on the enabled state. By\n   * default, caching is enabled.\n   * @param enabled - sets the `enabled` state of cache\n   * @defaultValue `true`\n   */\n  async setCacheEnabled(enabled?: boolean): Promise<void>;\n  async setCacheEnabled(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  async _maybeWriteBufferToFile(\n    path: string | undefined,\n    buffer: Buffer\n  ): Promise<void> {\n    if (!path) {\n      return;\n    }\n\n    const fs = await importFSPromises();\n\n    await fs.writeFile(path, buffer);\n  }\n\n  /**\n   * Captures screenshot of the current page.\n   *\n   * @remarks\n   * Options object which might have the following properties:\n   *\n   * - `path` : The file path to save the image to. The screenshot type\n   *   will be inferred from file extension. If `path` is a relative path, then\n   *   it is resolved relative to\n   *   {@link https://nodejs.org/api/process.html#process_process_cwd\n   *   | current working directory}.\n   *   If no path is provided, the image won't be saved to the disk.\n   *\n   * - `type` : Specify screenshot type, can be `jpeg`, `png` or `webp`.\n   *   Defaults to 'png'.\n   *\n   * - `quality` : The quality of the image, between 0-100. Not\n   *   applicable to `png` images.\n   *\n   * - `fullPage` : When true, takes a screenshot of the full\n   *   scrollable page. Defaults to `false`.\n   *\n   * - `clip` : An object which specifies clipping region of the page.\n   *   Should have the following fields:<br/>\n   * - `x` : x-coordinate of top-left corner of clip area.<br/>\n   * - `y` : y-coordinate of top-left corner of clip area.<br/>\n   * - `width` : width of clipping area.<br/>\n   * - `height` : height of clipping area.\n   *\n   * - `omitBackground` : Hides default white background and allows\n   *   capturing screenshots with transparency. Defaults to `false`.\n   *\n   * - `encoding` : The encoding of the image, can be either base64 or\n   *   binary. Defaults to `binary`.\n   *\n   * - `captureBeyondViewport` : When true, captures screenshot\n   *   {@link https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-captureScreenshot\n   *   | beyond the viewport}. When false, falls back to old behaviour,\n   *   and cuts the screenshot by the viewport size. Defaults to `true`.\n   *\n   * - `fromSurface` : When true, captures screenshot\n   *   {@link https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-captureScreenshot\n   *   | from the surface rather than the view}. When false, works only in\n   *   headful mode and ignores page viewport (but not browser window's\n   *   bounds). Defaults to `true`.\n   *\n   * @returns Promise which resolves to buffer or a base64 string (depending on\n   * the value of `encoding`) with captured screenshot.\n   */\n  screenshot(\n    options: ScreenshotOptions & {encoding: 'base64'}\n  ): Promise<string>;\n  screenshot(\n    options?: ScreenshotOptions & {encoding?: 'binary'}\n  ): Promise<Buffer>;\n  async screenshot(options?: ScreenshotOptions): Promise<Buffer | string>;\n  async screenshot(): Promise<Buffer | string> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  _getPDFOptions(\n    options: PDFOptions = {},\n    lengthUnit: 'in' | 'cm' = 'in'\n  ): ParsedPDFOptions {\n    const defaults = {\n      scale: 1,\n      displayHeaderFooter: false,\n      headerTemplate: '',\n      footerTemplate: '',\n      printBackground: false,\n      landscape: false,\n      pageRanges: '',\n      preferCSSPageSize: false,\n      omitBackground: false,\n      timeout: 30000,\n    };\n\n    let width = 8.5;\n    let height = 11;\n    if (options.format) {\n      const format =\n        paperFormats[options.format.toLowerCase() as LowerCasePaperFormat];\n      assert(format, 'Unknown paper format: ' + options.format);\n      width = format.width;\n      height = format.height;\n    } else {\n      width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;\n      height =\n        convertPrintParameterToInches(options.height, lengthUnit) ?? height;\n    }\n\n    const margin = {\n      top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,\n      left:\n        convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,\n      bottom:\n        convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,\n      right:\n        convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0,\n    };\n\n    const output = {\n      ...defaults,\n      ...options,\n      width,\n      height,\n      margin,\n    };\n\n    return output;\n  }\n\n  /**\n   * Generates a PDF of the page with the `print` CSS media type.\n   * @remarks\n   *\n   * To generate a PDF with the `screen` media type, call\n   * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before\n   * calling `page.pdf()`.\n   *\n   * By default, `page.pdf()` generates a pdf with modified colors for printing.\n   * Use the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}\n   * property to force rendering of exact colors.\n   *\n   * @param options - options for generating the PDF.\n   */\n  async createPDFStream(options?: PDFOptions): Promise<Readable>;\n  async createPDFStream(): Promise<Readable> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Page.createPDFStream}\n   */\n  async pdf(options?: PDFOptions): Promise<Buffer>;\n  async pdf(): Promise<Buffer> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The page's title\n   *\n   * @remarks\n   * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n   */\n  async title(): Promise<string> {\n    throw new Error('Not implemented');\n  }\n\n  async close(options?: {runBeforeUnload?: boolean}): Promise<void>;\n  async close(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Indicates that the page has been closed.\n   * @returns\n   */\n  isClosed(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Mouse}\n   */\n  get mouse(): Mouse {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.mouse} to click in the center of the\n   * element. If there's no element matching `selector`, the method throws an\n   * error.\n   * @remarks Bear in mind that if `click()` triggers a navigation event and\n   * there's a separate `page.waitForNavigation()` promise to be resolved, you\n   * may end up with a race condition that yields unexpected results. The\n   * correct pattern for click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   page.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n   * @param selector - A `selector` to search for element to click. If there are\n   * multiple elements satisfying the `selector`, the first will be clicked\n   * @param options - `Object`\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully clicked. The Promise will be rejected if there is no element\n   * matching `selector`.\n   */\n  click(selector: string, options?: Readonly<ClickOptions>): Promise<void> {\n    return this.mainFrame().click(selector, options);\n  }\n\n  /**\n   * This method fetches an element with `selector` and focuses it. If there's no\n   * element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }\n   * of an element to focus. If there are multiple elements satisfying the\n   * selector, the first will be focused.\n   * @returns Promise which resolves when the element matching selector is\n   * successfully focused. The promise will be rejected if there is no element\n   * matching selector.\n   * @remarks\n   * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.\n   */\n  focus(selector: string): Promise<void> {\n    return this.mainFrame().focus(selector);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.mouse}\n   * to hover over the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to search for element to hover. If there are multiple elements satisfying\n   * the selector, the first will be hovered.\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully hovered. Promise gets rejected if there's no element matching\n   * `selector`.\n   * @remarks\n   * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n   */\n  hover(selector: string): Promise<void> {\n    return this.mainFrame().hover(selector);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * page.select('select#colors', 'blue'); // single selection\n   * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to query the page for\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first one\n   * is taken into account.\n   * @returns\n   *\n   * @remarks\n   * Shortcut for {@link Frame.select | page.mainFrame().select()}\n   */\n  select(selector: string, ...values: string[]): Promise<string[]> {\n    return this.mainFrame().select(selector, ...values);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.touchscreen}\n   * to tap in the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to search for element to tap. If there are multiple elements satisfying the\n   * selector, the first will be tapped.\n   * @returns\n   * @remarks\n   * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n   */\n  tap(selector: string): Promise<void> {\n    return this.mainFrame().tap(selector);\n  }\n\n  /**\n   * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n   * in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n   * @example\n   *\n   * ```ts\n   * await page.type('#mytextarea', 'Hello');\n   * // Types instantly\n   * await page.type('#mytextarea', 'World', {delay: 100});\n   * // Types slower, like a user\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to type into. If there are multiple elements satisfying the\n   * selector, the first will be used.\n   * @param text - A text to type into a focused element.\n   * @param options - have property `delay` which is the Time to wait between\n   * key presses in milliseconds. Defaults to `0`.\n   * @returns\n   * @remarks\n   */\n  type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    return this.mainFrame().type(selector, text, options);\n  }\n\n  /**\n   * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.\n   *\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```ts\n   * await page.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n  waitForTimeout(milliseconds: number): Promise<void> {\n    return this.mainFrame().waitForTimeout(milliseconds);\n  }\n\n  /**\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately. If\n   * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigations:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by selector string\n   * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n   * selector is not found in DOM.\n   * @remarks\n   * The optional Parameter in Arguments `options` are:\n   *\n   * - `visible`: A boolean wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n   *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n   *   `false`.\n   *\n   * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n   *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n   *   by using the {@link Page.setDefaultTimeout} method.\n   */\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().waitForSelector(selector, options);\n  }\n\n  /**\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigation\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForXPath('//img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param xpath - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an\n   * element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by xpath string is\n   * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is\n   * not found in DOM, otherwise resolves to `ElementHandle`.\n   * @remarks\n   * The optional Argument `options` have properties:\n   *\n   * - `visible`: A boolean to wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: A boolean wait for element to not be found in the DOM or to be\n   *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *   Defaults to `false`.\n   *\n   * - `timeout`: A number which is maximum time to wait for in milliseconds.\n   *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default\n   *   value can be changed by using the {@link Page.setDefaultTimeout} method.\n   */\n  waitForXPath(\n    xpath: string,\n    options?: WaitForSelectorOptions\n  ): Promise<ElementHandle<Node> | null> {\n    return this.mainFrame().waitForXPath(xpath, options);\n  }\n\n  /**\n   * Waits for a function to finish evaluating in the page's context.\n   *\n   * @example\n   * The {@link Page.waitForFunction} can be used to observe viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n   *   await page.setViewport({width: 50, height: 50});\n   *   await watchDog;\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * To pass arguments from node.js to the predicate of\n   * {@link Page.waitForFunction} function:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await page.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {},\n   *   selector\n   * );\n   * ```\n   *\n   * @example\n   * The predicate of {@link Page.waitForFunction} can be asynchronous too:\n   *\n   * ```ts\n   * const username = 'github-username';\n   * await page.waitForFunction(\n   *   async username => {\n   *     const githubResponse = await fetch(\n   *       `https://api.github.com/users/${username}`\n   *     );\n   *     const githubUser = await githubResponse.json();\n   *     // show the avatar\n   *     const img = document.createElement('img');\n   *     img.src = githubUser.avatar_url;\n   *     // wait 3 seconds\n   *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n   *     img.remove();\n   *   },\n   *   {},\n   *   username\n   * );\n   * ```\n   *\n   * @param pageFunction - Function to be evaluated in browser context\n   * @param options - Options for configuring waiting behavior.\n   */\n  waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    options?: FrameWaitForFunctionOptions,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   page.waitForDevicePrompt(),\n   *   page.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  waitForDevicePrompt(\n    options?: WaitTimeoutOptions\n  ): Promise<DeviceRequestPrompt>;\n  waitForDevicePrompt(): Promise<DeviceRequestPrompt> {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * @internal\n */\nexport const supportedMetrics = new Set<string>([\n  'Timestamp',\n  'Documents',\n  'Frames',\n  'JSEventListeners',\n  'Nodes',\n  'LayoutCount',\n  'RecalcStyleCount',\n  'LayoutDuration',\n  'RecalcStyleDuration',\n  'ScriptDuration',\n  'TaskDuration',\n  'JSHeapUsedSize',\n  'JSHeapTotalSize',\n]);\n\n/**\n * @internal\n */\nexport const unitToPixels = {\n  px: 1,\n  in: 96,\n  cm: 37.8,\n  mm: 3.78,\n};\n\nfunction convertPrintParameterToInches(\n  parameter?: string | number,\n  lengthUnit: 'in' | 'cm' = 'in'\n): number | undefined {\n  if (typeof parameter === 'undefined') {\n    return undefined;\n  }\n  let pixels;\n  if (isNumber(parameter)) {\n    // Treat numbers as pixel values to be aligned with phantom's paperSize.\n    pixels = parameter;\n  } else if (isString(parameter)) {\n    const text = parameter;\n    let unit = text.substring(text.length - 2).toLowerCase();\n    let valueText = '';\n    if (unit in unitToPixels) {\n      valueText = text.substring(0, text.length - 2);\n    } else {\n      // In case of unknown unit try to parse the whole parameter as number of pixels.\n      // This is consistent with phantom's paperSize behavior.\n      unit = 'px';\n      valueText = text;\n    }\n    const value = Number(valueText);\n    assert(!isNaN(value), 'Failed to parse parameter value: ' + text);\n    pixels = value * unitToPixels[unit as keyof typeof unitToPixels];\n  } else {\n    throw new Error(\n      'page.pdf() Cannot handle parameter type: ' + typeof parameter\n    );\n  }\n  return pixels / unitToPixels[lengthUnit];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}