{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\nconst STREAM_DESTROYED = new Error('Stream was destroyed');\nconst PREMATURE_CLOSE = new Error('Premature close');\nconst queueTick = require('queue-tick');\nconst FIFO = require('fast-fifo');\n\n/* eslint-disable no-multi-spaces */\n\n// 27 bits used total (4 from shared, 13 from read, and 10 from write)\nconst MAX = (1 << 27) - 1;\n\n// Shared state\nconst OPENING = 0b0001;\nconst PREDESTROYING = 0b0010;\nconst DESTROYING = 0b0100;\nconst DESTROYED = 0b1000;\nconst NOT_OPENING = MAX ^ OPENING;\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING;\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE = 0b0000000000001 << 4;\nconst READ_UPDATING = 0b0000000000010 << 4;\nconst READ_PRIMARY = 0b0000000000100 << 4;\nconst READ_QUEUED = 0b0000000001000 << 4;\nconst READ_RESUMED = 0b0000000010000 << 4;\nconst READ_PIPE_DRAINED = 0b0000000100000 << 4;\nconst READ_ENDING = 0b0000001000000 << 4;\nconst READ_EMIT_DATA = 0b0000010000000 << 4;\nconst READ_EMIT_READABLE = 0b0000100000000 << 4;\nconst READ_EMITTED_READABLE = 0b0001000000000 << 4;\nconst READ_DONE = 0b0010000000000 << 4;\nconst READ_NEXT_TICK = 0b0100000000000 << 4;\nconst READ_NEEDS_PUSH = 0b1000000000000 << 4;\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;\nconst READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;\nconst READ_NON_PRIMARY = MAX ^ READ_PRIMARY;\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);\nconst READ_PUSHED = MAX ^ READ_NEEDS_PUSH;\nconst READ_PAUSED = MAX ^ READ_RESUMED;\nconst READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);\nconst READ_NOT_ENDING = MAX ^ READ_ENDING;\nconst READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;\nconst READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;\nconst READ_NOT_UPDATING = MAX ^ READ_UPDATING;\n\n// Write state (17 bit offset, 4 bit offset from shared state and 13 from read state)\nconst WRITE_ACTIVE = 0b0000000001 << 17;\nconst WRITE_UPDATING = 0b0000000010 << 17;\nconst WRITE_PRIMARY = 0b0000000100 << 17;\nconst WRITE_QUEUED = 0b0000001000 << 17;\nconst WRITE_UNDRAINED = 0b0000010000 << 17;\nconst WRITE_DONE = 0b0000100000 << 17;\nconst WRITE_EMIT_DRAIN = 0b0001000000 << 17;\nconst WRITE_NEXT_TICK = 0b0010000000 << 17;\nconst WRITE_WRITING = 0b0100000000 << 17;\nconst WRITE_FINISHING = 0b1000000000 << 17;\nconst WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);\nconst WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;\nconst WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;\nconst WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;\nconst WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;\nconst WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE;\nconst NOT_ACTIVE = MAX ^ ACTIVE;\nconst DONE = READ_DONE | WRITE_DONE;\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;\nconst OPEN_STATUS = DESTROY_STATUS | OPENING;\nconst AUTO_DESTROY = DESTROY_STATUS | DONE;\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;\nconst IS_OPENING = OPEN_STATUS | TICKING;\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH;\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED;\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');\nclass WritableState {\n  constructor(stream, {\n    highWaterMark = 16384,\n    map = null,\n    mapWritable,\n    byteLength,\n    byteLengthWritable\n  } = {}) {\n    this.stream = stream;\n    this.queue = new FIFO();\n    this.highWaterMark = highWaterMark;\n    this.buffered = 0;\n    this.error = null;\n    this.pipeline = null;\n    this.drains = null; // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength;\n    this.map = mapWritable || map;\n    this.afterWrite = afterWrite.bind(this);\n    this.afterUpdateNextTick = updateWriteNT.bind(this);\n  }\n  get ended() {\n    return (this.stream._duplexState & WRITE_DONE) !== 0;\n  }\n  push(data) {\n    if (this.map !== null) data = this.map(data);\n    this.buffered += this.byteLength(data);\n    this.queue.push(data);\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED;\n      return true;\n    }\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;\n    return false;\n  }\n  shift() {\n    const data = this.queue.shift();\n    this.buffered -= this.byteLength(data);\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;\n    return data;\n  }\n  end(data) {\n    if (typeof data === 'function') this.stream.once('finish', data);else if (data !== undefined && data !== null) this.push(data);\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;\n  }\n  autoBatch(data, cb) {\n    const buffer = [];\n    const stream = this.stream;\n    buffer.push(data);\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift());\n    }\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);\n    stream._writev(buffer, cb);\n  }\n  update() {\n    const stream = this.stream;\n    stream._duplexState |= WRITE_UPDATING;\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift();\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING;\n        stream._write(data, this.afterWrite);\n      }\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();\n    } while (this.continueUpdate() === true);\n    stream._duplexState &= WRITE_NOT_UPDATING;\n  }\n  updateNonPrimary() {\n    const stream = this.stream;\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;\n      stream._final(afterFinal.bind(this));\n      return;\n    }\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE;\n        stream._destroy(afterDestroy.bind(this));\n      }\n      return;\n    }\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;\n      stream._open(afterOpen.bind(this));\n    }\n  }\n  continueUpdate() {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK;\n    return true;\n  }\n  updateCallback() {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();else this.updateNextTick();\n  }\n  updateNextTick() {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;\n    this.stream._duplexState |= WRITE_NEXT_TICK;\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick);\n  }\n}\nclass ReadableState {\n  constructor(stream, {\n    highWaterMark = 16384,\n    map = null,\n    mapReadable,\n    byteLength,\n    byteLengthReadable\n  } = {}) {\n    this.stream = stream;\n    this.queue = new FIFO();\n    this.highWaterMark = highWaterMark;\n    this.buffered = 0;\n    this.error = null;\n    this.pipeline = null;\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength;\n    this.map = mapReadable || map;\n    this.pipeTo = null;\n    this.afterRead = afterRead.bind(this);\n    this.afterUpdateNextTick = updateReadNT.bind(this);\n  }\n  get ended() {\n    return (this.stream._duplexState & READ_DONE) !== 0;\n  }\n  pipe(pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');\n    if (typeof cb !== 'function') cb = null;\n    this.stream._duplexState |= READ_PIPE_DRAINED;\n    this.pipeTo = pipeTo;\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb);\n    if (cb) this.stream.on('error', noop); // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline;\n      if (cb) pipeTo.on('error', noop); // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)); // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null); // onclose has a weird bool arg\n      pipeTo.on('error', onerror);\n      pipeTo.on('close', onclose);\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));\n    }\n    pipeTo.on('drain', afterDrain.bind(this));\n    this.stream.emit('piping', pipeTo);\n    pipeTo.emit('pipe', this.stream);\n  }\n  push(data) {\n    const stream = this.stream;\n    if (data === null) {\n      this.highWaterMark = 0;\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;\n      return false;\n    }\n    if (this.map !== null) data = this.map(data);\n    this.buffered += this.byteLength(data);\n    this.queue.push(data);\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;\n    return this.buffered < this.highWaterMark;\n  }\n  shift() {\n    const data = this.queue.shift();\n    this.buffered -= this.byteLength(data);\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;\n    return data;\n  }\n  unshift(data) {\n    const pending = [this.map !== null ? this.map(data) : data];\n    while (this.buffered > 0) pending.push(this.shift());\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i];\n      this.buffered += this.byteLength(data);\n      this.queue.push(data);\n    }\n    this.push(pending[pending.length - 1]);\n  }\n  read() {\n    const stream = this.stream;\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift();\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);\n      return data;\n    }\n    return null;\n  }\n  drain() {\n    const stream = this.stream;\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift();\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);\n    }\n  }\n  update() {\n    const stream = this.stream;\n    stream._duplexState |= READ_UPDATING;\n    do {\n      this.drain();\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === 0) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;\n        stream._read(this.afterRead);\n        this.drain();\n      }\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE;\n        stream.emit('readable');\n      }\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();\n    } while (this.continueUpdate() === true);\n    stream._duplexState &= READ_NOT_UPDATING;\n  }\n  updateNonPrimary() {\n    const stream = this.stream;\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;\n      stream.emit('end');\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;\n      if (this.pipeTo !== null) this.pipeTo.end();\n    }\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE;\n        stream._destroy(afterDestroy.bind(this));\n      }\n      return;\n    }\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;\n      stream._open(afterOpen.bind(this));\n    }\n  }\n  continueUpdate() {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;\n    this.stream._duplexState &= READ_NOT_NEXT_TICK;\n    return true;\n  }\n  updateCallback() {\n    if ((this.stream._readableState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();else this.updateNextTick();\n  }\n  updateNextTick() {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;\n    this.stream._duplexState |= READ_NEXT_TICK;\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick);\n  }\n}\nclass TransformState {\n  constructor(stream) {\n    this.data = null;\n    this.afterTransform = afterTransform.bind(stream);\n    this.afterFinal = null;\n  }\n}\nclass Pipeline {\n  constructor(src, dst, cb) {\n    this.from = src;\n    this.to = dst;\n    this.afterPipe = cb;\n    this.error = null;\n    this.pipeToFinished = false;\n  }\n  finished() {\n    this.pipeToFinished = true;\n  }\n  done(stream, err) {\n    if (err) this.error = err;\n    if (stream === this.to) {\n      this.to = null;\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'));\n        }\n        return;\n      }\n    }\n    if (stream === this.from) {\n      this.from = null;\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'));\n        }\n        return;\n      }\n    }\n    if (this.afterPipe !== null) this.afterPipe(this.error);\n    this.to = this.from = this.afterPipe = null;\n  }\n}\nfunction afterDrain() {\n  this.stream._duplexState |= READ_PIPE_DRAINED;\n  this.updateCallback();\n}\nfunction afterFinal(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE;\n    stream.emit('finish');\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING;\n  }\n  stream._duplexState &= WRITE_NOT_ACTIVE;\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();else this.updateNextTick();\n}\nfunction afterDestroy(err) {\n  const stream = this.stream;\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error;\n  if (err) stream.emit('error', err);\n  stream._duplexState |= DESTROYED;\n  stream.emit('close');\n  const rs = stream._readableState;\n  const ws = stream._writableState;\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false);\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err);\n  }\n}\nfunction afterWrite(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  stream._duplexState &= WRITE_NOT_ACTIVE;\n  if (this.drains !== null) tickDrains(this.drains);\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED;\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain');\n    }\n  }\n  this.updateCallback();\n}\nfunction afterRead(err) {\n  if (err) this.stream.destroy(err);\n  this.stream._duplexState &= READ_NOT_ACTIVE;\n  this.updateCallback();\n}\nfunction updateReadNT() {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK;\n    this.update();\n  }\n}\nfunction updateWriteNT() {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK;\n    this.update();\n  }\n}\nfunction tickDrains(drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true);\n      i--;\n    }\n  }\n}\nfunction afterOpen(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;\n    stream.emit('open');\n  }\n  stream._duplexState &= NOT_ACTIVE;\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback();\n  }\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback();\n  }\n}\nfunction afterTransform(err, data) {\n  if (data !== undefined && data !== null) this.push(data);\n  this._writableState.afterWrite(err);\n}\nclass Stream extends EventEmitter {\n  constructor(opts) {\n    super();\n    this._duplexState = 0;\n    this._readableState = null;\n    this._writableState = null;\n    if (opts) {\n      if (opts.open) this._open = opts.open;\n      if (opts.destroy) this._destroy = opts.destroy;\n      if (opts.predestroy) this._predestroy = opts.predestroy;\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this));\n      }\n    }\n  }\n  _open(cb) {\n    cb(null);\n  }\n  _destroy(cb) {\n    cb(null);\n  }\n  _predestroy() {\n    // does nothing\n  }\n  get readable() {\n    return this._readableState !== null ? true : undefined;\n  }\n  get writable() {\n    return this._writableState !== null ? true : undefined;\n  }\n  get destroyed() {\n    return (this._duplexState & DESTROYED) !== 0;\n  }\n  get destroying() {\n    return (this._duplexState & DESTROY_STATUS) !== 0;\n  }\n  destroy(err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED;\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0;\n        this._readableState.error = err;\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0;\n        this._writableState.error = err;\n      }\n      this._duplexState |= PREDESTROYING;\n      this._predestroy();\n      this._duplexState &= NOT_PREDESTROYING;\n      if (this._readableState !== null) this._readableState.updateNextTick();\n      if (this._writableState !== null) this._writableState.updateNextTick();\n    }\n  }\n  on(name, fn) {\n    if (this._readableState !== null) {\n      if (name === 'data') {\n        this._duplexState |= READ_EMIT_DATA | READ_RESUMED;\n        this._readableState.updateNextTick();\n      }\n      if (name === 'readable') {\n        this._duplexState |= READ_EMIT_READABLE;\n        this._readableState.updateNextTick();\n      }\n    }\n    if (this._writableState !== null) {\n      if (name === 'drain') {\n        this._duplexState |= WRITE_EMIT_DRAIN;\n        this._writableState.updateNextTick();\n      }\n    }\n    return super.on(name, fn);\n  }\n}\nclass Readable extends Stream {\n  constructor(opts) {\n    super(opts);\n    this._duplexState |= OPENING | WRITE_DONE;\n    this._readableState = new ReadableState(this, opts);\n    if (opts) {\n      if (opts.read) this._read = opts.read;\n      if (opts.eagerOpen) this._readableState.updateNextTick();\n    }\n  }\n  _read(cb) {\n    cb(null);\n  }\n  pipe(dest, cb) {\n    this._readableState.updateNextTick();\n    this._readableState.pipe(dest, cb);\n    return dest;\n  }\n  read() {\n    this._readableState.updateNextTick();\n    return this._readableState.read();\n  }\n  push(data) {\n    this._readableState.updateNextTick();\n    return this._readableState.push(data);\n  }\n  unshift(data) {\n    this._readableState.updateNextTick();\n    return this._readableState.unshift(data);\n  }\n  resume() {\n    this._duplexState |= READ_RESUMED;\n    this._readableState.updateNextTick();\n    return this;\n  }\n  pause() {\n    this._duplexState &= READ_PAUSED;\n    return this;\n  }\n  static _fromAsyncIterator(ite, opts) {\n    let destroy;\n    const rs = new Readable({\n      ...opts,\n      read(cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb);\n      },\n      predestroy() {\n        destroy = ite.return();\n      },\n      destroy(cb) {\n        if (!destroy) return cb(null);\n        destroy.then(cb.bind(null, null)).catch(cb);\n      }\n    });\n    return rs;\n    function push(data) {\n      if (data.done) rs.push(null);else rs.push(data.value);\n    }\n  }\n  static from(data, opts) {\n    if (isReadStreamx(data)) return data;\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data];\n    let i = 0;\n    return new Readable({\n      ...opts,\n      read(cb) {\n        this.push(i === data.length ? null : data[i++]);\n        cb(null);\n      }\n    });\n  }\n  static isBackpressured(rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;\n  }\n  static isPaused(rs) {\n    return (rs._duplexState & READ_RESUMED) === 0;\n  }\n  [asyncIterator]() {\n    const stream = this;\n    let error = null;\n    let promiseResolve = null;\n    let promiseReject = null;\n    this.on('error', err => {\n      error = err;\n    });\n    this.on('readable', onreadable);\n    this.on('close', onclose);\n    return {\n      [asyncIterator]() {\n        return this;\n      },\n      next() {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve;\n          promiseReject = reject;\n          const data = stream.read();\n          if (data !== null) ondata(data);else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);\n        });\n      },\n      return() {\n        return destroy(null);\n      },\n      throw(err) {\n        return destroy(err);\n      }\n    };\n    function onreadable() {\n      if (promiseResolve !== null) ondata(stream.read());\n    }\n    function onclose() {\n      if (promiseResolve !== null) ondata(null);\n    }\n    function ondata(data) {\n      if (promiseReject === null) return;\n      if (error) promiseReject(error);else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);else promiseResolve({\n        value: data,\n        done: data === null\n      });\n      promiseReject = promiseResolve = null;\n    }\n    function destroy(err) {\n      stream.destroy(err);\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({\n          value: undefined,\n          done: true\n        });\n        stream.once('close', function () {\n          if (err) reject(err);else resolve({\n            value: undefined,\n            done: true\n          });\n        });\n      });\n    }\n  }\n}\nclass Writable extends Stream {\n  constructor(opts) {\n    super(opts);\n    this._duplexState |= OPENING | READ_DONE;\n    this._writableState = new WritableState(this, opts);\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev;\n      if (opts.write) this._write = opts.write;\n      if (opts.final) this._final = opts.final;\n      if (opts.eagerOpen) this._writableState.updateNextTick();\n    }\n  }\n  _writev(batch, cb) {\n    cb(null);\n  }\n  _write(data, cb) {\n    this._writableState.autoBatch(data, cb);\n  }\n  _final(cb) {\n    cb(null);\n  }\n  static isBackpressured(ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;\n  }\n  static drained(ws) {\n    if (ws.destroyed) return Promise.resolve(false);\n    const state = ws._writableState;\n    const writes = state.queue.length + (ws._duplexState & WRITE_WRITING ? 1 : 0);\n    if (writes === 0) return Promise.resolve(true);\n    if (state.drains === null) state.drains = [];\n    return new Promise(resolve => {\n      state.drains.push({\n        writes,\n        resolve\n      });\n    });\n  }\n  write(data) {\n    this._writableState.updateNextTick();\n    return this._writableState.push(data);\n  }\n  end(data) {\n    this._writableState.updateNextTick();\n    this._writableState.end(data);\n    return this;\n  }\n}\nclass Duplex extends Readable {\n  // and Writable\n  constructor(opts) {\n    super(opts);\n    this._duplexState = OPENING;\n    this._writableState = new WritableState(this, opts);\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev;\n      if (opts.write) this._write = opts.write;\n      if (opts.final) this._final = opts.final;\n    }\n  }\n  _writev(batch, cb) {\n    cb(null);\n  }\n  _write(data, cb) {\n    this._writableState.autoBatch(data, cb);\n  }\n  _final(cb) {\n    cb(null);\n  }\n  write(data) {\n    this._writableState.updateNextTick();\n    return this._writableState.push(data);\n  }\n  end(data) {\n    this._writableState.updateNextTick();\n    this._writableState.end(data);\n    return this;\n  }\n}\nclass Transform extends Duplex {\n  constructor(opts) {\n    super(opts);\n    this._transformState = new TransformState(this);\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform;\n      if (opts.flush) this._flush = opts.flush;\n    }\n  }\n  _write(data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data;\n    } else {\n      this._transform(data, this._transformState.afterTransform);\n    }\n  }\n  _read(cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data;\n      this._transformState.data = null;\n      cb(null);\n      this._transform(data, this._transformState.afterTransform);\n    } else {\n      cb(null);\n    }\n  }\n  _transform(data, cb) {\n    cb(null, data);\n  }\n  _flush(cb) {\n    cb(null);\n  }\n  _final(cb) {\n    this._transformState.afterFinal = cb;\n    this._flush(transformAfterFlush.bind(this));\n  }\n}\nclass PassThrough extends Transform {}\nfunction transformAfterFlush(err, data) {\n  const cb = this._transformState.afterFinal;\n  if (err) return cb(err);\n  if (data !== null && data !== undefined) this.push(data);\n  this.push(null);\n  cb(null);\n}\nfunction pipelinePromise(...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, err => {\n      if (err) return reject(err);\n      resolve();\n    });\n  });\n}\nfunction pipeline(stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];\n  const done = all.length && typeof all[all.length - 1] === 'function' ? all.pop() : null;\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams');\n  let src = all[0];\n  let dest = null;\n  let error = null;\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i];\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror);\n    } else {\n      errorHandle(src, true, i > 1, onerror);\n      src.pipe(dest);\n    }\n    src = dest;\n  }\n  if (done) {\n    let fin = false;\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);\n    dest.on('error', err => {\n      if (error === null) error = err;\n    });\n    dest.on('finish', () => {\n      fin = true;\n      if (!autoDestroy) done(error);\n    });\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)));\n    }\n  }\n  return dest;\n  function errorHandle(s, rd, wr, onerror) {\n    s.on('error', onerror);\n    s.on('close', onclose);\n    function onclose() {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE);\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE);\n    }\n  }\n  function onerror(err) {\n    if (!err || error) return;\n    error = err;\n    for (const s of all) {\n      s.destroy(err);\n    }\n  }\n}\nfunction isStream(stream) {\n  return !!stream._readableState || !!stream._writableState;\n}\nfunction isStreamx(stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream);\n}\nfunction getStreamError(stream) {\n  const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;\n  return err === STREAM_DESTROYED ? null : err; // only explicit errors\n}\n\nfunction isReadStreamx(stream) {\n  return isStreamx(stream) && stream.readable;\n}\nfunction isTypedArray(data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number';\n}\nfunction defaultByteLength(data) {\n  return isTypedArray(data) ? data.byteLength : 1024;\n}\nfunction noop() {}\nfunction abort() {\n  this.destroy(new Error('Stream aborted.'));\n}\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n};","map":{"version":3,"names":["EventEmitter","require","STREAM_DESTROYED","Error","PREMATURE_CLOSE","queueTick","FIFO","MAX","OPENING","PREDESTROYING","DESTROYING","DESTROYED","NOT_OPENING","NOT_PREDESTROYING","READ_ACTIVE","READ_UPDATING","READ_PRIMARY","READ_QUEUED","READ_RESUMED","READ_PIPE_DRAINED","READ_ENDING","READ_EMIT_DATA","READ_EMIT_READABLE","READ_EMITTED_READABLE","READ_DONE","READ_NEXT_TICK","READ_NEEDS_PUSH","READ_FLOWING","READ_ACTIVE_AND_NEEDS_PUSH","READ_PRIMARY_AND_ACTIVE","READ_EMIT_READABLE_AND_QUEUED","READ_NOT_ACTIVE","READ_NON_PRIMARY","READ_NON_PRIMARY_AND_PUSHED","READ_PUSHED","READ_PAUSED","READ_NOT_QUEUED","READ_NOT_ENDING","READ_PIPE_NOT_DRAINED","READ_NOT_NEXT_TICK","READ_NOT_UPDATING","WRITE_ACTIVE","WRITE_UPDATING","WRITE_PRIMARY","WRITE_QUEUED","WRITE_UNDRAINED","WRITE_DONE","WRITE_EMIT_DRAIN","WRITE_NEXT_TICK","WRITE_WRITING","WRITE_FINISHING","WRITE_NOT_ACTIVE","WRITE_NON_PRIMARY","WRITE_NOT_FINISHING","WRITE_DRAINED","WRITE_NOT_QUEUED","WRITE_NOT_NEXT_TICK","WRITE_NOT_UPDATING","ACTIVE","NOT_ACTIVE","DONE","DESTROY_STATUS","OPEN_STATUS","AUTO_DESTROY","NON_PRIMARY","ACTIVE_OR_TICKING","TICKING","IS_OPENING","READ_PRIMARY_STATUS","READ_STATUS","READ_ENDING_STATUS","READ_READABLE_STATUS","SHOULD_NOT_READ","READ_BACKPRESSURE_STATUS","READ_UPDATE_SYNC_STATUS","WRITE_PRIMARY_STATUS","WRITE_QUEUED_AND_UNDRAINED","WRITE_QUEUED_AND_ACTIVE","WRITE_DRAIN_STATUS","WRITE_STATUS","WRITE_PRIMARY_AND_ACTIVE","WRITE_ACTIVE_AND_WRITING","WRITE_FINISHING_STATUS","WRITE_BACKPRESSURE_STATUS","WRITE_UPDATE_SYNC_STATUS","asyncIterator","Symbol","WritableState","constructor","stream","highWaterMark","map","mapWritable","byteLength","byteLengthWritable","queue","buffered","error","pipeline","drains","defaultByteLength","afterWrite","bind","afterUpdateNextTick","updateWriteNT","ended","_duplexState","push","data","shift","end","once","undefined","autoBatch","cb","buffer","_writableState","_writev","update","_write","updateNonPrimary","continueUpdate","_final","afterFinal","_destroy","afterDestroy","_open","afterOpen","updateCallback","updateNextTick","ReadableState","mapReadable","byteLengthReadable","pipeTo","afterRead","updateReadNT","pipe","Pipeline","on","noop","isStreamx","finished","onerror","done","onclose","afterDrain","emit","unshift","pending","i","length","read","write","drain","_read","_readableState","TransformState","afterTransform","src","dst","from","to","afterPipe","pipeToFinished","err","destroy","rs","ws","resolve","tickDrains","writes","Stream","opts","open","predestroy","_predestroy","signal","addEventListener","abort","readable","writable","destroyed","destroying","name","fn","Readable","eagerOpen","dest","resume","pause","_fromAsyncIterator","ite","next","then","catch","return","value","isReadStreamx","Array","isArray","isBackpressured","isPaused","promiseResolve","promiseReject","onreadable","Promise","reject","ondata","throw","Writable","writev","final","batch","drained","state","Duplex","Transform","_transformState","transform","_transform","flush","_flush","transformAfterFlush","PassThrough","pipelinePromise","streams","all","pop","errorHandle","fin","autoDestroy","s","rd","wr","isStream","getStreamError","isTypedArray","module","exports"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/streamx/index.js"],"sourcesContent":["const { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = require('queue-tick')\nconst FIFO = require('fast-fifo')\n\n/* eslint-disable no-multi-spaces */\n\n// 27 bits used total (4 from shared, 13 from read, and 10 from write)\nconst MAX = ((1 << 27) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b0000000000001 << 4\nconst READ_UPDATING         = 0b0000000000010 << 4\nconst READ_PRIMARY          = 0b0000000000100 << 4\nconst READ_QUEUED           = 0b0000000001000 << 4\nconst READ_RESUMED          = 0b0000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b0000000100000 << 4\nconst READ_ENDING           = 0b0000001000000 << 4\nconst READ_EMIT_DATA        = 0b0000010000000 << 4\nconst READ_EMIT_READABLE    = 0b0000100000000 << 4\nconst READ_EMITTED_READABLE = 0b0001000000000 << 4\nconst READ_DONE             = 0b0010000000000 << 4\nconst READ_NEXT_TICK        = 0b0100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b1000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\n\n// Write state (17 bit offset, 4 bit offset from shared state and 13 from read state)\nconst WRITE_ACTIVE     = 0b0000000001 << 17\nconst WRITE_UPDATING   = 0b0000000010 << 17\nconst WRITE_PRIMARY    = 0b0000000100 << 17\nconst WRITE_QUEUED     = 0b0000001000 << 17\nconst WRITE_UNDRAINED  = 0b0000010000 << 17\nconst WRITE_DONE       = 0b0000100000 << 17\nconst WRITE_EMIT_DRAIN = 0b0001000000 << 17\nconst WRITE_NEXT_TICK  = 0b0010000000 << 17\nconst WRITE_WRITING    = 0b0100000000 << 17\nconst WRITE_FINISHING  = 0b1000000000 << 17\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) data = this.map(data)\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === 0) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._readableState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n\n  on (name, fn) {\n    if (this._readableState !== null) {\n      if (name === 'data') {\n        this._duplexState |= (READ_EMIT_DATA | READ_RESUMED)\n        this._readableState.updateNextTick()\n      }\n      if (name === 'readable') {\n        this._duplexState |= READ_EMIT_READABLE\n        this._readableState.updateNextTick()\n      }\n    }\n\n    if (this._writableState !== null) {\n      if (name === 'drain') {\n        this._duplexState |= WRITE_EMIT_DRAIN\n        this._writableState.updateNextTick()\n      }\n    }\n\n    return super.on(name, fn)\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= READ_PAUSED\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const writes = state.queue.length + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction getStreamError (stream) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n  return err === STREAM_DESTROYED ? null : err // only explicit errors\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}