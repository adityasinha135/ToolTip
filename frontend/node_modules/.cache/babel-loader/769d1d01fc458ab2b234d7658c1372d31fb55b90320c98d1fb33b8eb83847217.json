{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getQueryHandlerAndSelector } from '../common/GetQueryHandler.js';\nimport { LazyArg } from '../common/LazyArg.js';\nimport { isString, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { AsyncIterableUtil } from '../util/AsyncIterableUtil.js';\nimport { JSHandle } from './JSHandle.js';\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nexport class ElementHandle extends JSHandle {\n  /**\n   * @internal\n   */\n  handle;\n  /**\n   * @internal\n   */\n  constructor(handle) {\n    super();\n    this.handle = handle;\n  }\n  /**\n   * @internal\n   */\n  get id() {\n    return this.handle.id;\n  }\n  /**\n   * @internal\n   */\n  get disposed() {\n    return this.handle.disposed;\n  }\n  async getProperty(propertyName) {\n    return this.handle.getProperty(propertyName);\n  }\n  /**\n   * @internal\n   */\n  async getProperties() {\n    return this.handle.getProperties();\n  }\n  /**\n   * @internal\n   */\n  async evaluate(pageFunction, ...args) {\n    return this.handle.evaluate(pageFunction, ...args);\n  }\n  /**\n   * @internal\n   */\n  evaluateHandle(pageFunction, ...args) {\n    return this.handle.evaluateHandle(pageFunction, ...args);\n  }\n  /**\n   * @internal\n   */\n  async jsonValue() {\n    return this.handle.jsonValue();\n  }\n  /**\n   * @internal\n   */\n  toString() {\n    return this.handle.toString();\n  }\n  /**\n   * @internal\n   */\n  async dispose() {\n    return await this.handle.dispose();\n  }\n  asElement() {\n    return this;\n  }\n  /**\n   * @internal\n   */\n  executionContext() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  get client() {\n    throw new Error('Not implemented');\n  }\n  get frame() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Queries the current element for an element matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  async $(selector) {\n    const {\n      updatedSelector,\n      QueryHandler\n    } = getQueryHandlerAndSelector(selector);\n    return await QueryHandler.queryOne(this, updatedSelector);\n  }\n  /**\n   * Queries the current element for all elements matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  async $$(selector) {\n    const {\n      updatedSelector,\n      QueryHandler\n    } = getQueryHandlerAndSelector(selector);\n    return AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));\n  }\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const tweetHandle = await page.$('.tweet');\n   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n   *   '100'\n   * );\n   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n   *   '10'\n   * );\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in this element's page's\n   * context. The first element matching the selector will be passed in as the\n   * first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $eval(selector, pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    const elementHandle = await this.$(selector);\n    if (!elementHandle) {\n      throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n    }\n    const result = await elementHandle.evaluate(pageFunction, ...args);\n    await elementHandle.dispose();\n    return result;\n  }\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   * HTML:\n   *\n   * ```html\n   * <div class=\"feed\">\n   *   <div class=\"tweet\">Hello!</div>\n   *   <div class=\"tweet\">Hi!</div>\n   * </div>\n   * ```\n   *\n   * JavaScript:\n   *\n   * ```js\n   * const feedHandle = await page.$('.feed');\n   * expect(\n   *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))\n   * ).toEqual(['Hello!', 'Hi!']);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in the element's page's\n   * context. An array of elements matching the given selector will be passed to\n   * the function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $$eval(selector, pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    const results = await this.$$(selector);\n    const elements = await this.evaluateHandle((_, ...elements) => {\n      return elements;\n    }, ...results);\n    const [result] = await Promise.all([elements.evaluate(pageFunction, ...args), ...results.map(results => {\n      return results.dispose();\n    })]);\n    await elements.dispose();\n    return result;\n  }\n  /**\n   * @deprecated Use {@link ElementHandle.$$} with the `xpath` prefix.\n   *\n   * Example: `await elementHandle.$$('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the elementHandle.\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * If there are no such elements, the method will resolve to an empty array.\n   * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}\n   */\n  async $x(expression) {\n    if (expression.startsWith('//')) {\n      expression = `.${expression}`;\n    }\n    return this.$$(`xpath/${expression}`);\n  }\n  /**\n   * Wait for an element matching the given selector to appear in the current\n   * element.\n   *\n   * Unlike {@link Frame.waitForSelector}, this method does not work across\n   * navigations or if the element is detached from DOM.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  async waitForSelector(selector, options = {}) {\n    const {\n      updatedSelector,\n      QueryHandler\n    } = getQueryHandlerAndSelector(selector);\n    return await QueryHandler.waitFor(this, updatedSelector, options);\n  }\n  async #checkVisibility(visibility) {\n    const element = await this.frame.isolatedRealm().adoptHandle(this);\n    try {\n      return await this.frame.isolatedRealm().evaluate(async (PuppeteerUtil, element, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      }, LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }), element, visibility);\n    } finally {\n      await element.dispose();\n    }\n  }\n  /**\n   * Checks if an element is visible using the same mechanism as\n   * {@link ElementHandle.waitForSelector}.\n   */\n  async isVisible() {\n    return this.#checkVisibility(true);\n  }\n  /**\n   * Checks if an element is hidden using the same mechanism as\n   * {@link ElementHandle.waitForSelector}.\n   */\n  async isHidden() {\n    return this.#checkVisibility(false);\n  }\n  /**\n   * @deprecated Use {@link ElementHandle.waitForSelector} with the `xpath`\n   * prefix.\n   *\n   * Example: `await elementHandle.waitForSelector('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the elementHandle.\n   *\n   * Wait for the `xpath` within the element. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * @example\n   * This method works across navigation.\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForXPath('//img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param xpath - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an\n   * element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by xpath string is\n   * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is\n   * not found in DOM, otherwise resolves to `ElementHandle`.\n   * @remarks\n   * The optional Argument `options` have properties:\n   *\n   * - `visible`: A boolean to wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: A boolean wait for element to not be found in the DOM or to be\n   *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *   Defaults to `false`.\n   *\n   * - `timeout`: A number which is maximum time to wait for in milliseconds.\n   *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n   *   default value can be changed by using the {@link Page.setDefaultTimeout}\n   *   method.\n   */\n  async waitForXPath(xpath, options = {}) {\n    if (xpath.startsWith('//')) {\n      xpath = `.${xpath}`;\n    }\n    return this.waitForSelector(`xpath/${xpath}`, options);\n  }\n  /**\n   * Converts the current handle to the given element type.\n   *\n   * @example\n   *\n   * ```ts\n   * const element: ElementHandle<Element> = await page.$(\n   *   '.class-name-of-anchor'\n   * );\n   * // DO NOT DISPOSE `element`, this will be always be the same handle.\n   * const anchor: ElementHandle<HTMLAnchorElement> = await element.toElement(\n   *   'a'\n   * );\n   * ```\n   *\n   * @param tagName - The tag name of the desired element type.\n   * @throws An error if the handle does not match. **The handle will not be\n   * automatically disposed.**\n   */\n  async toElement(tagName) {\n    const isMatchingTagName = await this.evaluate((node, tagName) => {\n      return node.nodeName === tagName.toUpperCase();\n    }, tagName);\n    if (!isMatchingTagName) {\n      throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n    }\n    return this;\n  }\n  /**\n   * Resolves to the content frame for element handles referencing\n   * iframe nodes, or null otherwise\n   */\n  async contentFrame() {\n    throw new Error('Not implemented');\n  }\n  async clickablePoint() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async hover() {\n    throw new Error('Not implemented');\n  }\n  async click() {\n    throw new Error('Not implemented');\n  }\n  async drag() {\n    throw new Error('Not implemented');\n  }\n  async dragEnter() {\n    throw new Error('Not implemented');\n  }\n  async dragOver() {\n    throw new Error('Not implemented');\n  }\n  async drop() {\n    throw new Error('Not implemented');\n  }\n  async dragAndDrop() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * handle.select('blue'); // single selection\n   * handle.select('red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   */\n  async select(...values) {\n    for (const value of values) {\n      assert(isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + typeof value + '\"');\n    }\n    return this.evaluate((element, vals) => {\n      const values = new Set(vals);\n      if (!(element instanceof HTMLSelectElement)) {\n        throw new Error('Element is not a <select> element.');\n      }\n      const selectedValues = new Set();\n      if (!element.multiple) {\n        for (const option of element.options) {\n          option.selected = false;\n        }\n        for (const option of element.options) {\n          if (values.has(option.value)) {\n            option.selected = true;\n            selectedValues.add(option.value);\n            break;\n          }\n        }\n      } else {\n        for (const option of element.options) {\n          option.selected = values.has(option.value);\n          if (option.selected) {\n            selectedValues.add(option.value);\n          }\n        }\n      }\n      element.dispatchEvent(new Event('input', {\n        bubbles: true\n      }));\n      element.dispatchEvent(new Event('change', {\n        bubbles: true\n      }));\n      return [...selectedValues.values()];\n    }, values);\n  }\n  async uploadFile() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Touchscreen.tap} to tap in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async tap() {\n    throw new Error('Not implemented');\n  }\n  async touchStart() {\n    throw new Error('Not implemented');\n  }\n  async touchMove() {\n    throw new Error('Not implemented');\n  }\n  async touchEnd() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n   */\n  async focus() {\n    await this.evaluate(element => {\n      if (!(element instanceof HTMLElement)) {\n        throw new Error('Cannot focus non-HTMLElement');\n      }\n      return element.focus();\n    });\n  }\n  async type() {\n    throw new Error('Not implemented');\n  }\n  async press() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * This method returns the bounding box of the element (relative to the main frame),\n   * or `null` if the element is not visible.\n   */\n  async boundingBox() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * This method returns boxes of the element, or `null` if the element is not visible.\n   *\n   * @remarks\n   *\n   * Boxes are represented as an array of points;\n   * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n   */\n  async boxModel() {\n    throw new Error('Not implemented');\n  }\n  async screenshot() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  async assertConnectedElement() {\n    const error = await this.evaluate(async element => {\n      if (!element.isConnected) {\n        return 'Node is detached from document';\n      }\n      if (element.nodeType !== Node.ELEMENT_NODE) {\n        return 'Node is not of type HTMLElement';\n      }\n      return;\n    });\n    if (error) {\n      throw new Error(error);\n    }\n  }\n  /**\n   * @internal\n   */\n  async scrollIntoViewIfNeeded() {\n    if (await this.isIntersectingViewport({\n      threshold: 1\n    })) {\n      return;\n    }\n    await this.scrollIntoView();\n  }\n  /**\n   * Resolves to true if the element is visible in the current viewport. If an\n   * element is an SVG, we check if the svg owner element is in the viewport\n   * instead. See https://crbug.com/963246.\n   *\n   * @param options - Threshold for the intersection between 0 (no intersection) and 1\n   * (full intersection). Defaults to 1.\n   */\n  async isIntersectingViewport(options) {\n    await this.assertConnectedElement();\n    const {\n      threshold = 0\n    } = options ?? {};\n    const svgHandle = await this.#asSVGElementHandle(this);\n    const intersectionTarget = svgHandle ? await this.#getOwnerSVGElement(svgHandle) : this;\n    try {\n      return await intersectionTarget.evaluate(async (element, threshold) => {\n        const visibleRatio = await new Promise(resolve => {\n          const observer = new IntersectionObserver(entries => {\n            resolve(entries[0].intersectionRatio);\n            observer.disconnect();\n          });\n          observer.observe(element);\n        });\n        return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n      }, threshold);\n    } finally {\n      if (intersectionTarget !== this) {\n        await intersectionTarget.dispose();\n      }\n    }\n  }\n  /**\n   * Scrolls the element into view using either the automation protocol client\n   * or by calling element.scrollIntoView.\n   */\n  async scrollIntoView() {\n    await this.assertConnectedElement();\n    await this.evaluate(async element => {\n      element.scrollIntoView({\n        block: 'center',\n        inline: 'center',\n        behavior: 'instant'\n      });\n    });\n  }\n  /**\n   * Returns true if an element is an SVGElement (included svg, path, rect\n   * etc.).\n   */\n  async #asSVGElementHandle(handle) {\n    if (await handle.evaluate(element => {\n      return element instanceof SVGElement;\n    })) {\n      return handle;\n    } else {\n      return null;\n    }\n  }\n  async #getOwnerSVGElement(handle) {\n    // SVGSVGElement.ownerSVGElement === null.\n    return await handle.evaluateHandle(element => {\n      if (element instanceof SVGSVGElement) {\n        return element;\n      }\n      return element.ownerSVGElement;\n    });\n  }\n  /**\n   * @internal\n   */\n  assertElementHasWorld() {\n    assert(this.executionContext()._world);\n  }\n  autofill() {\n    throw new Error('Not implemented');\n  }\n}","map":{"version":3,"names":["getQueryHandlerAndSelector","LazyArg","isString","withSourcePuppeteerURLIfNone","assert","AsyncIterableUtil","JSHandle","ElementHandle","handle","constructor","id","disposed","getProperty","propertyName","getProperties","evaluate","pageFunction","args","evaluateHandle","jsonValue","toString","dispose","asElement","executionContext","Error","client","frame","$","selector","updatedSelector","QueryHandler","queryOne","$$","collect","queryAll","$eval","name","elementHandle","result","$$eval","results","elements","_","Promise","all","map","$x","expression","startsWith","waitForSelector","options","waitFor","checkVisibility","#checkVisibility","visibility","element","isolatedRealm","adoptHandle","PuppeteerUtil","Boolean","create","context","puppeteerUtil","isVisible","isHidden","waitForXPath","xpath","toElement","tagName","isMatchingTagName","node","nodeName","toUpperCase","contentFrame","clickablePoint","hover","click","drag","dragEnter","dragOver","drop","dragAndDrop","select","values","value","vals","Set","HTMLSelectElement","selectedValues","multiple","option","selected","has","add","dispatchEvent","Event","bubbles","uploadFile","tap","touchStart","touchMove","touchEnd","focus","HTMLElement","type","press","boundingBox","boxModel","screenshot","assertConnectedElement","error","isConnected","nodeType","Node","ELEMENT_NODE","scrollIntoViewIfNeeded","isIntersectingViewport","threshold","scrollIntoView","svgHandle","asSVGElementHandle","intersectionTarget","getOwnerSVGElement","visibleRatio","resolve","observer","IntersectionObserver","entries","intersectionRatio","disconnect","observe","block","inline","behavior","#asSVGElementHandle","SVGElement","#getOwnerSVGElement","SVGSVGElement","ownerSVGElement","assertElementHasWorld","_world","autofill"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/api/ElementHandle.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Protocol} from 'devtools-protocol';\n\nimport {Frame} from '../api/Frame.js';\nimport {CDPSession} from '../common/Connection.js';\nimport {ExecutionContext} from '../common/ExecutionContext.js';\nimport {getQueryHandlerAndSelector} from '../common/GetQueryHandler.js';\nimport {WaitForSelectorOptions} from '../common/IsolatedWorld.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport {\n  ElementFor,\n  EvaluateFuncWith,\n  HandleFor,\n  HandleOr,\n  NodeFor,\n} from '../common/types.js';\nimport {KeyInput} from '../common/USKeyboardLayout.js';\nimport {isString, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\n\nimport {\n  KeyPressOptions,\n  MouseClickOptions,\n  KeyboardTypeOptions,\n} from './Input.js';\nimport {JSHandle} from './JSHandle.js';\nimport {ScreenshotOptions} from './Page.js';\n\n/**\n * @public\n */\nexport interface BoxModel {\n  content: Point[];\n  padding: Point[];\n  border: Point[];\n  margin: Point[];\n  width: number;\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface BoundingBox extends Point {\n  /**\n   * the width of the element in pixels.\n   */\n  width: number;\n  /**\n   * the height of the element in pixels.\n   */\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface Offset {\n  /**\n   * x-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  x: number;\n  /**\n   * y-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ClickOptions extends MouseClickOptions {\n  /**\n   * Offset for the clickable point relative to the top-left corner of the border box.\n   */\n  offset?: Offset;\n}\n\n/**\n * @public\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\n\nexport class ElementHandle<\n  ElementType extends Node = Element,\n> extends JSHandle<ElementType> {\n  /**\n   * @internal\n   */\n  protected handle;\n\n  /**\n   * @internal\n   */\n  constructor(handle: JSHandle<ElementType>) {\n    super();\n    this.handle = handle;\n  }\n\n  /**\n   * @internal\n   */\n  override get id(): string | undefined {\n    return this.handle.id;\n  }\n\n  /**\n   * @internal\n   */\n  override get disposed(): boolean {\n    return this.handle.disposed;\n  }\n\n  /**\n   * @internal\n   */\n  override async getProperty<K extends keyof ElementType>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<ElementType[K]>>;\n  /**\n   * @internal\n   */\n  override async getProperty(propertyName: string): Promise<JSHandle<unknown>>;\n  override async getProperty<K extends keyof ElementType>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<ElementType[K]>> {\n    return this.handle.getProperty(propertyName);\n  }\n\n  /**\n   * @internal\n   */\n  override async getProperties(): Promise<Map<string, JSHandle>> {\n    return this.handle.getProperties();\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    return this.handle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  override evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return this.handle.evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  override async jsonValue(): Promise<ElementType> {\n    return this.handle.jsonValue();\n  }\n\n  /**\n   * @internal\n   */\n  override toString(): string {\n    return this.handle.toString();\n  }\n\n  /**\n   * @internal\n   */\n  override async dispose(): Promise<void> {\n    return await this.handle.dispose();\n  }\n\n  override asElement(): ElementHandle<ElementType> {\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  override executionContext(): ExecutionContext {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  override get client(): CDPSession {\n    throw new Error('Not implemented');\n  }\n\n  get frame(): Frame {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Queries the current element for an element matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.queryOne(\n      this,\n      updatedSelector\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  /**\n   * Queries the current element for all elements matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return AsyncIterableUtil.collect(\n      QueryHandler.queryAll(this, updatedSelector)\n    ) as Promise<Array<ElementHandle<NodeFor<Selector>>>>;\n  }\n\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const tweetHandle = await page.$('.tweet');\n   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n   *   '100'\n   * );\n   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n   *   '10'\n   * );\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in this element's page's\n   * context. The first element matching the selector will be passed in as the\n   * first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    const elementHandle = await this.$(selector);\n    if (!elementHandle) {\n      throw new Error(\n        `Error: failed to find element matching selector \"${selector}\"`\n      );\n    }\n    const result = await elementHandle.evaluate(pageFunction, ...args);\n    await elementHandle.dispose();\n    return result;\n  }\n\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   * HTML:\n   *\n   * ```html\n   * <div class=\"feed\">\n   *   <div class=\"tweet\">Hello!</div>\n   *   <div class=\"tweet\">Hi!</div>\n   * </div>\n   * ```\n   *\n   * JavaScript:\n   *\n   * ```js\n   * const feedHandle = await page.$('.feed');\n   * expect(\n   *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))\n   * ).toEqual(['Hello!', 'Hi!']);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in the element's page's\n   * context. An array of elements matching the given selector will be passed to\n   * the function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    const results = await this.$$(selector);\n    const elements = await this.evaluateHandle(\n      (_, ...elements) => {\n        return elements;\n      },\n      ...results\n    );\n    const [result] = await Promise.all([\n      elements.evaluate(pageFunction, ...args),\n      ...results.map(results => {\n        return results.dispose();\n      }),\n    ]);\n    await elements.dispose();\n    return result;\n  }\n\n  /**\n   * @deprecated Use {@link ElementHandle.$$} with the `xpath` prefix.\n   *\n   * Example: `await elementHandle.$$('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the elementHandle.\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * If there are no such elements, the method will resolve to an empty array.\n   * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}\n   */\n  async $x(expression: string): Promise<Array<ElementHandle<Node>>> {\n    if (expression.startsWith('//')) {\n      expression = `.${expression}`;\n    }\n    return this.$$(`xpath/${expression}`);\n  }\n\n  /**\n   * Wait for an element matching the given selector to appear in the current\n   * element.\n   *\n   * Unlike {@link Frame.waitForSelector}, this method does not work across\n   * navigations or if the element is detached from DOM.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.waitFor(\n      this,\n      updatedSelector,\n      options\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  async #checkVisibility(visibility: boolean): Promise<boolean> {\n    const element = await this.frame.isolatedRealm().adoptHandle(this);\n    try {\n      return await this.frame.isolatedRealm().evaluate(\n        async (PuppeteerUtil, element, visibility) => {\n          return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n        },\n        LazyArg.create(context => {\n          return context.puppeteerUtil;\n        }),\n        element,\n        visibility\n      );\n    } finally {\n      await element.dispose();\n    }\n  }\n\n  /**\n   * Checks if an element is visible using the same mechanism as\n   * {@link ElementHandle.waitForSelector}.\n   */\n  async isVisible(): Promise<boolean> {\n    return this.#checkVisibility(true);\n  }\n\n  /**\n   * Checks if an element is hidden using the same mechanism as\n   * {@link ElementHandle.waitForSelector}.\n   */\n  async isHidden(): Promise<boolean> {\n    return this.#checkVisibility(false);\n  }\n\n  /**\n   * @deprecated Use {@link ElementHandle.waitForSelector} with the `xpath`\n   * prefix.\n   *\n   * Example: `await elementHandle.waitForSelector('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the elementHandle.\n   *\n   * Wait for the `xpath` within the element. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * @example\n   * This method works across navigation.\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForXPath('//img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param xpath - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an\n   * element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by xpath string is\n   * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is\n   * not found in DOM, otherwise resolves to `ElementHandle`.\n   * @remarks\n   * The optional Argument `options` have properties:\n   *\n   * - `visible`: A boolean to wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: A boolean wait for element to not be found in the DOM or to be\n   *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *   Defaults to `false`.\n   *\n   * - `timeout`: A number which is maximum time to wait for in milliseconds.\n   *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n   *   default value can be changed by using the {@link Page.setDefaultTimeout}\n   *   method.\n   */\n  async waitForXPath(\n    xpath: string,\n    options: {\n      visible?: boolean;\n      hidden?: boolean;\n      timeout?: number;\n    } = {}\n  ): Promise<ElementHandle<Node> | null> {\n    if (xpath.startsWith('//')) {\n      xpath = `.${xpath}`;\n    }\n    return this.waitForSelector(`xpath/${xpath}`, options);\n  }\n\n  /**\n   * Converts the current handle to the given element type.\n   *\n   * @example\n   *\n   * ```ts\n   * const element: ElementHandle<Element> = await page.$(\n   *   '.class-name-of-anchor'\n   * );\n   * // DO NOT DISPOSE `element`, this will be always be the same handle.\n   * const anchor: ElementHandle<HTMLAnchorElement> = await element.toElement(\n   *   'a'\n   * );\n   * ```\n   *\n   * @param tagName - The tag name of the desired element type.\n   * @throws An error if the handle does not match. **The handle will not be\n   * automatically disposed.**\n   */\n  async toElement<\n    K extends keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap,\n  >(tagName: K): Promise<HandleFor<ElementFor<K>>> {\n    const isMatchingTagName = await this.evaluate((node, tagName) => {\n      return node.nodeName === tagName.toUpperCase();\n    }, tagName);\n    if (!isMatchingTagName) {\n      throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n    }\n    return this as unknown as HandleFor<ElementFor<K>>;\n  }\n\n  /**\n   * Resolves to the content frame for element handles referencing\n   * iframe nodes, or null otherwise\n   */\n  async contentFrame(): Promise<Frame | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Returns the middle point within an element unless a specific offset is provided.\n   */\n  async clickablePoint(offset?: Offset): Promise<Point>;\n  async clickablePoint(): Promise<Point> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async hover(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page | Page.mouse} to click in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async click(\n    this: ElementHandle<Element>,\n    options?: ClickOptions\n  ): Promise<void>;\n  async click(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method creates and captures a dragevent from the element.\n   */\n  async drag(\n    this: ElementHandle<Element>,\n    target: Point\n  ): Promise<Protocol.Input.DragData>;\n  async drag(this: ElementHandle<Element>): Promise<Protocol.Input.DragData> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method creates a `dragenter` event on the element.\n   */\n  async dragEnter(\n    this: ElementHandle<Element>,\n    data?: Protocol.Input.DragData\n  ): Promise<void>;\n  async dragEnter(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method creates a `dragover` event on the element.\n   */\n  async dragOver(\n    this: ElementHandle<Element>,\n    data?: Protocol.Input.DragData\n  ): Promise<void>;\n  async dragOver(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method triggers a drop on the element.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    data?: Protocol.Input.DragData\n  ): Promise<void>;\n  async drop(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method triggers a dragenter, dragover, and drop on the element.\n   */\n  async dragAndDrop(\n    this: ElementHandle<Element>,\n    target: ElementHandle<Node>,\n    options?: {delay: number}\n  ): Promise<void>;\n  async dragAndDrop(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * handle.select('blue'); // single selection\n   * handle.select('red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   */\n  async select(...values: string[]): Promise<string[]> {\n    for (const value of values) {\n      assert(\n        isString(value),\n        'Values must be strings. Found value \"' +\n          value +\n          '\" of type \"' +\n          typeof value +\n          '\"'\n      );\n    }\n\n    return this.evaluate((element, vals): string[] => {\n      const values = new Set(vals);\n      if (!(element instanceof HTMLSelectElement)) {\n        throw new Error('Element is not a <select> element.');\n      }\n\n      const selectedValues = new Set<string>();\n      if (!element.multiple) {\n        for (const option of element.options) {\n          option.selected = false;\n        }\n        for (const option of element.options) {\n          if (values.has(option.value)) {\n            option.selected = true;\n            selectedValues.add(option.value);\n            break;\n          }\n        }\n      } else {\n        for (const option of element.options) {\n          option.selected = values.has(option.value);\n          if (option.selected) {\n            selectedValues.add(option.value);\n          }\n        }\n      }\n      element.dispatchEvent(new Event('input', {bubbles: true}));\n      element.dispatchEvent(new Event('change', {bubbles: true}));\n      return [...selectedValues.values()];\n    }, values);\n  }\n\n  /**\n   * Sets the value of an\n   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}\n   * to the given file paths.\n   *\n   * @remarks This will not validate whether the file paths exists. Also, if a\n   * path is relative, then it is resolved against the\n   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.\n   * For locals script connecting to remote chrome environments, paths must be\n   * absolute.\n   */\n  async uploadFile(\n    this: ElementHandle<HTMLInputElement>,\n    ...paths: string[]\n  ): Promise<void>;\n  async uploadFile(this: ElementHandle<HTMLInputElement>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Touchscreen.tap} to tap in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async tap(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  async touchStart(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  async touchMove(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  async touchEnd(this: ElementHandle<Element>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n   */\n  async focus(): Promise<void> {\n    await this.evaluate(element => {\n      if (!(element instanceof HTMLElement)) {\n        throw new Error('Cannot focus non-HTMLElement');\n      }\n      return element.focus();\n    });\n  }\n\n  /**\n   * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n   * `keyup` event for each character in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`,\n   * use {@link ElementHandle.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await elementHandle.type('Hello'); // Types instantly\n   * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @example\n   * An example of typing into a text field and then submitting the form:\n   *\n   * ```ts\n   * const elementHandle = await page.$('input');\n   * await elementHandle.type('some text');\n   * await elementHandle.press('Enter');\n   * ```\n   *\n   * @param options - Delay in milliseconds. Defaults to 0.\n   */\n  async type(\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void>;\n  async type(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n   *\n   * @remarks\n   * If `key` is a single character and no modifier keys besides `Shift`\n   * are being held down, a `keypress`/`input` event will also be generated.\n   * The `text` option can be specified to force an input event to be generated.\n   *\n   * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n   * will type the text in upper case.\n   *\n   * @param key - Name of key to press, such as `ArrowLeft`.\n   * See {@link KeyInput} for a list of all key names.\n   */\n  async press(\n    key: KeyInput,\n    options?: Readonly<KeyPressOptions>\n  ): Promise<void>;\n  async press(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method returns the bounding box of the element (relative to the main frame),\n   * or `null` if the element is not visible.\n   */\n  async boundingBox(): Promise<BoundingBox | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method returns boxes of the element, or `null` if the element is not visible.\n   *\n   * @remarks\n   *\n   * Boxes are represented as an array of points;\n   * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n   */\n  async boxModel(): Promise<BoxModel | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Page.(screenshot:3) } to take a screenshot of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async screenshot(\n    this: ElementHandle<Element>,\n    options?: ScreenshotOptions\n  ): Promise<string | Buffer>;\n  async screenshot(this: ElementHandle<Element>): Promise<string | Buffer> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  protected async assertConnectedElement(): Promise<void> {\n    const error = await this.evaluate(\n      async (element): Promise<string | undefined> => {\n        if (!element.isConnected) {\n          return 'Node is detached from document';\n        }\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n          return 'Node is not of type HTMLElement';\n        }\n        return;\n      }\n    );\n\n    if (error) {\n      throw new Error(error);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected async scrollIntoViewIfNeeded(\n    this: ElementHandle<Element>\n  ): Promise<void> {\n    if (\n      await this.isIntersectingViewport({\n        threshold: 1,\n      })\n    ) {\n      return;\n    }\n    await this.scrollIntoView();\n  }\n\n  /**\n   * Resolves to true if the element is visible in the current viewport. If an\n   * element is an SVG, we check if the svg owner element is in the viewport\n   * instead. See https://crbug.com/963246.\n   *\n   * @param options - Threshold for the intersection between 0 (no intersection) and 1\n   * (full intersection). Defaults to 1.\n   */\n  async isIntersectingViewport(\n    this: ElementHandle<Element>,\n    options?: {\n      threshold?: number;\n    }\n  ): Promise<boolean> {\n    await this.assertConnectedElement();\n\n    const {threshold = 0} = options ?? {};\n    const svgHandle = await this.#asSVGElementHandle(this);\n    const intersectionTarget: ElementHandle<Element> = svgHandle\n      ? await this.#getOwnerSVGElement(svgHandle)\n      : this;\n\n    try {\n      return await intersectionTarget.evaluate(async (element, threshold) => {\n        const visibleRatio = await new Promise<number>(resolve => {\n          const observer = new IntersectionObserver(entries => {\n            resolve(entries[0]!.intersectionRatio);\n            observer.disconnect();\n          });\n          observer.observe(element);\n        });\n        return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n      }, threshold);\n    } finally {\n      if (intersectionTarget !== this) {\n        await intersectionTarget.dispose();\n      }\n    }\n  }\n\n  /**\n   * Scrolls the element into view using either the automation protocol client\n   * or by calling element.scrollIntoView.\n   */\n  async scrollIntoView(this: ElementHandle<Element>): Promise<void> {\n    await this.assertConnectedElement();\n    await this.evaluate(async (element): Promise<void> => {\n      element.scrollIntoView({\n        block: 'center',\n        inline: 'center',\n        behavior: 'instant',\n      });\n    });\n  }\n\n  /**\n   * Returns true if an element is an SVGElement (included svg, path, rect\n   * etc.).\n   */\n  async #asSVGElementHandle(\n    handle: ElementHandle<Element>\n  ): Promise<ElementHandle<SVGElement> | null> {\n    if (\n      await handle.evaluate(element => {\n        return element instanceof SVGElement;\n      })\n    ) {\n      return handle as ElementHandle<SVGElement>;\n    } else {\n      return null;\n    }\n  }\n\n  async #getOwnerSVGElement(\n    handle: ElementHandle<SVGElement>\n  ): Promise<ElementHandle<SVGSVGElement>> {\n    // SVGSVGElement.ownerSVGElement === null.\n    return await handle.evaluateHandle(element => {\n      if (element instanceof SVGSVGElement) {\n        return element;\n      }\n      return element.ownerSVGElement!;\n    });\n  }\n\n  /**\n   * @internal\n   */\n  assertElementHasWorld(): asserts this {\n    assert(this.executionContext()._world);\n  }\n\n  /**\n   * If the element is a form input, you can use {@link ElementHandle.autofill}\n   * to test if the form is compatible with the browser's autofill\n   * implementation. Throws an error if the form cannot be autofilled.\n   *\n   * @remarks\n   *\n   * Currently, Puppeteer supports auto-filling credit card information only and\n   * in Chrome in the new headless and headful modes only.\n   *\n   * ```ts\n   * // Select an input on the credit card form.\n   * const name = await page.waitForSelector('form #name');\n   * // Trigger autofill with the desired data.\n   * await name.autofill({\n   *   creditCard: {\n   *     number: '4444444444444444',\n   *     name: 'John Smith',\n   *     expiryMonth: '01',\n   *     expiryYear: '2030',\n   *     cvc: '123',\n   *   },\n   * });\n   * ```\n   */\n  autofill(data: AutofillData): Promise<void>;\n  autofill(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * @public\n */\nexport interface AutofillData {\n  creditCard: {\n    // See https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#type-CreditCard.\n    number: string;\n    name: string;\n    expiryMonth: string;\n    expiryYear: string;\n    cvc: string;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}