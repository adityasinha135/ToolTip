{"ast":null,"code":"/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { Connection } from './Connection.js';\nimport { EventEmitter } from './EventEmitter.js';\n/**\n * FirefoxTargetManager implements target management using\n * `Target.setDiscoverTargets` without using auto-attach. It, therefore, creates\n * targets that lazily establish their CDP sessions.\n *\n * Although the approach is potentially flaky, there is no other way for Firefox\n * because Firefox's CDP implementation does not support auto-attach.\n *\n * Firefox does not support targetInfoChanged and detachedFromTarget events:\n *\n * - https://bugzilla.mozilla.org/show_bug.cgi?id=1610855\n * - https://bugzilla.mozilla.org/show_bug.cgi?id=1636979\n *   @internal\n */\nexport class FirefoxTargetManager extends EventEmitter {\n  #connection;\n  /**\n   * Keeps track of the following events: 'Target.targetCreated',\n   * 'Target.targetDestroyed'.\n   *\n   * A target becomes discovered when 'Target.targetCreated' is received.\n   * A target is removed from this map once 'Target.targetDestroyed' is\n   * received.\n   *\n   * `targetFilterCallback` has no effect on this map.\n   */\n  #discoveredTargetsByTargetId = new Map();\n  /**\n   * Keeps track of targets that were created via 'Target.targetCreated'\n   * and which one are not filtered out by `targetFilterCallback`.\n   *\n   * The target is removed from here once it's been destroyed.\n   */\n  #availableTargetsByTargetId = new Map();\n  /**\n   * Tracks which sessions attach to which target.\n   */\n  #availableTargetsBySessionId = new Map();\n  /**\n   * If a target was filtered out by `targetFilterCallback`, we still receive\n   * events about it from CDP, but we don't forward them to the rest of Puppeteer.\n   */\n  #ignoredTargets = new Set();\n  #targetFilterCallback;\n  #targetFactory;\n  #targetInterceptors = new WeakMap();\n  #attachedToTargetListenersBySession = new WeakMap();\n  #initializeDeferred = Deferred.create();\n  #targetsIdsForInit = new Set();\n  constructor(connection, targetFactory, targetFilterCallback) {\n    super();\n    this.#connection = connection;\n    this.#targetFilterCallback = targetFilterCallback;\n    this.#targetFactory = targetFactory;\n    this.#connection.on('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.on('sessiondetached', this.#onSessionDetached);\n    this.setupAttachmentListeners(this.#connection);\n  }\n  addTargetInterceptor(client, interceptor) {\n    const interceptors = this.#targetInterceptors.get(client) || [];\n    interceptors.push(interceptor);\n    this.#targetInterceptors.set(client, interceptors);\n  }\n  removeTargetInterceptor(client, interceptor) {\n    const interceptors = this.#targetInterceptors.get(client) || [];\n    this.#targetInterceptors.set(client, interceptors.filter(currentInterceptor => {\n      return currentInterceptor !== interceptor;\n    }));\n  }\n  setupAttachmentListeners(session) {\n    const listener = event => {\n      return this.#onAttachedToTarget(session, event);\n    };\n    assert(!this.#attachedToTargetListenersBySession.has(session));\n    this.#attachedToTargetListenersBySession.set(session, listener);\n    session.on('Target.attachedToTarget', listener);\n  }\n  #onSessionDetached = session => {\n    this.removeSessionListeners(session);\n    this.#targetInterceptors.delete(session);\n    this.#availableTargetsBySessionId.delete(session.id());\n  };\n  removeSessionListeners(session) {\n    if (this.#attachedToTargetListenersBySession.has(session)) {\n      session.off('Target.attachedToTarget', this.#attachedToTargetListenersBySession.get(session));\n      this.#attachedToTargetListenersBySession.delete(session);\n    }\n  }\n  getAvailableTargets() {\n    return this.#availableTargetsByTargetId;\n  }\n  dispose() {\n    this.#connection.off('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);\n  }\n  async initialize() {\n    await this.#connection.send('Target.setDiscoverTargets', {\n      discover: true,\n      filter: [{}]\n    });\n    this.#targetsIdsForInit = new Set(this.#discoveredTargetsByTargetId.keys());\n    await this.#initializeDeferred.valueOrThrow();\n  }\n  #onTargetCreated = async event => {\n    if (this.#discoveredTargetsByTargetId.has(event.targetInfo.targetId)) {\n      return;\n    }\n    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);\n    if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {\n      const target = this.#targetFactory(event.targetInfo, undefined);\n      target._initialize();\n      this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);\n      this.#finishInitializationIfReady(target._targetId);\n      return;\n    }\n    const target = this.#targetFactory(event.targetInfo, undefined);\n    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {\n      this.#ignoredTargets.add(event.targetInfo.targetId);\n      this.#finishInitializationIfReady(event.targetInfo.targetId);\n      return;\n    }\n    target._initialize();\n    this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);\n    this.emit(\"targetAvailable\" /* TargetManagerEmittedEvents.TargetAvailable */, target);\n    this.#finishInitializationIfReady(target._targetId);\n  };\n  #onTargetDestroyed = event => {\n    this.#discoveredTargetsByTargetId.delete(event.targetId);\n    this.#finishInitializationIfReady(event.targetId);\n    const target = this.#availableTargetsByTargetId.get(event.targetId);\n    if (target) {\n      this.emit(\"targetGone\" /* TargetManagerEmittedEvents.TargetGone */, target);\n      this.#availableTargetsByTargetId.delete(event.targetId);\n    }\n  };\n  #onAttachedToTarget = async (parentSession, event) => {\n    const targetInfo = event.targetInfo;\n    const session = this.#connection.session(event.sessionId);\n    if (!session) {\n      throw new Error(`Session ${event.sessionId} was not created.`);\n    }\n    const target = this.#availableTargetsByTargetId.get(targetInfo.targetId);\n    assert(target, `Target ${targetInfo.targetId} is missing`);\n    this.setupAttachmentListeners(session);\n    this.#availableTargetsBySessionId.set(session.id(), this.#availableTargetsByTargetId.get(targetInfo.targetId));\n    for (const hook of this.#targetInterceptors.get(parentSession) || []) {\n      if (!(parentSession instanceof Connection)) {\n        assert(this.#availableTargetsBySessionId.has(parentSession.id()));\n      }\n      await hook(target, parentSession instanceof Connection ? null : this.#availableTargetsBySessionId.get(parentSession.id()));\n    }\n  };\n  #finishInitializationIfReady(targetId) {\n    this.#targetsIdsForInit.delete(targetId);\n    if (this.#targetsIdsForInit.size === 0) {\n      this.#initializeDeferred.resolve();\n    }\n  }\n}","map":{"version":3,"names":["assert","Deferred","Connection","EventEmitter","FirefoxTargetManager","connection","discoveredTargetsByTargetId","Map","availableTargetsByTargetId","availableTargetsBySessionId","ignoredTargets","Set","targetFilterCallback","targetFactory","targetInterceptors","WeakMap","attachedToTargetListenersBySession","initializeDeferred","create","targetsIdsForInit","constructor","on","onTargetCreated","onTargetDestroyed","onSessionDetached","setupAttachmentListeners","addTargetInterceptor","client","interceptor","interceptors","get","push","set","removeTargetInterceptor","filter","currentInterceptor","session","listener","event","onAttachedToTarget","has","removeSessionListeners","delete","id","off","getAvailableTargets","dispose","initialize","send","discover","keys","valueOrThrow","targetInfo","targetId","type","attached","target","undefined","_initialize","finishInitializationIfReady","_targetId","add","emit","#onAttachedToTarget","parentSession","sessionId","Error","hook","#finishInitializationIfReady","size","resolve"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/common/FirefoxTargetManager.ts"],"sourcesContent":["/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Protocol} from 'devtools-protocol';\n\nimport {TargetFilterCallback} from '../api/Browser.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\n\nimport {CDPSession, Connection} from './Connection.js';\nimport {EventEmitter} from './EventEmitter.js';\nimport {CDPTarget} from './Target.js';\nimport {\n  TargetFactory,\n  TargetInterceptor,\n  TargetManagerEmittedEvents,\n  TargetManager,\n} from './TargetManager.js';\n\n/**\n * FirefoxTargetManager implements target management using\n * `Target.setDiscoverTargets` without using auto-attach. It, therefore, creates\n * targets that lazily establish their CDP sessions.\n *\n * Although the approach is potentially flaky, there is no other way for Firefox\n * because Firefox's CDP implementation does not support auto-attach.\n *\n * Firefox does not support targetInfoChanged and detachedFromTarget events:\n *\n * - https://bugzilla.mozilla.org/show_bug.cgi?id=1610855\n * - https://bugzilla.mozilla.org/show_bug.cgi?id=1636979\n *   @internal\n */\nexport class FirefoxTargetManager\n  extends EventEmitter\n  implements TargetManager\n{\n  #connection: Connection;\n  /**\n   * Keeps track of the following events: 'Target.targetCreated',\n   * 'Target.targetDestroyed'.\n   *\n   * A target becomes discovered when 'Target.targetCreated' is received.\n   * A target is removed from this map once 'Target.targetDestroyed' is\n   * received.\n   *\n   * `targetFilterCallback` has no effect on this map.\n   */\n  #discoveredTargetsByTargetId = new Map<string, Protocol.Target.TargetInfo>();\n  /**\n   * Keeps track of targets that were created via 'Target.targetCreated'\n   * and which one are not filtered out by `targetFilterCallback`.\n   *\n   * The target is removed from here once it's been destroyed.\n   */\n  #availableTargetsByTargetId = new Map<string, CDPTarget>();\n  /**\n   * Tracks which sessions attach to which target.\n   */\n  #availableTargetsBySessionId = new Map<string, CDPTarget>();\n  /**\n   * If a target was filtered out by `targetFilterCallback`, we still receive\n   * events about it from CDP, but we don't forward them to the rest of Puppeteer.\n   */\n  #ignoredTargets = new Set<string>();\n  #targetFilterCallback: TargetFilterCallback | undefined;\n  #targetFactory: TargetFactory;\n\n  #targetInterceptors = new WeakMap<\n    CDPSession | Connection,\n    TargetInterceptor[]\n  >();\n\n  #attachedToTargetListenersBySession = new WeakMap<\n    CDPSession | Connection,\n    (event: Protocol.Target.AttachedToTargetEvent) => Promise<void>\n  >();\n\n  #initializeDeferred = Deferred.create<void>();\n  #targetsIdsForInit = new Set<string>();\n\n  constructor(\n    connection: Connection,\n    targetFactory: TargetFactory,\n    targetFilterCallback?: TargetFilterCallback\n  ) {\n    super();\n    this.#connection = connection;\n    this.#targetFilterCallback = targetFilterCallback;\n    this.#targetFactory = targetFactory;\n\n    this.#connection.on('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.on('sessiondetached', this.#onSessionDetached);\n    this.setupAttachmentListeners(this.#connection);\n  }\n\n  addTargetInterceptor(\n    client: CDPSession | Connection,\n    interceptor: TargetInterceptor\n  ): void {\n    const interceptors = this.#targetInterceptors.get(client) || [];\n    interceptors.push(interceptor);\n    this.#targetInterceptors.set(client, interceptors);\n  }\n\n  removeTargetInterceptor(\n    client: CDPSession | Connection,\n    interceptor: TargetInterceptor\n  ): void {\n    const interceptors = this.#targetInterceptors.get(client) || [];\n    this.#targetInterceptors.set(\n      client,\n      interceptors.filter(currentInterceptor => {\n        return currentInterceptor !== interceptor;\n      })\n    );\n  }\n\n  setupAttachmentListeners(session: CDPSession | Connection): void {\n    const listener = (event: Protocol.Target.AttachedToTargetEvent) => {\n      return this.#onAttachedToTarget(session, event);\n    };\n    assert(!this.#attachedToTargetListenersBySession.has(session));\n    this.#attachedToTargetListenersBySession.set(session, listener);\n    session.on('Target.attachedToTarget', listener);\n  }\n\n  #onSessionDetached = (session: CDPSession) => {\n    this.removeSessionListeners(session);\n    this.#targetInterceptors.delete(session);\n    this.#availableTargetsBySessionId.delete(session.id());\n  };\n\n  removeSessionListeners(session: CDPSession): void {\n    if (this.#attachedToTargetListenersBySession.has(session)) {\n      session.off(\n        'Target.attachedToTarget',\n        this.#attachedToTargetListenersBySession.get(session)!\n      );\n      this.#attachedToTargetListenersBySession.delete(session);\n    }\n  }\n\n  getAvailableTargets(): Map<string, CDPTarget> {\n    return this.#availableTargetsByTargetId;\n  }\n\n  dispose(): void {\n    this.#connection.off('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);\n  }\n\n  async initialize(): Promise<void> {\n    await this.#connection.send('Target.setDiscoverTargets', {\n      discover: true,\n      filter: [{}],\n    });\n    this.#targetsIdsForInit = new Set(this.#discoveredTargetsByTargetId.keys());\n    await this.#initializeDeferred.valueOrThrow();\n  }\n\n  #onTargetCreated = async (\n    event: Protocol.Target.TargetCreatedEvent\n  ): Promise<void> => {\n    if (this.#discoveredTargetsByTargetId.has(event.targetInfo.targetId)) {\n      return;\n    }\n\n    this.#discoveredTargetsByTargetId.set(\n      event.targetInfo.targetId,\n      event.targetInfo\n    );\n\n    if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {\n      const target = this.#targetFactory(event.targetInfo, undefined);\n      target._initialize();\n      this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);\n      this.#finishInitializationIfReady(target._targetId);\n      return;\n    }\n\n    const target = this.#targetFactory(event.targetInfo, undefined);\n    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {\n      this.#ignoredTargets.add(event.targetInfo.targetId);\n      this.#finishInitializationIfReady(event.targetInfo.targetId);\n      return;\n    }\n    target._initialize();\n    this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);\n    this.emit(TargetManagerEmittedEvents.TargetAvailable, target);\n    this.#finishInitializationIfReady(target._targetId);\n  };\n\n  #onTargetDestroyed = (event: Protocol.Target.TargetDestroyedEvent): void => {\n    this.#discoveredTargetsByTargetId.delete(event.targetId);\n    this.#finishInitializationIfReady(event.targetId);\n    const target = this.#availableTargetsByTargetId.get(event.targetId);\n    if (target) {\n      this.emit(TargetManagerEmittedEvents.TargetGone, target);\n      this.#availableTargetsByTargetId.delete(event.targetId);\n    }\n  };\n\n  #onAttachedToTarget = async (\n    parentSession: Connection | CDPSession,\n    event: Protocol.Target.AttachedToTargetEvent\n  ) => {\n    const targetInfo = event.targetInfo;\n    const session = this.#connection.session(event.sessionId);\n    if (!session) {\n      throw new Error(`Session ${event.sessionId} was not created.`);\n    }\n\n    const target = this.#availableTargetsByTargetId.get(targetInfo.targetId);\n\n    assert(target, `Target ${targetInfo.targetId} is missing`);\n\n    this.setupAttachmentListeners(session);\n\n    this.#availableTargetsBySessionId.set(\n      session.id(),\n      this.#availableTargetsByTargetId.get(targetInfo.targetId)!\n    );\n\n    for (const hook of this.#targetInterceptors.get(parentSession) || []) {\n      if (!(parentSession instanceof Connection)) {\n        assert(this.#availableTargetsBySessionId.has(parentSession.id()));\n      }\n      await hook(\n        target,\n        parentSession instanceof Connection\n          ? null\n          : this.#availableTargetsBySessionId.get(parentSession.id())!\n      );\n    }\n  };\n\n  #finishInitializationIfReady(targetId: string): void {\n    this.#targetsIdsForInit.delete(targetId);\n    if (this.#targetsIdsForInit.size === 0) {\n      this.#initializeDeferred.resolve();\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}