{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EMPTY, catchError, defaultIfEmpty, defer, filter, first, firstValueFrom, from, fromEvent, identity, ignoreElements, map, merge, mergeMap, noop, pipe, raceWith, retry, tap, timer } from '../../../third_party/rxjs/rxjs.js';\nimport { TimeoutError } from '../../common/Errors.js';\nimport { EventEmitter } from '../../common/EventEmitter.js';\nimport { debugError } from '../../common/util.js';\nimport { FilteredLocator, MappedLocator, RaceLocator } from './locators.js';\n/**\n * For observables coming from promises, a delay is needed, otherwise RxJS will\n * never yield in a permanent failure for a promise.\n *\n * We also don't want RxJS to do promise operations to often, so we bump the\n * delay up to 100ms.\n *\n * @internal\n */\nexport const RETRY_DELAY = 100;\n/**\n * All the events that a locator instance may emit.\n *\n * @public\n */\nexport var LocatorEmittedEvents;\n(function (LocatorEmittedEvents) {\n  /**\n   * Emitted every time before the locator performs an action on the located element(s).\n   */\n  LocatorEmittedEvents[\"Action\"] = \"action\";\n})(LocatorEmittedEvents || (LocatorEmittedEvents = {}));\n/**\n * Locators describe a strategy of locating objects and performing an action on\n * them. If the action fails because the object is not ready for the action, the\n * whole operation is retried. Various preconditions for a successful action are\n * checked automatically.\n *\n * @public\n */\nexport class Locator extends EventEmitter {\n  /**\n   * Creates a race between multiple locators but ensures that only a single one\n   * acts.\n   *\n   * @public\n   */\n  static race(locators) {\n    return RaceLocator.create(locators);\n  }\n  /**\n   * @internal\n   */\n  visibility = null;\n  /**\n   * @internal\n   */\n  _timeout = 30000;\n  #ensureElementIsInTheViewport = true;\n  #waitForEnabled = true;\n  #waitForStableBoundingBox = true;\n  /**\n   * @internal\n   */\n  operators = {\n    conditions: (conditions, signal) => {\n      return mergeMap(handle => {\n        return merge(...conditions.map(condition => {\n          return condition(handle, signal);\n        })).pipe(defaultIfEmpty(handle));\n      });\n    },\n    retryAndRaceWithSignalAndTimer: signal => {\n      const candidates = [];\n      if (signal) {\n        candidates.push(fromEvent(signal, 'abort').pipe(map(() => {\n          throw signal.reason;\n        })));\n      }\n      if (this._timeout > 0) {\n        candidates.push(timer(this._timeout).pipe(map(() => {\n          throw new TimeoutError(`Timed out after waiting ${this._timeout}ms`);\n        })));\n      }\n      return pipe(retry({\n        delay: RETRY_DELAY\n      }), raceWith(...candidates));\n    }\n  };\n  // Determines when the locator will timeout for actions.\n  get timeout() {\n    return this._timeout;\n  }\n  on(eventName, handler) {\n    return super.on(eventName, handler);\n  }\n  once(eventName, handler) {\n    return super.once(eventName, handler);\n  }\n  off(eventName, handler) {\n    return super.off(eventName, handler);\n  }\n  setTimeout(timeout) {\n    const locator = this._clone();\n    locator._timeout = timeout;\n    return locator;\n  }\n  setVisibility(visibility) {\n    const locator = this._clone();\n    locator.visibility = visibility;\n    return locator;\n  }\n  setWaitForEnabled(value) {\n    const locator = this._clone();\n    locator.#waitForEnabled = value;\n    return locator;\n  }\n  setEnsureElementIsInTheViewport(value) {\n    const locator = this._clone();\n    locator.#ensureElementIsInTheViewport = value;\n    return locator;\n  }\n  setWaitForStableBoundingBox(value) {\n    const locator = this._clone();\n    locator.#waitForStableBoundingBox = value;\n    return locator;\n  }\n  /**\n   * @internal\n   */\n  copyOptions(locator) {\n    this._timeout = locator._timeout;\n    this.visibility = locator.visibility;\n    this.#waitForEnabled = locator.#waitForEnabled;\n    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;\n    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;\n    return this;\n  }\n  /**\n   * If the element has a \"disabled\" property, wait for the element to be\n   * enabled.\n   */\n  #waitForEnabledIfNeeded = (handle, signal) => {\n    if (!this.#waitForEnabled) {\n      return EMPTY;\n    }\n    return from(handle.frame.page().waitForFunction(element => {\n      if (!(element instanceof HTMLElement)) {\n        return true;\n      }\n      const isNativeFormControl = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTION', 'OPTGROUP'].includes(element.nodeName);\n      return !isNativeFormControl || !element.hasAttribute('disabled');\n    }, {\n      timeout: this._timeout,\n      signal\n    }, handle)).pipe(ignoreElements());\n  };\n  /**\n   * Compares the bounding box of the element for two consecutive animation\n   * frames and waits till they are the same.\n   */\n  #waitForStableBoundingBoxIfNeeded = handle => {\n    if (!this.#waitForStableBoundingBox) {\n      return EMPTY;\n    }\n    return defer(() => {\n      // Note we don't use waitForFunction because that relies on RAF.\n      return from(handle.evaluate(element => {\n        return new Promise(resolve => {\n          window.requestAnimationFrame(() => {\n            const rect1 = element.getBoundingClientRect();\n            window.requestAnimationFrame(() => {\n              const rect2 = element.getBoundingClientRect();\n              resolve([{\n                x: rect1.x,\n                y: rect1.y,\n                width: rect1.width,\n                height: rect1.height\n              }, {\n                x: rect2.x,\n                y: rect2.y,\n                width: rect2.width,\n                height: rect2.height\n              }]);\n            });\n          });\n        });\n      }));\n    }).pipe(first(([rect1, rect2]) => {\n      return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;\n    }), retry({\n      delay: RETRY_DELAY\n    }), ignoreElements());\n  };\n  /**\n   * Checks if the element is in the viewport and auto-scrolls it if it is not.\n   */\n  #ensureElementIsInTheViewportIfNeeded = handle => {\n    if (!this.#ensureElementIsInTheViewport) {\n      return EMPTY;\n    }\n    return from(handle.isIntersectingViewport({\n      threshold: 0\n    })).pipe(filter(isIntersectingViewport => {\n      return !isIntersectingViewport;\n    }), mergeMap(() => {\n      return from(handle.scrollIntoView());\n    }), mergeMap(() => {\n      return defer(() => {\n        return from(handle.isIntersectingViewport({\n          threshold: 0\n        }));\n      }).pipe(first(identity), retry({\n        delay: RETRY_DELAY\n      }), ignoreElements());\n    }));\n  };\n  #click(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded, this.#waitForEnabledIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEmittedEvents.Action);\n    }), mergeMap(handle => {\n      return from(handle.click(options)).pipe(catchError((_, caught) => {\n        void handle.dispose().catch(debugError);\n        return caught;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #fill(value, options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded, this.#waitForEnabledIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEmittedEvents.Action);\n    }), mergeMap(handle => {\n      return from(handle.evaluate(el => {\n        if (el instanceof HTMLSelectElement) {\n          return 'select';\n        }\n        if (el instanceof HTMLInputElement) {\n          if (new Set(['textarea', 'text', 'url', 'tel', 'search', 'password', 'number', 'email']).has(el.type)) {\n            return 'typeable-input';\n          } else {\n            return 'other-input';\n          }\n        }\n        if (el.isContentEditable) {\n          return 'contenteditable';\n        }\n        return 'unknown';\n      })).pipe(mergeMap(inputType => {\n        switch (inputType) {\n          case 'select':\n            return from(handle.select(value).then(noop));\n          case 'contenteditable':\n          case 'typeable-input':\n            return from(handle.evaluate((input, newValue) => {\n              const currentValue = input.isContentEditable ? input.innerText : input.value;\n              // Clear the input if the current value does not match the filled\n              // out value.\n              if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {\n                if (input.isContentEditable) {\n                  input.innerText = '';\n                } else {\n                  input.value = '';\n                }\n                return newValue;\n              }\n              const originalValue = input.isContentEditable ? input.innerText : input.value;\n              // If the value is partially filled out, only type the rest. Move\n              // cursor to the end of the common prefix.\n              if (input.isContentEditable) {\n                input.innerText = '';\n                input.innerText = originalValue;\n              } else {\n                input.value = '';\n                input.value = originalValue;\n              }\n              return newValue.substring(originalValue.length);\n            }, value)).pipe(mergeMap(textToType => {\n              return from(handle.type(textToType));\n            }));\n          case 'other-input':\n            return from(handle.focus()).pipe(mergeMap(() => {\n              return from(handle.evaluate((input, value) => {\n                input.value = value;\n                input.dispatchEvent(new Event('input', {\n                  bubbles: true\n                }));\n                input.dispatchEvent(new Event('change', {\n                  bubbles: true\n                }));\n              }, value));\n            }));\n          case 'unknown':\n            throw new Error(`Element cannot be filled out.`);\n        }\n      })).pipe(catchError((_, caught) => {\n        void handle.dispose().catch(debugError);\n        return caught;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #hover(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEmittedEvents.Action);\n    }), mergeMap(handle => {\n      return from(handle.hover()).pipe(catchError((_, caught) => {\n        void handle.dispose().catch(debugError);\n        return caught;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #scroll(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEmittedEvents.Action);\n    }), mergeMap(handle => {\n      return from(handle.evaluate((el, scrollTop, scrollLeft) => {\n        if (scrollTop !== undefined) {\n          el.scrollTop = scrollTop;\n        }\n        if (scrollLeft !== undefined) {\n          el.scrollLeft = scrollLeft;\n        }\n      }, options?.scrollTop, options?.scrollLeft)).pipe(catchError((_, caught) => {\n        void handle.dispose().catch(debugError);\n        return caught;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  /**\n   * Clones the locator.\n   */\n  clone() {\n    return this._clone();\n  }\n  /**\n   * Waits for the locator to get a handle from the page.\n   *\n   * @public\n   */\n  async waitHandle(options) {\n    return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal)));\n  }\n  /**\n   * Waits for the locator to get the serialized value from the page.\n   *\n   * Note this requires the value to be JSON-serializable.\n   *\n   * @public\n   */\n  async wait(options) {\n    const handle = await this.waitHandle(options);\n    try {\n      return await handle.jsonValue();\n    } finally {\n      void handle.dispose().catch(debugError);\n    }\n  }\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @public\n   */\n  map(mapper) {\n    return new MappedLocator(this._clone(), mapper);\n  }\n  /**\n   * Creates an expectation that is evaluated against located values.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @public\n   */\n  filter(predicate) {\n    return new FilteredLocator(this._clone(), predicate);\n  }\n  click(options) {\n    return firstValueFrom(this.#click(options));\n  }\n  /**\n   * Fills out the input identified by the locator using the provided value. The\n   * type of the input is determined at runtime and the appropriate fill-out\n   * method is chosen based on the type. contenteditable, selector, inputs are\n   * supported.\n   */\n  fill(value, options) {\n    return firstValueFrom(this.#fill(value, options));\n  }\n  hover(options) {\n    return firstValueFrom(this.#hover(options));\n  }\n  scroll(options) {\n    return firstValueFrom(this.#scroll(options));\n  }\n}","map":{"version":3,"names":["EMPTY","catchError","defaultIfEmpty","defer","filter","first","firstValueFrom","from","fromEvent","identity","ignoreElements","map","merge","mergeMap","noop","pipe","raceWith","retry","tap","timer","TimeoutError","EventEmitter","debugError","FilteredLocator","MappedLocator","RaceLocator","RETRY_DELAY","LocatorEmittedEvents","Locator","race","locators","create","visibility","_timeout","ensureElementIsInTheViewport","waitForEnabled","waitForStableBoundingBox","operators","conditions","signal","handle","condition","retryAndRaceWithSignalAndTimer","candidates","push","reason","delay","timeout","on","eventName","handler","once","off","setTimeout","locator","_clone","setVisibility","setWaitForEnabled","value","setEnsureElementIsInTheViewport","setWaitForStableBoundingBox","copyOptions","waitForEnabledIfNeeded","#waitForEnabledIfNeeded","frame","page","waitForFunction","element","HTMLElement","isNativeFormControl","includes","nodeName","hasAttribute","waitForStableBoundingBoxIfNeeded","evaluate","Promise","resolve","window","requestAnimationFrame","rect1","getBoundingClientRect","rect2","x","y","width","height","ensureElementIsInTheViewportIfNeeded","isIntersectingViewport","threshold","scrollIntoView","click","#click","options","_wait","emit","Action","_","caught","dispose","catch","fill","#fill","el","HTMLSelectElement","HTMLInputElement","Set","has","type","isContentEditable","inputType","select","then","input","newValue","currentValue","innerText","length","startsWith","originalValue","substring","textToType","focus","dispatchEvent","Event","bubbles","Error","hover","#hover","scroll","#scroll","scrollTop","scrollLeft","undefined","clone","waitHandle","wait","jsonValue","mapper","predicate"],"sources":["/home/adityasinha/Desktop/React/topdf/node_modules/puppeteer-core/src/api/locators/Locator.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  EMPTY,\n  Observable,\n  OperatorFunction,\n  catchError,\n  defaultIfEmpty,\n  defer,\n  filter,\n  first,\n  firstValueFrom,\n  from,\n  fromEvent,\n  identity,\n  ignoreElements,\n  map,\n  merge,\n  mergeMap,\n  noop,\n  pipe,\n  raceWith,\n  retry,\n  tap,\n  timer,\n} from '../../../third_party/rxjs/rxjs.js';\nimport {TimeoutError} from '../../common/Errors.js';\nimport {EventEmitter} from '../../common/EventEmitter.js';\nimport {HandleFor} from '../../common/types.js';\nimport {debugError} from '../../common/util.js';\nimport {BoundingBox, ClickOptions, ElementHandle} from '../ElementHandle.js';\n\nimport {\n  Action,\n  AwaitedLocator,\n  FilteredLocator,\n  MappedLocator,\n  Mapper,\n  Predicate,\n  RaceLocator,\n} from './locators.js';\n\n/**\n * For observables coming from promises, a delay is needed, otherwise RxJS will\n * never yield in a permanent failure for a promise.\n *\n * We also don't want RxJS to do promise operations to often, so we bump the\n * delay up to 100ms.\n *\n * @internal\n */\nexport const RETRY_DELAY = 100;\n\n/**\n * @public\n */\nexport type VisibilityOption = 'hidden' | 'visible' | null;\n\n/**\n * @public\n */\nexport interface LocatorOptions {\n  /**\n   * Whether to wait for the element to be `visible` or `hidden`. `null` to\n   * disable visibility checks.\n   */\n  visibility: VisibilityOption;\n  /**\n   * Total timeout for the entire locator operation.\n   *\n   * Pass `0` to disable timeout.\n   *\n   * @defaultValue `Page.getDefaultTimeout()`\n   */\n  timeout: number;\n  /**\n   * Whether to scroll the element into viewport if not in the viewprot already.\n   * @defaultValue `true`\n   */\n  ensureElementIsInTheViewport: boolean;\n  /**\n   * Whether to wait for input elements to become enabled before the action.\n   * Applicable to `click` and `fill` actions.\n   * @defaultValue `true`\n   */\n  waitForEnabled: boolean;\n  /**\n   * Whether to wait for the element's bounding box to be same between two\n   * animation frames.\n   * @defaultValue `true`\n   */\n  waitForStableBoundingBox: boolean;\n}\n\n/**\n * @public\n */\nexport interface ActionOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport type LocatorClickOptions = ClickOptions & ActionOptions;\n\n/**\n * @public\n */\nexport interface LocatorScrollOptions extends ActionOptions {\n  scrollTop?: number;\n  scrollLeft?: number;\n}\n\n/**\n * All the events that a locator instance may emit.\n *\n * @public\n */\nexport enum LocatorEmittedEvents {\n  /**\n   * Emitted every time before the locator performs an action on the located element(s).\n   */\n  Action = 'action',\n}\n\n/**\n * @public\n */\nexport interface LocatorEventObject {\n  [LocatorEmittedEvents.Action]: never;\n}\n\n/**\n * Locators describe a strategy of locating objects and performing an action on\n * them. If the action fails because the object is not ready for the action, the\n * whole operation is retried. Various preconditions for a successful action are\n * checked automatically.\n *\n * @public\n */\nexport abstract class Locator<T> extends EventEmitter {\n  /**\n   * Creates a race between multiple locators but ensures that only a single one\n   * acts.\n   *\n   * @public\n   */\n  static race<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return RaceLocator.create(locators);\n  }\n\n  /**\n   * Used for nominally typing {@link Locator}.\n   */\n  declare _?: T;\n\n  /**\n   * @internal\n   */\n  protected visibility: VisibilityOption = null;\n  /**\n   * @internal\n   */\n  protected _timeout = 30_000;\n  #ensureElementIsInTheViewport = true;\n  #waitForEnabled = true;\n  #waitForStableBoundingBox = true;\n\n  /**\n   * @internal\n   */\n  protected operators = {\n    conditions: (\n      conditions: Array<Action<T, never>>,\n      signal?: AbortSignal\n    ): OperatorFunction<HandleFor<T>, HandleFor<T>> => {\n      return mergeMap((handle: HandleFor<T>) => {\n        return merge(\n          ...conditions.map(condition => {\n            return condition(handle, signal);\n          })\n        ).pipe(defaultIfEmpty(handle));\n      });\n    },\n    retryAndRaceWithSignalAndTimer: <T>(\n      signal?: AbortSignal\n    ): OperatorFunction<T, T> => {\n      const candidates = [];\n      if (signal) {\n        candidates.push(\n          fromEvent(signal, 'abort').pipe(\n            map(() => {\n              throw signal.reason;\n            })\n          )\n        );\n      }\n      if (this._timeout > 0) {\n        candidates.push(\n          timer(this._timeout).pipe(\n            map(() => {\n              throw new TimeoutError(\n                `Timed out after waiting ${this._timeout}ms`\n              );\n            })\n          )\n        );\n      }\n      return pipe(\n        retry({delay: RETRY_DELAY}),\n        raceWith<T, never[]>(...candidates)\n      );\n    },\n  };\n\n  // Determines when the locator will timeout for actions.\n  get timeout(): number {\n    return this._timeout;\n  }\n\n  override on<K extends keyof LocatorEventObject>(\n    eventName: K,\n    handler: (event: LocatorEventObject[K]) => void\n  ): this {\n    return super.on(eventName, handler);\n  }\n\n  override once<K extends keyof LocatorEventObject>(\n    eventName: K,\n    handler: (event: LocatorEventObject[K]) => void\n  ): this {\n    return super.once(eventName, handler);\n  }\n\n  override off<K extends keyof LocatorEventObject>(\n    eventName: K,\n    handler: (event: LocatorEventObject[K]) => void\n  ): this {\n    return super.off(eventName, handler);\n  }\n\n  setTimeout(timeout: number): Locator<T> {\n    const locator = this._clone();\n    locator._timeout = timeout;\n    return locator;\n  }\n\n  setVisibility<NodeType extends Node>(\n    this: Locator<NodeType>,\n    visibility: VisibilityOption\n  ): Locator<NodeType> {\n    const locator = this._clone();\n    locator.visibility = visibility;\n    return locator;\n  }\n\n  setWaitForEnabled<NodeType extends Node>(\n    this: Locator<NodeType>,\n    value: boolean\n  ): Locator<NodeType> {\n    const locator = this._clone();\n    locator.#waitForEnabled = value;\n    return locator;\n  }\n\n  setEnsureElementIsInTheViewport<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: boolean\n  ): Locator<ElementType> {\n    const locator = this._clone();\n    locator.#ensureElementIsInTheViewport = value;\n    return locator;\n  }\n\n  setWaitForStableBoundingBox<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: boolean\n  ): Locator<ElementType> {\n    const locator = this._clone();\n    locator.#waitForStableBoundingBox = value;\n    return locator;\n  }\n\n  /**\n   * @internal\n   */\n  copyOptions<T>(locator: Locator<T>): this {\n    this._timeout = locator._timeout;\n    this.visibility = locator.visibility;\n    this.#waitForEnabled = locator.#waitForEnabled;\n    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;\n    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;\n    return this;\n  }\n\n  /**\n   * If the element has a \"disabled\" property, wait for the element to be\n   * enabled.\n   */\n  #waitForEnabledIfNeeded = <ElementType extends Node>(\n    handle: HandleFor<ElementType>,\n    signal?: AbortSignal\n  ): Observable<never> => {\n    if (!this.#waitForEnabled) {\n      return EMPTY;\n    }\n    return from(\n      handle.frame.page().waitForFunction(\n        element => {\n          if (!(element instanceof HTMLElement)) {\n            return true;\n          }\n          const isNativeFormControl = [\n            'BUTTON',\n            'INPUT',\n            'SELECT',\n            'TEXTAREA',\n            'OPTION',\n            'OPTGROUP',\n          ].includes(element.nodeName);\n          return !isNativeFormControl || !element.hasAttribute('disabled');\n        },\n        {\n          timeout: this._timeout,\n          signal,\n        },\n        handle\n      )\n    ).pipe(ignoreElements());\n  };\n\n  /**\n   * Compares the bounding box of the element for two consecutive animation\n   * frames and waits till they are the same.\n   */\n  #waitForStableBoundingBoxIfNeeded = <ElementType extends Element>(\n    handle: HandleFor<ElementType>\n  ): Observable<never> => {\n    if (!this.#waitForStableBoundingBox) {\n      return EMPTY;\n    }\n    return defer(() => {\n      // Note we don't use waitForFunction because that relies on RAF.\n      return from(\n        handle.evaluate(element => {\n          return new Promise<[BoundingBox, BoundingBox]>(resolve => {\n            window.requestAnimationFrame(() => {\n              const rect1 = element.getBoundingClientRect();\n              window.requestAnimationFrame(() => {\n                const rect2 = element.getBoundingClientRect();\n                resolve([\n                  {\n                    x: rect1.x,\n                    y: rect1.y,\n                    width: rect1.width,\n                    height: rect1.height,\n                  },\n                  {\n                    x: rect2.x,\n                    y: rect2.y,\n                    width: rect2.width,\n                    height: rect2.height,\n                  },\n                ]);\n              });\n            });\n          });\n        })\n      );\n    }).pipe(\n      first(([rect1, rect2]) => {\n        return (\n          rect1.x === rect2.x &&\n          rect1.y === rect2.y &&\n          rect1.width === rect2.width &&\n          rect1.height === rect2.height\n        );\n      }),\n      retry({delay: RETRY_DELAY}),\n      ignoreElements()\n    );\n  };\n\n  /**\n   * Checks if the element is in the viewport and auto-scrolls it if it is not.\n   */\n  #ensureElementIsInTheViewportIfNeeded = <ElementType extends Element>(\n    handle: HandleFor<ElementType>\n  ): Observable<never> => {\n    if (!this.#ensureElementIsInTheViewport) {\n      return EMPTY;\n    }\n    return from(handle.isIntersectingViewport({threshold: 0})).pipe(\n      filter(isIntersectingViewport => {\n        return !isIntersectingViewport;\n      }),\n      mergeMap(() => {\n        return from(handle.scrollIntoView());\n      }),\n      mergeMap(() => {\n        return defer(() => {\n          return from(handle.isIntersectingViewport({threshold: 0}));\n        }).pipe(first(identity), retry({delay: RETRY_DELAY}), ignoreElements());\n      })\n    );\n  };\n\n  #click<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorClickOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n          this.#waitForEnabledIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEmittedEvents.Action);\n      }),\n      mergeMap(handle => {\n        return from(handle.click(options)).pipe(\n          catchError((_, caught) => {\n            void handle.dispose().catch(debugError);\n            return caught;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #fill<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: string,\n    options?: Readonly<ActionOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n          this.#waitForEnabledIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEmittedEvents.Action);\n      }),\n      mergeMap(handle => {\n        return from(\n          (handle as unknown as ElementHandle<HTMLElement>).evaluate(el => {\n            if (el instanceof HTMLSelectElement) {\n              return 'select';\n            }\n            if (el instanceof HTMLInputElement) {\n              if (\n                new Set([\n                  'textarea',\n                  'text',\n                  'url',\n                  'tel',\n                  'search',\n                  'password',\n                  'number',\n                  'email',\n                ]).has(el.type)\n              ) {\n                return 'typeable-input';\n              } else {\n                return 'other-input';\n              }\n            }\n\n            if (el.isContentEditable) {\n              return 'contenteditable';\n            }\n\n            return 'unknown';\n          })\n        )\n          .pipe(\n            mergeMap(inputType => {\n              switch (inputType) {\n                case 'select':\n                  return from(handle.select(value).then(noop));\n                case 'contenteditable':\n                case 'typeable-input':\n                  return from(\n                    (\n                      handle as unknown as ElementHandle<HTMLInputElement>\n                    ).evaluate((input, newValue) => {\n                      const currentValue = input.isContentEditable\n                        ? input.innerText\n                        : input.value;\n\n                      // Clear the input if the current value does not match the filled\n                      // out value.\n                      if (\n                        newValue.length <= currentValue.length ||\n                        !newValue.startsWith(input.value)\n                      ) {\n                        if (input.isContentEditable) {\n                          input.innerText = '';\n                        } else {\n                          input.value = '';\n                        }\n                        return newValue;\n                      }\n                      const originalValue = input.isContentEditable\n                        ? input.innerText\n                        : input.value;\n\n                      // If the value is partially filled out, only type the rest. Move\n                      // cursor to the end of the common prefix.\n                      if (input.isContentEditable) {\n                        input.innerText = '';\n                        input.innerText = originalValue;\n                      } else {\n                        input.value = '';\n                        input.value = originalValue;\n                      }\n                      return newValue.substring(originalValue.length);\n                    }, value)\n                  ).pipe(\n                    mergeMap(textToType => {\n                      return from(handle.type(textToType));\n                    })\n                  );\n                case 'other-input':\n                  return from(handle.focus()).pipe(\n                    mergeMap(() => {\n                      return from(\n                        handle.evaluate((input, value) => {\n                          (input as HTMLInputElement).value = value;\n                          input.dispatchEvent(\n                            new Event('input', {bubbles: true})\n                          );\n                          input.dispatchEvent(\n                            new Event('change', {bubbles: true})\n                          );\n                        }, value)\n                      );\n                    })\n                  );\n                case 'unknown':\n                  throw new Error(`Element cannot be filled out.`);\n              }\n            })\n          )\n          .pipe(\n            catchError((_, caught) => {\n              void handle.dispose().catch(debugError);\n              return caught;\n            })\n          );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #hover<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<ActionOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEmittedEvents.Action);\n      }),\n      mergeMap(handle => {\n        return from(handle.hover()).pipe(\n          catchError((_, caught) => {\n            void handle.dispose().catch(debugError);\n            return caught;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #scroll<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorScrollOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEmittedEvents.Action);\n      }),\n      mergeMap(handle => {\n        return from(\n          handle.evaluate(\n            (el, scrollTop, scrollLeft) => {\n              if (scrollTop !== undefined) {\n                el.scrollTop = scrollTop;\n              }\n              if (scrollLeft !== undefined) {\n                el.scrollLeft = scrollLeft;\n              }\n            },\n            options?.scrollTop,\n            options?.scrollLeft\n          )\n        ).pipe(\n          catchError((_, caught) => {\n            void handle.dispose().catch(debugError);\n            return caught;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  /**\n   * @internal\n   */\n  abstract _clone(): Locator<T>;\n\n  /**\n   * @internal\n   */\n  abstract _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>>;\n\n  /**\n   * Clones the locator.\n   */\n  clone(): Locator<T> {\n    return this._clone();\n  }\n\n  /**\n   * Waits for the locator to get a handle from the page.\n   *\n   * @public\n   */\n  async waitHandle(options?: Readonly<ActionOptions>): Promise<HandleFor<T>> {\n    return await firstValueFrom(\n      this._wait(options).pipe(\n        this.operators.retryAndRaceWithSignalAndTimer(options?.signal)\n      )\n    );\n  }\n\n  /**\n   * Waits for the locator to get the serialized value from the page.\n   *\n   * Note this requires the value to be JSON-serializable.\n   *\n   * @public\n   */\n  async wait(options?: Readonly<ActionOptions>): Promise<T> {\n    const handle = await this.waitHandle(options);\n    try {\n      return await handle.jsonValue();\n    } finally {\n      void handle.dispose().catch(debugError);\n    }\n  }\n\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @public\n   */\n  map<To>(mapper: Mapper<T, To>): Locator<To> {\n    return new MappedLocator(this._clone(), mapper);\n  }\n\n  /**\n   * Creates an expectation that is evaluated against located values.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @public\n   */\n  filter<S extends T>(predicate: Predicate<T, S>): Locator<S> {\n    return new FilteredLocator(this._clone(), predicate);\n  }\n\n  click<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorClickOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#click(options));\n  }\n\n  /**\n   * Fills out the input identified by the locator using the provided value. The\n   * type of the input is determined at runtime and the appropriate fill-out\n   * method is chosen based on the type. contenteditable, selector, inputs are\n   * supported.\n   */\n  fill<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: string,\n    options?: Readonly<ActionOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#fill(value, options));\n  }\n\n  hover<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<ActionOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#hover(options));\n  }\n\n  scroll<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorScrollOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#scroll(options));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}